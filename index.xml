<?xml-stylesheet href="/rss.xsl" type="text/xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>归零幻想</title>
    <link>https://ntutn.top/</link>
    <description>Recent content on 归零幻想</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <copyright>CC BY-SA 4.0</copyright>
    <lastBuildDate>Wed, 14 Sep 2022 02:55:44 +0800</lastBuildDate>
    
        <atom:link href="https://ntutn.top/index.xml" rel="self" type="application/rss+xml" />
    
    
    
        <item>
        <title>打造一个接入简单的通用banner组件</title>
        <link>https://ntutn.top/posts/%E6%89%93%E9%80%A0%E4%B8%80%E4%B8%AA%E6%8E%A5%E5%85%A5%E7%AE%80%E5%8D%95%E7%9A%84%E9%80%9A%E7%94%A8banner%E7%BB%84%E4%BB%B6/</link>
        <pubDate>Wed, 14 Sep 2022 02:55:44 +0800</pubDate>
        
        <guid>https://ntutn.top/posts/%E6%89%93%E9%80%A0%E4%B8%80%E4%B8%AA%E6%8E%A5%E5%85%A5%E7%AE%80%E5%8D%95%E7%9A%84%E9%80%9A%E7%94%A8banner%E7%BB%84%E4%BB%B6/</guid>
        <description>归零幻想 https://ntutn.top/posts/%E6%89%93%E9%80%A0%E4%B8%80%E4%B8%AA%E6%8E%A5%E5%85%A5%E7%AE%80%E5%8D%95%E7%9A%84%E9%80%9A%E7%94%A8banner%E7%BB%84%E4%BB%B6/ -&lt;p&gt;banner是一个常见的活动入口形式，给我们的印象一般是一些不断轮播的图片。但，有些事情，远没有看上去那么简单。&lt;/p&gt;
&lt;h1 id=&#34;banner使用&#34;&gt;banner使用&lt;/h1&gt;
&lt;p&gt;特点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;支持不同类型卡片混排&lt;/li&gt;
&lt;li&gt;支持比较复杂的轮播逻辑&lt;/li&gt;
&lt;li&gt;布局和展示逻辑完全交给业务方ViewHolder控制，可以灵活定制。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;先看最终使用效果，也许你能提起一些兴趣。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.bilibili.com/video/BV1Ed4y137T7/&#34;&gt;https://www.bilibili.com/video/BV1Ed4y137T7/&lt;/a&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;将banner添加到你的布局中，&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-xml&#34; data-lang=&#34;xml&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;&amp;lt;top.ntutn.zerohelper.view.banner.BannerView&lt;/span&gt;  
    &lt;span style=&#34;color:#658b00&#34;&gt;android:id=&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;@+id/banner_view&amp;#34;&lt;/span&gt;  
    &lt;span style=&#34;color:#658b00&#34;&gt;android:layout_width=&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;match_parent&amp;#34;&lt;/span&gt;  
    &lt;span style=&#34;color:#658b00&#34;&gt;android:layout_height=&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;300dp&amp;#34;&lt;/span&gt;  
    &lt;span style=&#34;color:#658b00&#34;&gt;android:layout_gravity=&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;center&amp;#34;&lt;/span&gt;  
    &lt;span style=&#34;color:#658b00&#34;&gt;android:layout_margin=&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;16dp&amp;#34;&lt;/span&gt;  
    &lt;span style=&#34;color:#658b00&#34;&gt;tools:background=&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;@tools:sample/backgrounds/scenic&amp;#34;&lt;/span&gt;  
    &lt;span style=&#34;color:#658b00&#34;&gt;app:cardCornerRadius=&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;8dp&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;/&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ol&gt;
&lt;li&gt;准备一个或多个ViewHolder，实现业务展示和播控逻辑。&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-kotlin&#34; data-lang=&#34;kotlin&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;ImageBannerData&lt;/span&gt;(&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;var&lt;/span&gt; url: String = &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;): BannerData {  
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;override&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;val&lt;/span&gt; holderKey: String  
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;get&lt;/span&gt;() = ImageBannerViewHolder.key  
}  

&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;ImageBannerViewHolder&lt;/span&gt;(&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;val&lt;/span&gt; binding: ItemImageBannerBinding) : BannerViewHolder(binding.root) {  
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;companion&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;object&lt;/span&gt;: IBannerViewHolderFactory {  
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;override&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;val&lt;/span&gt; key: String  
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;get&lt;/span&gt;() = &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;_image&amp;#34;&lt;/span&gt;  

        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;override&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;newInstance&lt;/span&gt;(parent: ViewGroup): BannerViewHolder {  
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;val&lt;/span&gt; inflater = LayoutInflater.from(parent.context)  
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; ImageBannerViewHolder(  
                ItemImageBannerBinding.inflate(inflater, parent, &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;false&lt;/span&gt;)  
            )  
        }  
    }  

    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;override&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;onBind&lt;/span&gt;(&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;data&lt;/span&gt;: BannerData) {  
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;data&lt;/span&gt; !is ImageBannerData) {  
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt;  
        }  
        Glide.with(binding.bannerImageView)  
            .load(&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;data&lt;/span&gt;.url)  
            .placeholder(R.drawable.ic_baseline_photo_24)  
            .into(binding.bannerImageView)  
    }  

    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;override&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;onSelect&lt;/span&gt;() {  
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;super&lt;/span&gt;.onSelect()  
        &lt;span style=&#34;color:#228b22&#34;&gt;// 3s后标记播放完成
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        selectScope.launch {  
            delay(&lt;span style=&#34;color:#b452cd&#34;&gt;3000L&lt;/span&gt;)  
            playDone()  
        }  
    }  
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ol&gt;
&lt;li&gt;初始化Banner和绑定数据，记得最后要销毁哦&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-kotlin&#34; data-lang=&#34;kotlin&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;BannerViewActivity&lt;/span&gt; : AppCompatActivity() {  
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;lateinit&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;var&lt;/span&gt; binding: ActivityBannerViewBinding  

    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;override&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;onCreate&lt;/span&gt;(savedInstanceState: Bundle?) {  
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;super&lt;/span&gt;.onCreate(savedInstanceState)  
        binding = ActivityBannerViewBinding.inflate(layoutInflater)  
        setContentView(binding.root)  
        bindView()  
        bindData()  
    }  

    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;bindView&lt;/span&gt;() {  
        &lt;span style=&#34;color:#228b22&#34;&gt;// 初始化banner
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        binding.bannerView.initViewPager2()  
        &lt;span style=&#34;color:#228b22&#34;&gt;// 注册VH
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        binding.bannerView.registerViewHolder(ImageBannerViewHolder.Companion)  
        binding.bannerView.registerViewHolder(TextBannerViewHolder.Companion)  
    }  

    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;bindData&lt;/span&gt;() { 
        &lt;span style=&#34;color:#228b22&#34;&gt;// 绑定数据 
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        binding.bannerView.setData(  
            buildList {  
                repeat(&lt;span style=&#34;color:#b452cd&#34;&gt;20&lt;/span&gt;) {  
                    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (listOf(&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;true&lt;/span&gt;, &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;false&lt;/span&gt;).random()) {  
                        add(ImageBannerData(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;https://fakeimg.pl/400x300/&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;${randomColor()}&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;/?text=&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;$it&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;&lt;/span&gt;))  
                    } &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;else&lt;/span&gt; {  
                        add(TextBannerData(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;This is #&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;$it&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt; ViewHolder.&amp;#34;&lt;/span&gt;))  
                    }  
                }  
            }        )  
    }  

    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;randomColor&lt;/span&gt;(): String {  
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;val&lt;/span&gt; characters = &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;0123456789ABCDEF&amp;#34;&lt;/span&gt;  
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; buildString { repeat(&lt;span style=&#34;color:#b452cd&#34;&gt;6&lt;/span&gt;) { append(characters.random()) } }  
    }  

    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;override&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;onStart&lt;/span&gt;() {  
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;super&lt;/span&gt;.onStart()  
        &lt;span style=&#34;color:#228b22&#34;&gt;// 开启自动轮播
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        binding.bannerView.enableAutoSwitch()  
    }  

    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;override&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;onStop&lt;/span&gt;() {  
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;super&lt;/span&gt;.onStop()  
        &lt;span style=&#34;color:#228b22&#34;&gt;// 禁止自动轮播
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        binding.bannerView.disableAutoSwitch()  
    }  

    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;override&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;onDestroy&lt;/span&gt;() {  
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;super&lt;/span&gt;.onDestroy()
        &lt;span style=&#34;color:#228b22&#34;&gt;// 记得销毁控件  
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        binding.bannerView.release()  
    }  
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h1 id=&#34;banner设计&#34;&gt;banner设计&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;https://images.ntutn.top/2022/09/46cd2e16328c8030e8be7b2473eba6c7.png&#34; alt=&#34;banner结构&#34;&gt;&lt;/p&gt;
&lt;p&gt;banner整体上使用一个自定义ViewGroup嵌套一个ViewPager2实现。每张图片是一个ViewHolder，业务方可以实现自己需要的任何布局。&lt;/p&gt;
&lt;h2 id=&#34;vh创建解耦&#34;&gt;VH创建解耦&lt;/h2&gt;
&lt;p&gt;我们知道ViewPager2实际上就是用RecyclerView实现的，而ViewHolder要交给业务方实现，那么ViewHolder的创建逻辑就要从我们的BannerAdapter中分离出去了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://images.ntutn.top/2022/09/eaebc18f4dc6808a518176f4793259dc.png&#34; alt=&#34;ViewHolder创建解耦&#34;&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-kotlin&#34; data-lang=&#34;kotlin&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;interface&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;BannerData&lt;/span&gt; {  
    &lt;span style=&#34;color:#228b22&#34;&gt;// holderFactory.key  
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;val&lt;/span&gt; holderKey: String  
}

&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;interface&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;IBannerViewHolderFactory&lt;/span&gt; {  
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;val&lt;/span&gt; key: String  
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;newInstance&lt;/span&gt;(parent: ViewGroup): BannerViewHolder  
}

&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;BannerAdapter&lt;/span&gt;(&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;val&lt;/span&gt; bannerOperator: BannerOperator) :  
    RecyclerView.Adapter&amp;lt;BannerViewHolder&amp;gt;() {  

    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;val&lt;/span&gt; viewHolderFactoryMap = mutableMapOf&amp;lt;String, IBannerViewHolderFactory&amp;gt;()  
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;val&lt;/span&gt; viewHolderFactoryList = mutableListOf&amp;lt;IBannerViewHolderFactory&amp;gt;()  

    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;var&lt;/span&gt; dataSet: List&amp;lt;BannerData&amp;gt; = listOf()  
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;set&lt;/span&gt;(value) {  
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;field&lt;/span&gt; = value  
            notifyDataSetChanged()  
        }  

    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;registerViewHolder&lt;/span&gt;(factory: IBannerViewHolderFactory) {  
        viewHolderFactoryMap[factory.key] = factory  
        viewHolderFactoryList.add(factory)  
    }  

    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;override&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;onCreateViewHolder&lt;/span&gt;(parent: ViewGroup, viewType: Int): BannerViewHolder {  
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;val&lt;/span&gt; viewHolder = viewHolderFactoryList[viewType].newInstance(parent)  
        viewHolder.bannerOperator = bannerOperator  
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; viewHolder  
    }  

    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;override&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;getItemViewType&lt;/span&gt;(position: Int): Int {  
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;val&lt;/span&gt; key = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (dataSet.isEmpty()) {  
            StubViewHolder.key  
        } &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;else&lt;/span&gt; {  
            dataSet[position % dataSet.size].holderKey  
        }  
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;val&lt;/span&gt; factory = viewHolderFactoryMap[key]  
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; viewHolderFactoryList.indexOf(factory)  
    }  

    ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;无限横滑&#34;&gt;无限横滑&lt;/h2&gt;
&lt;p&gt;这个实现并不难，只要理解RecyclerView.Adapter的几个回调就可以。只要 &lt;code&gt;getItemCount()&lt;/code&gt; 返回 &lt;code&gt;Int.MAX_VALUE&lt;/code&gt; ，然后所有用到position的地方替换为 &lt;code&gt;position % dataSet.size&lt;/code&gt; 即可。我不相信我会遇到头铁滑了2147483647次的头铁用户。&lt;/p&gt;
&lt;h2 id=&#34;卡片选中事件传递&#34;&gt;卡片选中事件传递&lt;/h2&gt;
&lt;p&gt;我预期一个ViewHolder要拿到自己被选中/取消选中状态的回调，用来处理播控状态。&lt;/p&gt;
&lt;h3 id=&#34;选中事件产生&#34;&gt;选中事件产生&lt;/h3&gt;
&lt;p&gt;选中事件是通过对ViewPager2页面事件监听来实现的。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-kotlin&#34; data-lang=&#34;kotlin&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;val&lt;/span&gt; pagerChangeCallback = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;object&lt;/span&gt; &lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;: &lt;/span&gt;&lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;ViewPager2&lt;/span&gt;.OnPageChangeCallback() {  
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;override&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;onPageSelected&lt;/span&gt;(position: Int) {  
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;super&lt;/span&gt;.onPageSelected(position)  
        &lt;span style=&#34;color:#228b22&#34;&gt;// 选中页面发生变化
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    }  
}  

&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;initViewPager2&lt;/span&gt;() {  
    ...
    viewPager2.registerOnPageChangeCallback(pagerChangeCallback)  
}  

&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;release&lt;/span&gt;() {  
    ...
    viewPager2.unregisterOnPageChangeCallback(pagerChangeCallback)  
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;使用livedata传递选中事件&#34;&gt;使用LiveData传递选中事件&lt;/h3&gt;
&lt;p&gt;为了将选中事件传递给VH，我决定让VH监听一个在BannerView中的LiveData来实现。但ViewHolder并不是LifecycleOwner，我们需要手动注册和取消监听。这里我们通常是写在attach和detach回调中来实现的。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-kotlin&#34; data-lang=&#34;kotlin&#34;&gt;&lt;span style=&#34;color:#228b22&#34;&gt;// ViewHolder
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;DemoViewHolder&lt;/span&gt;(&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;val&lt;/span&gt; liveData) {
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;val&lt;/span&gt; observer = ...

    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;onAttach&lt;/span&gt;() {
        liveData.observeForever(observer)
    }

    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;onDetach&lt;/span&gt;() {
        liveData.removeObserver(observer)
    }
}

&lt;span style=&#34;color:#228b22&#34;&gt;// Adapter
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;DemoAdapter&lt;/span&gt; {
    ...

    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;override&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;onViewAttachedToWindow&lt;/span&gt;(holder: BannerViewHolder) {  
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;super&lt;/span&gt;.onViewAttachedToWindow(holder)  
        holder.onAttach()  
    }  

    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;override&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;onViewDetachedFromWindow&lt;/span&gt;(holder: BannerViewHolder) {  
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;super&lt;/span&gt;.onViewDetachedFromWindow(holder)  
        holder.onDetach()  
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;但这样其实是有问题的， &lt;strong&gt;如果Activity直接退出，onViewDetachedFromWindow其实并不会执行，这样就会带来潜在问题。&lt;/strong&gt; 参考 &lt;a href=&#34;https://www.jianshu.com/p/4f66c2c71d8c&#34;&gt;# RecyclerView#Adapter使用中的两个陷阱&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我的办法是使用 &lt;code&gt;WeakHashMap&lt;/code&gt;，不影响holder销毁的同时记录未detach的holder。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-kotlin&#34; data-lang=&#34;kotlin&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;BannerAdapter&lt;/span&gt;(&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;val&lt;/span&gt; bannerOperator: BannerOperator) :  
    RecyclerView.Adapter&amp;lt;BannerViewHolder&amp;gt;() {

    ...

    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;var&lt;/span&gt; detachHolderTasks = WeakHashMap&amp;lt;RecyclerView.ViewHolder, Runnable&amp;gt;()

    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;override&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;onViewAttachedToWindow&lt;/span&gt;(holder: BannerViewHolder) {  
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;super&lt;/span&gt;.onViewAttachedToWindow(holder)  
        holder.onAttach()  
        detachHolderTasks[holder] = Runnable { holder.onDetach() }  
    }  

    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;override&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;onViewDetachedFromWindow&lt;/span&gt;(holder: BannerViewHolder) {  
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;super&lt;/span&gt;.onViewDetachedFromWindow(holder)  
        holder.onDetach()  
        detachHolderTasks.remove(holder)  
    }  

    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;release&lt;/span&gt;() {  
        detachHolderTasks.forEach {  
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;it&lt;/span&gt;.value.run()  
        }  
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;接下来就是实际监听LiveData并转换为事件了。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-kotlin&#34; data-lang=&#34;kotlin&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;abstract&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;BannerViewHolder&lt;/span&gt;(view: View) : RecyclerView.ViewHolder(view) {  
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;protected&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;var&lt;/span&gt; isSelected = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;false&lt;/span&gt;  
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;var&lt;/span&gt; bannerOperator: BannerOperator? = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;null&lt;/span&gt; &lt;span style=&#34;color:#228b22&#34;&gt;// 实际上就是BannerView  
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;var&lt;/span&gt; currentPosition = -&lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;  

    ...

    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;val&lt;/span&gt; selectPositionObserver = Observer&amp;lt;Int&amp;gt; {  
        checkSelectStatus()  
    }  

    &lt;span style=&#34;color:#707a7c&#34;&gt;@CallSuper&lt;/span&gt;  
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;onBind&lt;/span&gt;(position: Int, &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;data&lt;/span&gt;: BannerData) {  
        currentPosition = position  

        onBind(&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;data&lt;/span&gt;)  

        checkSelectStatus(force = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;true&lt;/span&gt;)  
    }  

    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;abstract&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;onBind&lt;/span&gt;(&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;data&lt;/span&gt;: BannerData)  

    &lt;span style=&#34;color:#228b22&#34;&gt;/**  
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;     * @param force 重新bind后，必定触发一次选择事件  
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;     */&lt;/span&gt;  
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;checkSelectStatus&lt;/span&gt;(force: Boolean = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;false&lt;/span&gt;) {  
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (bannerOperator?.selectedPosition?.value == currentPosition) {  
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (force || !isSelected) {  
                onSelect()  
            }  
        }  
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (bannerOperator?.selectedPosition?.value != currentPosition) {  
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (force || isSelected) {  
                onUnSelect()  
            }  
        }  
    }  

    &lt;span style=&#34;color:#707a7c&#34;&gt;@CallSuper&lt;/span&gt;  
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;open&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;onSelect&lt;/span&gt;() {  
        isSelected = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;true&lt;/span&gt;  
    }  

    &lt;span style=&#34;color:#707a7c&#34;&gt;@CallSuper&lt;/span&gt;  
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;open&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;onUnSelect&lt;/span&gt;() {  
        isSelected = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;false&lt;/span&gt;  
    }   
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这里写这么啰嗦是为了处理两个特殊情况：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;数据未走到onBind，但position先发生了变化。&lt;/li&gt;
&lt;li&gt;position未发生变化，但重新bind了不一样的数据。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;保证select事件总在bind之后，且只触发一次。&lt;/p&gt;
&lt;h2 id=&#34;卡片完播事件传递&#34;&gt;卡片完播事件传递&lt;/h2&gt;
&lt;p&gt;卡片完播是banner切换的前置条件，完播时机由VH决定，因而又要将这个事件传递到BannerView，以决定是否切换。&lt;/p&gt;
&lt;p&gt;这里也是我这个banner组件的最大特点， &lt;strong&gt;完播事件产生交给业务方灵活控制，消费则回到组件进行统一管理。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;完播事件产生&#34;&gt;完播事件产生&lt;/h3&gt;
&lt;p&gt;卡片可以认为自己是在onSelect时开始播放，即每次onSelect触发一次playDone。具体何时完播就可以进行灵活的业务逻辑控制了，如5s后完播，视频播放完成后完播，甚至第一次曝光10s完播第二次5s完播等。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-kotlin&#34; data-lang=&#34;kotlin&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;ImageBannerViewHolder&lt;/span&gt;(&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;val&lt;/span&gt; binding: ItemImageBannerBinding) : BannerViewHolder(binding.root) {  
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;override&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;onBind&lt;/span&gt;(&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;data&lt;/span&gt;: BannerData) {  
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;data&lt;/span&gt; !is ImageBannerData) {  
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt;  
        }  
        ...
    }  

    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;override&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;onSelect&lt;/span&gt;() {  
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;super&lt;/span&gt;.onSelect()  
        ThreadUtils.postDelayed({ playDone() }, &lt;span style=&#34;color:#b452cd&#34;&gt;5&lt;/span&gt;_000L)  
    }  
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;因为VH持有BannerView的引用，所以检查下当前是选中卡片就可以直接把完播事件传递给BannerView了。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-kotlin&#34; data-lang=&#34;kotlin&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;abstract&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;BannerViewHolder&lt;/span&gt;(view: View) : RecyclerView.ViewHolder(view) {  
    ...

    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;protected&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;playDone&lt;/span&gt;() {  
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (isSelected) {  
            bannerOperator?.currentItemPlayDone()  
        }  
    }  
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;完播事件的消费&#34;&gt;完播事件的消费&lt;/h3&gt;
&lt;p&gt;我用一个变量标识当前卡片已经完播，并有一个方法来检查并切换到下一张卡片。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-kotlin&#34; data-lang=&#34;kotlin&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;BannerView&lt;/span&gt; &lt;span style=&#34;color:#707a7c&#34;&gt;@JvmOverloads&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;constructor&lt;/span&gt;(  
    context: Context,  
    attrs: AttributeSet? = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;null&lt;/span&gt;,  
    defStyleAttr: Int = &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;  
) : CardView(context, attrs, defStyleAttr), BannerOperator {  

    ...
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;var&lt;/span&gt; pageInvalid = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;false&lt;/span&gt;  

    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;switchNext&lt;/span&gt;() {  
        viewPager2.setCurrentItem(viewPager2.currentItem + &lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;true&lt;/span&gt;)  
    }  

    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;override&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;currentItemPlayDone&lt;/span&gt;() {  
        pageInvalid = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;true&lt;/span&gt;  
        checkAndSwitchPage()  
    }  

    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;checkAndSwitchPage&lt;/span&gt;() {  
        ...
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (pageInvalid) {  
            switchNext()  
        }
    }  
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;用户正在拖动，或者用户刚刚松手我们是不能切换的，否则会干扰用户操作。这里我们通过监听dispatchTouchEvent来实现。&lt;/p&gt;
&lt;p&gt;为什么不是 &lt;code&gt;onInterceptTouchEvent&lt;/code&gt; 回调呢？因为ViewPager2父类RecyclerView在onTouch中开始滑动后会调用getParent().requestDisallowInterceptTouchEvent()阻止父布局继续拦截消息。放在dispatchTouchEvent中可以保证被调用到。&lt;/p&gt;
&lt;p&gt;实现上，用户未松手检查不通过，用户松手时补充一次检查即可。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-kotlin&#34; data-lang=&#34;kotlin&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;BannerView&lt;/span&gt; &lt;span style=&#34;color:#707a7c&#34;&gt;@JvmOverloads&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;constructor&lt;/span&gt;(  
    context: Context,  
    attrs: AttributeSet? = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;null&lt;/span&gt;,  
    defStyleAttr: Int = &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;  
) : CardView(context, attrs, defStyleAttr), BannerOperator {  

    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;var&lt;/span&gt; lastUserTouchTime = -&lt;span style=&#34;color:#b452cd&#34;&gt;1L&lt;/span&gt;  

    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;var&lt;/span&gt; delayAfterUserTouch = &lt;span style=&#34;color:#b452cd&#34;&gt;5000L&lt;/span&gt;  

    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;release&lt;/span&gt;() {  
        clearCheckTask()  
        ...
    }  

    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;override&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;dispatchTouchEvent&lt;/span&gt;(ev: MotionEvent?): Boolean {  
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;when&lt;/span&gt; (ev?.action) {  
            MotionEvent.ACTION_DOWN -&amp;gt; {  
                userDragging = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;true&lt;/span&gt;  
            }  
            MotionEvent.ACTION_UP -&amp;gt; {  
                userDragging = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;false&lt;/span&gt;  
                lastUserTouchTime = SystemClock.uptimeMillis()  
                checkAndSwitchPage()  
            }  
            MotionEvent.ACTION_CANCEL -&amp;gt; {  
                userDragging = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;false&lt;/span&gt;  
                lastUserTouchTime = SystemClock.uptimeMillis()  
                checkAndSwitchPage()  
            }  
        }  
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;super&lt;/span&gt;.dispatchTouchEvent(ev)  
    }  

    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;checkAndSwitchPage&lt;/span&gt;() {  
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (userDragging) {  
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt;  
        }  
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;val&lt;/span&gt; timeAfterLastTouch = SystemClock.uptimeMillis() - lastUserTouchTime  
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (timeAfterLastTouch &amp;lt; delayAfterUserTouch) {  
            &lt;span style=&#34;color:#228b22&#34;&gt;// 用户拖动松手5000 ms内，不自动切换，并规划下一次检查  
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;            handler.postDelayed(checkAutoPlayRunnable, delayAfterUserTouch - timeAfterLastTouch)  
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt;  
        }  
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (pageInvalid) {  
            switchNext()  
        }  
    }  

    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;clearCheckTask&lt;/span&gt;() {  
        handler.removeCallbacks(checkAutoPlayRunnable)  
    }  

    ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;我们还可以把是否开启轮播交给外部控制，实现锁屏停止轮播，解锁后又恢复轮播的效果。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-kotlin&#34; data-lang=&#34;kotlin&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;BannerView&lt;/span&gt; &lt;span style=&#34;color:#707a7c&#34;&gt;@JvmOverloads&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;constructor&lt;/span&gt;(  
    context: Context,  
    attrs: AttributeSet? = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;null&lt;/span&gt;,  
    defStyleAttr: Int = &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;  
) : CardView(context, attrs, defStyleAttr), BannerOperator { 

    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;var&lt;/span&gt; isAutoSwitchEnabled = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;false&lt;/span&gt;

    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;enableAutoSwitch&lt;/span&gt;() {  
        isAutoSwitchEnabled = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;true&lt;/span&gt;  
        checkAndSwitchPage()  
    }  

    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;disableAutoSwitch&lt;/span&gt;() {  
        clearCheckTask()  
        isAutoSwitchEnabled = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;false&lt;/span&gt;  
    }  

    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;checkAndSwitchPage&lt;/span&gt;() {  
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (userDragging) {  
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt;  
        }  
        ...
    }  

    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;clearCheckTask&lt;/span&gt;() {  
        handler.removeCallbacks(checkAutoPlayRunnable)  
    }  
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;selectscope&#34;&gt;selectScope&lt;/h3&gt;
&lt;p&gt;上述完播事件产生中标记完播时使用了这样的代码 &lt;code&gt;ThreadUtils.postDelayed({ playDone() }, 5_000L)&lt;/code&gt; ，其实还是在取消播放时取消下比较严谨。因此可以提供一个CoroutineScope，取消选中状态后自动取消。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-kotlin&#34; data-lang=&#34;kotlin&#34;&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;abstract&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;BannerViewHolder&lt;/span&gt;(view: View) : RecyclerView.ViewHolder(view) {  
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;protected&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;var&lt;/span&gt; isSelected = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;false&lt;/span&gt;  
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;protected&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;lateinit&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;var&lt;/span&gt; selectScope: CoroutineScope  

    &lt;span style=&#34;color:#707a7c&#34;&gt;@CallSuper&lt;/span&gt;  
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;open&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;onSelect&lt;/span&gt;() {  
        selectScope = CoroutineScope(Dispatchers.Main + SupervisorJob())  
        isSelected = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;true&lt;/span&gt;  
    }  

    &lt;span style=&#34;color:#707a7c&#34;&gt;@CallSuper&lt;/span&gt;  
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;open&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;onUnSelect&lt;/span&gt;() {  
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (::selectScope.isInitialized) {  
            selectScope.cancel()  
        }  
        isSelected = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;false&lt;/span&gt;  
    }  
    ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这样使用方就比较方便了&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-kotlin&#34; data-lang=&#34;kotlin&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;ImageBannerViewHolder&lt;/span&gt;(&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;val&lt;/span&gt; binding: ItemImageBannerBinding) : BannerViewHolder(binding.root) {  
    ...
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;override&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;onSelect&lt;/span&gt;() {  
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;super&lt;/span&gt;.onSelect()  
        selectScope.launch {  
            delay(&lt;span style=&#34;color:#b452cd&#34;&gt;3000L&lt;/span&gt;)  
            playDone()  
        }  
    }  
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;- https://ntutn.top/posts/%E6%89%93%E9%80%A0%E4%B8%80%E4%B8%AA%E6%8E%A5%E5%85%A5%E7%AE%80%E5%8D%95%E7%9A%84%E9%80%9A%E7%94%A8banner%E7%BB%84%E4%BB%B6/ - CC BY-SA 4.0</description>
        </item>
    
    
    
        <item>
        <title>Xfermode踩坑小结</title>
        <link>https://ntutn.top/posts/xfermode%E8%B8%A9%E5%9D%91%E5%B0%8F%E7%BB%93/</link>
        <pubDate>Mon, 05 Sep 2022 02:18:57 +0800</pubDate>
        
        <guid>https://ntutn.top/posts/xfermode%E8%B8%A9%E5%9D%91%E5%B0%8F%E7%BB%93/</guid>
        <description>归零幻想 https://ntutn.top/posts/xfermode%E8%B8%A9%E5%9D%91%E5%B0%8F%E7%BB%93/ -&lt;h1 id=&#34;xfermode踩坑小结&#34;&gt;Xfermode踩坑小结&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;Xfermode is the base class for objects that are called to implement custom &amp;ldquo;transfer-modes&amp;rdquo; in the drawing pipeline. The static function Create(Modes) can be called to return an instance of any of the predefined subclasses as specified in the Modes enum. When an Xfermode is assigned to an Paint, then objects drawn with that paint have the xfermode applied.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Xfermode最初有三个子类，除了目前我们常用的 &lt;code&gt;PorterDuffXfermode&lt;/code&gt; 其他两个都已经作古了。&lt;/p&gt;
&lt;p&gt;PorterDuffXfermode可以指定两张图形如何进行混合，借此我们可以实现一些特殊的绘图效果。官方有个很经典的示例图， &lt;em&gt;我经常是需要用时才找出来看一看。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://images.ntutn.top/2022/09/b3ea74b2c64e8b008ba3295f0546df9c.png&#34; alt=&#34;官方APIDemos&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;官方文档错了&#34;&gt;官方文档错了？&lt;/h1&gt;
&lt;p&gt;然而在最近做需求时，我发现自己做出来的效果和官方图上不一致。网上检索，有人说官方的示意图错了，并给出了自己绘制的demo。有模有样有代码，让人信服。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://images.ntutn.top/2022/09/381a44d4722a2f53d05229bf8f1bc099.jpg&#34; alt=&#34;网友的ApiDemos&#34;&gt;&lt;/p&gt;
&lt;p&gt;但官方的文档真的错了吗？如果错了，为什么一直没有改呢？我直觉感觉这种事情概率比较低，所以还是得找到双方的代码才能断案。&lt;/p&gt;
&lt;p&gt;官方的示例在一个叫做API Demos的APP中，代码在一个叫做 &lt;a href=&#34;https://android.googlesource.com/platform/development/+/master/samples/ApiDemos/src/com/example/android/apis/graphics/Xfermodes.java&#34;&gt;Xfermodes.java&lt;/a&gt; 的文件中，它没有很复杂的依赖关系，只要一并把它的父类 &lt;a href=&#34;https://android.googlesource.com/platform/development/+/master/samples/ApiDemos/src/com/example/android/apis/graphics/GraphicsActivity.java&#34;&gt;GraphicsActivity.java&lt;/a&gt; 一并拷贝过来就能工作。建议可以拷贝到自己的demo工程中，方便需要时查阅。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://images.ntutn.top/2022/09/8a823f4937afc11010358e75b5bed9b5.jpg&#34; alt=&#34;ApiDemos我们的运行结果&#34;&gt;&lt;/p&gt;
&lt;p&gt;看上去也没有错误。接下来看看双方的代码，看看问题出在哪里。&lt;/p&gt;
&lt;p&gt;官方代码（等效）&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-kotlin&#34; data-lang=&#34;kotlin&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;makeDst&lt;/span&gt;(width: Int, height: Int): Bitmap {  
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;val&lt;/span&gt; paint = Paint().also {  
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;it&lt;/span&gt;.color = &lt;span style=&#34;color:#b452cd&#34;&gt;0xFFFFCC44&lt;/span&gt;.toInt()  
    }  
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;val&lt;/span&gt; bitmap = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888)  
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;val&lt;/span&gt; canvas = Canvas(bitmap)  
    canvas.drawCircle(width / &lt;span style=&#34;color:#b452cd&#34;&gt;2f&lt;/span&gt;, height / &lt;span style=&#34;color:#b452cd&#34;&gt;2f&lt;/span&gt;, min(width, height) / &lt;span style=&#34;color:#b452cd&#34;&gt;4f&lt;/span&gt;, paint)  
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; bitmap  
}  

&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;makeSrc&lt;/span&gt;(width: Int, height: Int): Bitmap {  
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;val&lt;/span&gt; paint = Paint().also {   
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;it&lt;/span&gt;.color = &lt;span style=&#34;color:#b452cd&#34;&gt;0xFF66AAFF&lt;/span&gt;.toInt()  
    }  
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;val&lt;/span&gt; bitmap = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888)  
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;val&lt;/span&gt; canvas = Canvas(bitmap)  
    canvas.drawRect(width / &lt;span style=&#34;color:#b452cd&#34;&gt;2f&lt;/span&gt;, height / &lt;span style=&#34;color:#b452cd&#34;&gt;2f&lt;/span&gt;, width.toFloat(), height.toFloat(), paint)  
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; bitmap  
}  

&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;override&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;draw&lt;/span&gt;(canvas: Canvas) {  
    mPaint.xfermode = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;null&lt;/span&gt;  
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;val&lt;/span&gt; width = bounds.width()  
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;val&lt;/span&gt; height = bounds.height()  
    makeDst(width, height).also {  
        canvas.drawBitmap(&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;it&lt;/span&gt;, &lt;span style=&#34;color:#b452cd&#34;&gt;0f&lt;/span&gt;, &lt;span style=&#34;color:#b452cd&#34;&gt;0f&lt;/span&gt;, mPaint)  
    }  
    mPaint.xfermode = PorterDuffXfermode(PorterDuff.Mode.DST_OVER)  
    makeSrc(width, height).also {  
        canvas.drawBitmap(&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;it&lt;/span&gt;, &lt;span style=&#34;color:#b452cd&#34;&gt;0f&lt;/span&gt;, &lt;span style=&#34;color:#b452cd&#34;&gt;0f&lt;/span&gt;, mPaint)  
    }  
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;网友代码（等效）&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-kotlin&#34; data-lang=&#34;kotlin&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;makeDst&lt;/span&gt;(width: Int, height: Int): Bitmap {  
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;val&lt;/span&gt; paint = Paint().also {  
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;it&lt;/span&gt;.color = &lt;span style=&#34;color:#b452cd&#34;&gt;0xFFFFCC44&lt;/span&gt;.toInt()  
    }  
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;val&lt;/span&gt; bitmap = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888)  
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;val&lt;/span&gt; canvas = Canvas(bitmap)  
    canvas.drawCircle(width / &lt;span style=&#34;color:#b452cd&#34;&gt;2f&lt;/span&gt;, height / &lt;span style=&#34;color:#b452cd&#34;&gt;2f&lt;/span&gt;, min(width, height) / &lt;span style=&#34;color:#b452cd&#34;&gt;2f&lt;/span&gt;, paint)  
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; bitmap  
}  

&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;makeSrc&lt;/span&gt;(width: Int, height: Int): Bitmap {  
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;val&lt;/span&gt; paint = Paint().also {  
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;it&lt;/span&gt;.color = &lt;span style=&#34;color:#b452cd&#34;&gt;0xFF66AAFF&lt;/span&gt;.toInt()  
    }  
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;val&lt;/span&gt; bitmap = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888)  
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;val&lt;/span&gt; canvas = Canvas(bitmap)  
    canvas.drawRect(&lt;span style=&#34;color:#b452cd&#34;&gt;0f&lt;/span&gt;, &lt;span style=&#34;color:#b452cd&#34;&gt;0f&lt;/span&gt;, width.toFloat(), height.toFloat(), paint)  
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; bitmap  
}  

&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;override&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;draw&lt;/span&gt;(canvas: Canvas) {  
    mPaint.xfermode = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;null&lt;/span&gt;  
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;val&lt;/span&gt; width = bounds.width()  
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;val&lt;/span&gt; height = bounds.height()  
    makeDst(width / &lt;span style=&#34;color:#b452cd&#34;&gt;2&lt;/span&gt;, height / &lt;span style=&#34;color:#b452cd&#34;&gt;2&lt;/span&gt;).also {  
        canvas.drawBitmap(&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;it&lt;/span&gt;, width / &lt;span style=&#34;color:#b452cd&#34;&gt;4f&lt;/span&gt;, height / &lt;span style=&#34;color:#b452cd&#34;&gt;4f&lt;/span&gt;, mPaint)  
    }  
    mPaint.xfermode = PorterDuffXfermode(PorterDuff.Mode.DST_OVER)  
    makeSrc(width / &lt;span style=&#34;color:#b452cd&#34;&gt;2&lt;/span&gt;, height / &lt;span style=&#34;color:#b452cd&#34;&gt;2&lt;/span&gt;).also {  
        canvas.drawBitmap(&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;it&lt;/span&gt;, width / &lt;span style=&#34;color:#b452cd&#34;&gt;2f&lt;/span&gt;, height / &lt;span style=&#34;color:#b452cd&#34;&gt;2f&lt;/span&gt;, mPaint)  
    }  
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;仔细观察上述代码，你会发现 &lt;strong&gt;网友用法中两次绘制实际上并不完全重叠&lt;/strong&gt;。官方生成的两个Bitmap，是同样大小的并在同一个位置绘制，而后者是只生成了部分需要绘制的位置图形，在特定位置绘制。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://images.ntutn.top/2022/09/03ee100cf274352bb89bd5326a2971ec.png&#34; alt=&#34;单个图片绘制示意&#34;&gt;&lt;/p&gt;
&lt;p&gt;例如，对于一个400X400的目标区域，官方方法是创建了两个400X400的Bitmap，直接在(0, 0) 位置绘制。 另一种方法是创建了两个200X200的Bitmap，一个在(100, 100)处绘制，另一个在(200, 200)处绘制。&lt;/p&gt;
&lt;p&gt;后者绘制区域并不重叠，因而可以看到圆形变化的始终只有圆形的右下角四分之一圆。&lt;/p&gt;
&lt;h1 id=&#34;xfermode的几个应用&#34;&gt;Xfermode的几个应用&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;抖音Loading双色加载球&lt;/li&gt;
&lt;li&gt;圆形头像甚至异形头像裁剪&lt;/li&gt;
&lt;li&gt;抖音弹幕描边裁剪&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;弹幕需求xfermode的应用&#34;&gt;弹幕需求Xfermode的应用&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;https://images.ntutn.top/2022/09/e6c0cb56a69c8c9d8ba72ec75d47a1b7.png&#34; alt=&#34;B站的带描边弹幕&#34;&gt;&lt;/p&gt;
&lt;p&gt;弹幕有个优化需求，是给弹幕文字加上描边。描边一般是将paint的style设置为Stroke再进行一次绘制实现的。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-kotlin&#34; data-lang=&#34;kotlin&#34;&gt;&lt;span style=&#34;color:#228b22&#34;&gt;// 绘制描边
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;with(layout.paint) {
    color = Color.BLACK  
    style = Paint.Style.STROKE  
    strokeWidth = &lt;span style=&#34;color:#b452cd&#34;&gt;5f&lt;/span&gt;.dpFloat
}
layout.draw(canvas)

&lt;span style=&#34;color:#228b22&#34;&gt;// 绘制填充
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;with(layout.paint) {
    style = Paint.Style.FILL  
    color = drawColor
}
layout.draw(canvas)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;然而我这样实现后，效果并不好，因为 &lt;strong&gt;弹幕文本和描边都是有透明度的，而描边笔画重叠的位置也会进行绘制&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://images.ntutn.top/2022/09/bcd2513ffa6e3242c590981ac8f0af06.png&#34; alt=&#34;描边与透明度的冲突&#34;&gt;&lt;/p&gt;
&lt;p&gt;所以，我需要先将描边与填充重叠的地方裁掉，然后再绘制填充&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-kotlin&#34; data-lang=&#34;kotlin&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;override&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;draw&lt;/span&gt;(canvas: Canvas) {  
    &lt;span style=&#34;color:#228b22&#34;&gt;// 外层saveLayer也需要保留，否则裁剪时会有非预期表现  
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    canvas.saveLayer(&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;null&lt;/span&gt;, &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;null&lt;/span&gt;)  

    &lt;span style=&#34;color:#228b22&#34;&gt;// 绘制描边
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    drawStroke(canvas)  

    clipPaint.xfermode = PorterDuffXfermode(PorterDuff.Mode.DST_OUT)  
    canvas.saveLayer(&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;null&lt;/span&gt;, clipPaint)  
    &lt;span style=&#34;color:#228b22&#34;&gt;// 绘制文本剪影，DST_OUT方式图像混合。因为混合时会受到透明度影响，所以指定为黑色。
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    drawSolid(canvas, Color.BLACK)  
    canvas.restore()  

    &lt;span style=&#34;color:#228b22&#34;&gt;// 绘制文本
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    drawSolid(canvas)  

    canvas.restore()  
}  

&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;drawStroke&lt;/span&gt;(canvas: Canvas) {  
    with(layout.paint) {  
        color = Color.BLACK  
        style = Paint.Style.STROKE  
        strokeWidth = &lt;span style=&#34;color:#b452cd&#34;&gt;5f&lt;/span&gt;.dpFloat  
    }  
    layout.draw(canvas)  
}  

&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;drawSolid&lt;/span&gt;(canvas: Canvas, drawColor: Int ? = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;null&lt;/span&gt;) {  
    with(layout.paint) {  
        style = Paint.Style.FILL  
        color = drawColor ?: &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;#99FF0000&amp;#34;&lt;/span&gt;.color  
    }  
    layout.draw(canvas)   
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;img src=&#34;https://images.ntutn.top/2022/09/141e77ad4e1480f333d54c012b7ed0ed.png&#34; alt=&#34;弹幕xfermode绘制效果&#34;&gt;&lt;/p&gt;
&lt;p&gt;不过这个方案实现出来 &lt;strong&gt;性能表现太差&lt;/strong&gt; 被砍掉了 Orz&lt;/p&gt;
&lt;p&gt;总之就是，慎用saveLayer，优先考虑其他实现，尤其是在这种比较注重性能的场合。&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;其他&#34;&gt;其他&lt;/h1&gt;
&lt;h2 id=&#34;xfermode兼容性&#34;&gt;Xfermode兼容性&lt;/h2&gt;
&lt;p&gt;这个是需求测试中发现的。QA一台安卓手机上绘制效果不符合预期，然后借来跑了下demo，发现得到的结果和我自己测试机上还不一样。这里我找了个安卓8的手机，可以看到结果和我们之前得到的并不尽相同。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://images.ntutn.top/2022/09/0f4cc08dd4e2be9ca129462c842b7512.png&#34; alt=&#34;xfermode兼容问题&#34;&gt;&lt;/p&gt;
&lt;p&gt;显然，图上 CLEAR、DARKEN、LIGHTEN 是和前面运行结果不一样的。&lt;/p&gt;
&lt;p&gt;我建议， &lt;strong&gt;以上提到3个表现不一致的（CLEAR、DARKEN、LIGHTEN）和ADD、OVERLAY这两个没有在文档提到的不要在工程中用。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;此外， &lt;strong&gt;尽量只在canvas.saveLayer上和canvas.drawBitmap上设置xfermode&lt;/strong&gt; 在普通的图形绘制上不要给画笔设置xfermode，不是官方示例中的用法，可能出问题（本人踩坑，在vivo的某个机型出现了奇怪的绘制结果）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;canvas如果来源于View的onDraw方法，要使用xfermode要在最外层套上saveLayer&lt;/strong&gt; ，因为View拿出来的Canvas并不是透明背景，当你直接用xfermode裁剪掉部分区域时会遇到奇怪的问题（被裁掉的区域出现大块黑色块）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;愿在天堂的需求不需要用到xfermode。&lt;/strong&gt;&lt;/p&gt;
- https://ntutn.top/posts/xfermode%E8%B8%A9%E5%9D%91%E5%B0%8F%E7%BB%93/ - CC BY-SA 4.0</description>
        </item>
    
    
    
        <item>
        <title>从头开始制作一个tg机器人</title>
        <link>https://ntutn.top/posts/%E4%BB%8E%E5%A4%B4%E5%BC%80%E5%A7%8B%E5%88%B6%E4%BD%9C%E4%B8%80%E4%B8%AAtg%E6%9C%BA%E5%99%A8%E4%BA%BA/</link>
        <pubDate>Tue, 30 Aug 2022 02:49:11 +0800</pubDate>
        
        <guid>https://ntutn.top/posts/%E4%BB%8E%E5%A4%B4%E5%BC%80%E5%A7%8B%E5%88%B6%E4%BD%9C%E4%B8%80%E4%B8%AAtg%E6%9C%BA%E5%99%A8%E4%BA%BA/</guid>
        <description>归零幻想 https://ntutn.top/posts/%E4%BB%8E%E5%A4%B4%E5%BC%80%E5%A7%8B%E5%88%B6%E4%BD%9C%E4%B8%80%E4%B8%AAtg%E6%9C%BA%E5%99%A8%E4%BA%BA/ -&lt;p&gt;工作之外，总想折腾点什么东西。最近看朋友搞的QQ摸鱼机器人有点意思，就想自己也搞一个。tg提供的API比较全面，所以就想搞个tg版。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://images.ntutn.top/2022/08/4fcad14a68f078ea886d454f9173e0d0.png&#34; alt=&#34;image-20220830032946945&#34;&gt;&lt;/p&gt;
&lt;p&gt;直接贴代码：&lt;a href=&#34;https://github.com/rfkhx/starsea&#34;&gt;https://github.com/rfkhx/starsea&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;基本消息处理和分发&#34;&gt;基本消息处理和分发&lt;/h1&gt;
&lt;p&gt;其实仅就这个需求而言，并没有用多线程的必要性，一个死循环中拉取消息，拉到后交给对应模块处理，处理完继续下一次循环拉下一条消息就可以了。不过为了把代码结构写得更清楚一点，并希望能在这个过程中学到点东西，我决定仿照安卓的线程机制组织，将安卓中的 &lt;code&gt;Handler&lt;/code&gt;、&lt;code&gt;Looper&lt;/code&gt; 移植到我的项目中，借助这个过程更深入理解整个机制。&lt;/p&gt;
&lt;p&gt;类似安卓，我在后台线程进行网络请求，主线程进行结果的分发处理。&lt;/p&gt;
&lt;h2 id=&#34;message&#34;&gt;Message&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Message&lt;/code&gt; 就是消息对象。我对消息对象的定义如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-kotlin&#34; data-lang=&#34;kotlin&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;data&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;Message&lt;/span&gt;(  
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;val&lt;/span&gt; what: Int,  
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;val&lt;/span&gt; arg: Int = -&lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;,  
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;val&lt;/span&gt; payload: Any? = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;null&lt;/span&gt;,  
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;var&lt;/span&gt; time: Long = &lt;span style=&#34;color:#b452cd&#34;&gt;0L&lt;/span&gt;,  
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;var&lt;/span&gt; target: Handler? = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;null&lt;/span&gt;,  
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;val&lt;/span&gt; callback: Runnable? = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;null&lt;/span&gt;  
)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;要理解整个消息机制，还是得先看这几个参数。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;what 表示这是一条什么样的消息。一个 &lt;code&gt;Handler&lt;/code&gt; 中可能定义和处理多种不同的消息，通过这个参数进行区分。&lt;/li&gt;
&lt;li&gt;arg、payload 表示消息携带的参数。 &lt;code&gt;arg&lt;/code&gt; 是简单的， &lt;code&gt;Int&lt;/code&gt; 类型的参数，而 &lt;code&gt;payload&lt;/code&gt; 则用于传递复杂对象。按需使用&lt;/li&gt;
&lt;li&gt;time 表示 &lt;code&gt;Message&lt;/code&gt; 预期被处理的时间。只有到了这个时间之后消息才可以被取出处理。这对应我们经常用的 &lt;code&gt;handler.postDelayed&lt;/code&gt; 方法&lt;/li&gt;
&lt;li&gt;target 处理消息的 &lt;code&gt;Handler&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;callback 消息处理时执行特定回调。实际上和继承相关 &lt;code&gt;Handler&lt;/code&gt; 并在相关方法中处理消息是等同的&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;messagequeue&#34;&gt;MessageQueue&lt;/h2&gt;
&lt;p&gt;记得安卓中有个比较经典和基础的问题，主线程实际执行了 &lt;code&gt;Looper.loop()&lt;/code&gt; ，为什么不会卡死？&lt;/p&gt;
&lt;p&gt;首先我们看 &lt;code&gt;Looper&lt;/code&gt; 的实现。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://images.ntutn.top/2022/08/9af555bdbc0e5ef42784eed8e8219aac.png&#34; alt=&#34;Pasted image 20220825043217&#34;&gt;&lt;/p&gt;
&lt;p&gt;确认这里确实是个死循环，继续看单次循环 &lt;code&gt;loopOnce&lt;/code&gt; 方法做了什么。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://images.ntutn.top/2022/08/bd6595d2f86b8d42798042706166a27b.png&#34; alt=&#34;Pasted image 20220825043457&#34;&gt;&lt;/p&gt;
&lt;p&gt;首先从 &lt;code&gt;MessageQueue&lt;/code&gt; 中取到一条消息，一些判断后实际走了 &lt;code&gt;Message&lt;/code&gt; 对应 &lt;code&gt;Handler&lt;/code&gt; 来处理消息。似乎看不到哪里处理了这个问题，但我们可以在取消息处看到一条注释“might block”。&lt;/p&gt;
&lt;p&gt;是的，这个队列有个特性，就是没有可用消息时，线程会阻塞在这里，就像我们用 &lt;code&gt;Scanner&lt;/code&gt; 读用户输入一样，只有有了输入程序才会继续运行，所以不会占满CPU资源。而用户感受到的卡顿发生实际上是主线程堆积的消息过多，无法及时处理导致的，与这里用一个死循环处理消息没有直接关系。这里更多拓展探讨可以参考 &lt;a href=&#34;https://www.wanandroid.com/wenda/show/8685&#34;&gt;每日一问 Looper.loop为什么不会阻塞掉UI线程？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;幸运的是，java已经有具有这样功能的队列实现了，它就是 &lt;code&gt;java.util.concurrent.DelayQueue&lt;/code&gt; 。只要让我们的 &lt;code&gt;Message&lt;/code&gt; 类实现 &lt;code&gt;Delayed&lt;/code&gt; 接口&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-kotlin&#34; data-lang=&#34;kotlin&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;data&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;Message&lt;/span&gt;(  
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;val&lt;/span&gt; what: Int,  
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;val&lt;/span&gt; arg: Int = -&lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;,  
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;val&lt;/span&gt; payload: Any? = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;null&lt;/span&gt;,  
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;var&lt;/span&gt; time: Long = &lt;span style=&#34;color:#b452cd&#34;&gt;0L&lt;/span&gt;,  
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;var&lt;/span&gt; target: Handler? = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;null&lt;/span&gt;,  
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;val&lt;/span&gt; callback: Runnable? = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;null&lt;/span&gt;  
): Delayed {  
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;override&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;compareTo&lt;/span&gt;(other: Delayed?): Int {  
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;val&lt;/span&gt; value1 = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.getDelay(TimeUnit.MILLISECONDS)  
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;val&lt;/span&gt; value2 = (other?.getDelay(TimeUnit.MILLISECONDS)?: &lt;span style=&#34;color:#b452cd&#34;&gt;0L&lt;/span&gt;)  
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; (value1 - value2).getSymbolInt()  
    }  
  
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;override&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;getDelay&lt;/span&gt;(unit: TimeUnit): Long {  
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;val&lt;/span&gt; diffTime = time - System.currentTimeMillis()  
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; unit.convert(diffTime, TimeUnit.MILLISECONDS)  
    }  
  
    &lt;span style=&#34;color:#228b22&#34;&gt;/*  
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;     * 安全地提取符号，将long转换成 -1 0 1     */&lt;/span&gt;    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;Long&lt;/span&gt;.getSymbolInt(): Int {  
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;val&lt;/span&gt; value = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;  
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (value == &lt;span style=&#34;color:#b452cd&#34;&gt;0L&lt;/span&gt;) {  
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;  
        }  
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; (value / abs(value)).toInt()  
    }  
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;然后我们就可以直接用这个 &lt;code&gt;DelayQueue&lt;/code&gt; 作为我们的 &lt;code&gt;MessageQueue&lt;/code&gt; 了。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-kotlin&#34; data-lang=&#34;kotlin&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;MessageQueue&lt;/span&gt; {  
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;val&lt;/span&gt; mQueue = DelayQueue&amp;lt;Message&amp;gt;()  
  
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;enqueue&lt;/span&gt;(msg: Message) {  
        msg.time = &lt;span style=&#34;color:#b452cd&#34;&gt;0L&lt;/span&gt;  
        mQueue.put(msg)  
    }  
  
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;enqueue&lt;/span&gt;(msg: Message, time: Long) {  
        msg.time = time  
        mQueue.put(msg)  
    }  
  
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;poll&lt;/span&gt;(): Message {  
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; mQueue.take()  
    }  
  
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;clearMessages&lt;/span&gt;(handler: Handler) {  
        mQueue.removeIf { &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;it&lt;/span&gt;.target == handler }  
    }  
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;looper&#34;&gt;Looper&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Looper&lt;/code&gt; 的核心代码抽离出来比较简单，我就直接贴出来了。 &lt;code&gt;Looper&lt;/code&gt; 中持有 &lt;code&gt;MessageQueue&lt;/code&gt; ，是整个消息循环的核心。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-kotlin&#34; data-lang=&#34;kotlin&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;Looper&lt;/span&gt; {  
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;val&lt;/span&gt; mQueue = MessageQueue()  
  
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;companion&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;object&lt;/span&gt; {  
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;val&lt;/span&gt; sThreadLocal = ThreadLocal&amp;lt;Looper&amp;gt;()  
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;var&lt;/span&gt; sMainLooper: Looper? = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;null&lt;/span&gt;  
  
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;myLooper&lt;/span&gt;() = sThreadLocal.&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;get&lt;/span&gt;()  
  
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;mainLooper&lt;/span&gt;() = sMainLooper!!  
  
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;prepare&lt;/span&gt;() {  
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (sThreadLocal.&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;get&lt;/span&gt;() != &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;null&lt;/span&gt;) {  
                &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;throw&lt;/span&gt; IllegalStateException(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;looper prepared&amp;#34;&lt;/span&gt;)  
            }  
            sThreadLocal.&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;set&lt;/span&gt;(Looper())  
        }  
  
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;prepareMainLooper&lt;/span&gt;() {  
            prepare()  
            synchronized(Looper::&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt;) {  
                &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (sMainLooper != &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;null&lt;/span&gt;) {  
                    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;throw&lt;/span&gt; IllegalStateException(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;main looper prepared&amp;#34;&lt;/span&gt;)  
                }  
                sMainLooper = myLooper()  
            }  
        }  
  
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;loop&lt;/span&gt;() {  
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;val&lt;/span&gt; me = myLooper() ?: &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;throw&lt;/span&gt; IllegalStateException(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;you should call prepare first&amp;#34;&lt;/span&gt;)  
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;while&lt;/span&gt; (&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;true&lt;/span&gt;) {  
                &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;val&lt;/span&gt; message = me.mQueue.poll()  
                message.target?.dispatchMessage(message)  
            }  
        }  
    }  
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这里唯一一个知识点就是 &lt;code&gt;ThreadLocal&lt;/code&gt; 的使用。这里借用 &lt;a href=&#34;https://www.liaoxuefeng.com/wiki/1252599548343744/1306581251653666&#34;&gt;廖雪峰的教程&lt;/a&gt; 中的一句话：“实际上，可以把&lt;code&gt;ThreadLocal&lt;/code&gt;看成一个全局&lt;code&gt;Map&amp;lt;Thread, Object&amp;gt;&lt;/code&gt;：每个线程获取&lt;code&gt;ThreadLocal&lt;/code&gt;变量时，总是使用&lt;code&gt;Thread&lt;/code&gt;自身作为key”。&lt;/p&gt;
&lt;p&gt;每个线程 &lt;code&gt;prepare&lt;/code&gt; 后都绑定了一个 &lt;code&gt;Looper&lt;/code&gt; ，这个 &lt;code&gt;Looper&lt;/code&gt; 就是放在 &lt;code&gt;ThreadLocal&lt;/code&gt; 中的，此后我们在某一线程执行 &lt;code&gt;sThreadLocal.get()&lt;/code&gt; 拿到的就是这个线程的 &lt;code&gt;Looper&lt;/code&gt; 。&lt;/p&gt;
&lt;h2 id=&#34;handler&#34;&gt;Handler&lt;/h2&gt;
&lt;p&gt;终于到了激动人心的时刻了，我们理到了最常使用和打交道的 &lt;code&gt;Handler&lt;/code&gt; 。核心逻辑实际上要比我想象的简单。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-kotlin&#34; data-lang=&#34;kotlin&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;open&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;Handler&lt;/span&gt;(looper: Looper? = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;null&lt;/span&gt;) {  
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;companion&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;object&lt;/span&gt; {  
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;val&lt;/span&gt; EMPTY_MESSAGE = Message(-&lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;)  
    }  
  
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;var&lt;/span&gt; mLooper: Looper  
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;var&lt;/span&gt; mQueue: MessageQueue  
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;var&lt;/span&gt; mCallback: ((Message) -&amp;gt; Unit)? = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;null&lt;/span&gt;  
  
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;init&lt;/span&gt; {  
        mLooper = looper ?: Looper.myLooper() ?: &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;throw&lt;/span&gt; IllegalStateException(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;looper not prepared&amp;#34;&lt;/span&gt;)  
        mQueue = mLooper.mQueue  
    }  
  
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;sendMessage&lt;/span&gt;(msg: Message) = sendMessageDelay(msg, &lt;span style=&#34;color:#b452cd&#34;&gt;0L&lt;/span&gt;)  
  
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;sendMessageDelay&lt;/span&gt;(msg: Message, delay: Long) {  
        require(delay &amp;gt;= &lt;span style=&#34;color:#b452cd&#34;&gt;0L&lt;/span&gt;) { &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;delay cannot be negative&amp;#34;&lt;/span&gt; }  
        msg.target = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;  
        mQueue.enqueue(msg, System.currentTimeMillis() + delay)  
    }  
  
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;sendEmptyMessage&lt;/span&gt;() = sendMessage(EMPTY_MESSAGE)  
  
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;sendEmptyMessageDelayed&lt;/span&gt;(delay: Long) = sendMessageDelay(EMPTY_MESSAGE, delay)  
  
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;post&lt;/span&gt;(block: () -&amp;gt; Unit) {  
        sendMessage(Message(&lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;, callback = block))  
    }  
  
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;postDelayed&lt;/span&gt;(block: () -&amp;gt; Unit, delay: Long) {  
        sendMessageDelay(Message(&lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;, callback = block), delay)  
    }  
  
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;dispatchMessage&lt;/span&gt;(message: Message) {  
        message.callback?.run() ?: mCallback?.invoke(message) ?: handleMessage(message)  
    }  
  
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;clearMessages&lt;/span&gt;() {  
        mQueue.clearMessages(&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;)  
    }  
  
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;protected&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;open&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;handleMessage&lt;/span&gt;(message: Message) {}  
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;一个 &lt;code&gt;Handler&lt;/code&gt; 对应一个 &lt;code&gt;Looper&lt;/code&gt; ，&lt;code&gt;sendMessage&lt;/code&gt; 实际上就是把对应的 &lt;code&gt;Message&lt;/code&gt; 插入到了对应的 &lt;code&gt;MessageQueue&lt;/code&gt; 中。而后阻塞在 &lt;code&gt;Looper.loop&lt;/code&gt; 取下一条消息位置的线程被唤醒，并根据 &lt;code&gt;Message.target&lt;/code&gt; 找到了发送消息的 &lt;code&gt;Handler.dispatchMessage&lt;/code&gt; 来执行，而后实际执行对应callback或handleMessage方法。&lt;/p&gt;
&lt;h2 id=&#34;kotlin协程兼容&#34;&gt;Kotlin协程兼容&lt;/h2&gt;
&lt;p&gt;根据我们前面的设计，我们有主线程和后台线程之分。Kotlin协程的实现上， &lt;code&gt;Dispatchers.IO&lt;/code&gt; 实际上是个未设置上限的线程池，但 &lt;code&gt;Dispatchers.Main&lt;/code&gt; 可是需要切换回主线程来执行对应代码的。我们怎么做这里的兼容，使之能切换回我们定义的“主线程”呢？&lt;/p&gt;
&lt;p&gt;继续看代码，通过SPI加载了MainDispatcherFactory。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://images.ntutn.top/2022/08/9f27357e82b119c6fa75ef49d5696302.png&#34; alt=&#34;Pasted image 20220825052152&#34;&gt;&lt;/p&gt;
&lt;p&gt;继续找，很快找到了安卓对应的实现&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://images.ntutn.top/2022/08/516a7a7b328ae08f0b23911258fcbd73.png&#34; alt=&#34;Pasted image 20220825052357&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://images.ntutn.top/2022/08/0c622b2059b0ec440cfc3fcf882a6d91.png&#34; alt=&#34;Pasted image 20220825052541&#34;&gt;&lt;/p&gt;
&lt;p&gt;其实就是将对应的代码post到了主线程去处理。所以仿照它，我的“青春版”实现也有了&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-kotlin&#34; data-lang=&#34;kotlin&#34;&gt;&lt;span style=&#34;color:#707a7c&#34;&gt;@OptIn&lt;/span&gt;(InternalCoroutinesApi::&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt;)  
&lt;span style=&#34;color:#707a7c&#34;&gt;@AutoService&lt;/span&gt;(MainDispatcherFactory::&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt;)  
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;MainDispatcherFactoryImpl&lt;/span&gt;: MainDispatcherFactory {  
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;override&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;val&lt;/span&gt; loadPriority: Int  
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;get&lt;/span&gt;() = &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;  
  
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;override&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;createDispatcher&lt;/span&gt;(allFactories: List&amp;lt;MainDispatcherFactory&amp;gt;): MainCoroutineDispatcher {  
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; MainDispatcher()  
    }  
}  
  
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;MainDispatcher&lt;/span&gt;: MainCoroutineDispatcher() {  
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;val&lt;/span&gt; handler = Handler(Looper.mainLooper())  
  
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;override&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;val&lt;/span&gt; immediate: MainCoroutineDispatcher  
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;get&lt;/span&gt;() = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;  
  
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;override&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;dispatch&lt;/span&gt;(context: CoroutineContext, block: Runnable) {  
        handler.sendMessage(Message(&lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;, callback = block))  
    }  
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h1 id=&#34;消息的拉取&#34;&gt;消息的拉取&lt;/h1&gt;
&lt;h2 id=&#34;长轮询的实现&#34;&gt;长轮询的实现&lt;/h2&gt;
&lt;p&gt;tg的消息都是由一个叫做 &lt;code&gt;getUpdate&lt;/code&gt; 的接口拉取的，而通过这个接口获取消息要做&lt;a href=&#34;https://zh.javascript.info/long-polling&#34;&gt;长轮询&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;长轮询是什么？与普通的轮询方式不同，长轮询在发出请求后如果没有消息返回，服务端将不会立即返回，而是等有消息或超时再返回，而后客户端发起下一个请求。这一是能在有消息到达时让客户端及时收到通知，二是在没有消息时不会浪费太多无用请求。&lt;/p&gt;
&lt;p&gt;我的网络请求部分是 &lt;code&gt;Retrofit&lt;/code&gt; ，我发现单独给某个请求设置不同的超时时间还挺麻烦的。我参考 &lt;a href=&#34;https://github.com/square/retrofit/issues/2982&#34;&gt;这里的讨论&lt;/a&gt; 总结如下：&lt;/p&gt;
&lt;p&gt;首先将 &lt;code&gt;OkHttp&lt;/code&gt; 的超时时间设置为一个很大的值，保证不会影响到我们后面的设置。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-kotlin&#34; data-lang=&#34;kotlin&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;val&lt;/span&gt; okHttpClient: OkHttpClient &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;by&lt;/span&gt; lazy {  
    OkHttpClient.Builder()  
        .connectTimeout(&lt;span style=&#34;color:#b452cd&#34;&gt;1L&lt;/span&gt;, TimeUnit.DAYS) &lt;span style=&#34;color:#228b22&#34;&gt;// 超时相关逻辑由 [top.ntutn.starsea.network.TimeoutCallAdapterFactory] 控制  
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        .readTimeout(&lt;span style=&#34;color:#b452cd&#34;&gt;1L&lt;/span&gt;, TimeUnit.DAYS)  
        .writeTimeout(&lt;span style=&#34;color:#b452cd&#34;&gt;1L&lt;/span&gt;, TimeUnit.DAYS)  
        .build()  
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;声明一个注解，用于指定单个连接的超时时间。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-kotlin&#34; data-lang=&#34;kotlin&#34;&gt;&lt;span style=&#34;color:#707a7c&#34;&gt;@Retention&lt;/span&gt;(AnnotationRetention.RUNTIME)  
&lt;span style=&#34;color:#707a7c&#34;&gt;@Target&lt;/span&gt;(AnnotationTarget.FUNCTION, AnnotationTarget.PROPERTY_GETTER, AnnotationTarget.PROPERTY_SETTER)  
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;annotation&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;Timeout&lt;/span&gt;(&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;val&lt;/span&gt; value: Long, &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;val&lt;/span&gt; unit: TimeUnit)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;创建 &lt;code&gt;Retrofit&lt;/code&gt; 对象时，添加一个 &lt;code&gt;CallAdapterFactory&lt;/code&gt; ，读取注解设置超时时间。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-kotlin&#34; data-lang=&#34;kotlin&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;val&lt;/span&gt; retrofit: Retrofit &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;by&lt;/span&gt; lazy {  
    Retrofit.Builder()  
        .baseUrl(BASE_URL)  
        .addConverterFactory(KotlinSerializeUtil.json.asConverterFactory(MediaType.parse(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;application/json&amp;#34;&lt;/span&gt;)!!))  
        .addCallAdapterFactory(TimeoutCallAdapterFactory())  
        .client(okHttpClient)  
        .build()  
}

&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;TimeoutCallAdapterFactory&lt;/span&gt; : CallAdapter.Factory(), LoggerOwner &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;by&lt;/span&gt; slf4jLoggerOwner&amp;lt;TimeoutCallAdapterFactory&amp;gt;() {  
  
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;override&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;get&lt;/span&gt;(returnType: Type, annotations: Array&amp;lt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;out&lt;/span&gt; Annotation&amp;gt;, retrofit: Retrofit): CallAdapter&amp;lt;*, *&amp;gt;? {  
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;val&lt;/span&gt; timeout = annotations.firstOrNull { &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;it&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;is&lt;/span&gt; Timeout } &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;as&lt;/span&gt;? Timeout  
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;val&lt;/span&gt; delegate = retrofit.nextCallAdapter(&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;, returnType, annotations)  
  
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (getRawType(returnType) != Call::&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt;.java) {  
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;null&lt;/span&gt;  
        }  
  
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;object&lt;/span&gt; &lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;: &lt;/span&gt;&lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;CallAdapter&lt;/span&gt;&amp;lt;Any, Call&amp;lt;Any&amp;gt;&amp;gt; {  
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;override&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;responseType&lt;/span&gt;(): Type {  
                &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;delegate&lt;/span&gt;.responseType()  
            }  
  
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;override&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;adapt&lt;/span&gt;(call: Call&amp;lt;Any&amp;gt;): Call&amp;lt;Any&amp;gt; {  
                &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;val&lt;/span&gt; path = call.request().url().url().path  
                &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (timeout != &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;null&lt;/span&gt;) {  
                    logger.debug(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;请求{}的超时时间被设置为{} {}&amp;#34;&lt;/span&gt;, path, timeout.value, timeout.unit)  
                    call.timeout().timeout(timeout.value, timeout.unit)  
                } &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;else&lt;/span&gt; {  
                    logger.debug(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;请求{}的超时时间被设置为默认值{} s&amp;#34;&lt;/span&gt;, path, RetrofitManager.DEFAULT_TIMEOUT.toLong())  
                    call.timeout().timeout(RetrofitManager.DEFAULT_TIMEOUT.toLong(), TimeUnit.SECONDS)  
                }  
                &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; call  
            }  
        }  
    }  
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;然后就可以借助注解便捷地指定某单个请求的超时时间了。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-kotlin&#34; data-lang=&#34;kotlin&#34;&gt;&lt;span style=&#34;color:#228b22&#34;&gt;/**  
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt; * [Telegram Bot API](https://core.telegram.org/bots/api) */&lt;/span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;interface&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;BotApi&lt;/span&gt; {  
  
    &lt;span style=&#34;color:#707a7c&#34;&gt;@GET&lt;/span&gt;(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;/bot{token}/getMe&amp;#34;&lt;/span&gt;)  
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;suspend&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;getMe&lt;/span&gt;(&lt;span style=&#34;color:#707a7c&#34;&gt;@Path&lt;/span&gt;(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;token&amp;#34;&lt;/span&gt;) token: BotToken): ResultWrapperBean&amp;lt;UserBean&amp;gt;  
  
    &lt;span style=&#34;color:#228b22&#34;&gt;/**  
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;     * 获取更新消息，长连接  
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;     */&lt;/span&gt;  
    &lt;span style=&#34;color:#707a7c&#34;&gt;@Headers&lt;/span&gt;(  
        &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;${RetrofitManager.READ_TIMEOUT}&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;: 6000&amp;#34;&lt;/span&gt;,  
        &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;${RetrofitManager.WRITE_TIMEOUT}&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;: 6000&amp;#34;&lt;/span&gt;,  
        &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;${RetrofitManager.CONNECT_TIMEOUT}&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;: 6000&amp;#34;&lt;/span&gt;  
    )  
    &lt;span style=&#34;color:#707a7c&#34;&gt;@Timeout&lt;/span&gt;(value = &lt;span style=&#34;color:#b452cd&#34;&gt;60L&lt;/span&gt;, unit = TimeUnit.SECONDS)  
    &lt;span style=&#34;color:#707a7c&#34;&gt;@GET&lt;/span&gt;(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;/bot{token}/getUpdates?timeout=30&amp;amp;allowed_updates=message,edited_message&amp;#34;&lt;/span&gt;) &lt;span style=&#34;color:#228b22&#34;&gt;// timeout单位秒  
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;suspend&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;getUpdates&lt;/span&gt;(&lt;span style=&#34;color:#707a7c&#34;&gt;@Path&lt;/span&gt;(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;token&amp;#34;&lt;/span&gt;) token: BotToken, &lt;span style=&#34;color:#707a7c&#34;&gt;@Query&lt;/span&gt;(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;offset&amp;#34;&lt;/span&gt;) offset: Long? = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;null&lt;/span&gt;): ResultWrapperBean&amp;lt;List&amp;lt;UpdateBean&amp;gt;&amp;gt;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;消息循环实现&#34;&gt;消息循环实现&lt;/h2&gt;
&lt;p&gt;前面我们已经实现了安卓 &lt;code&gt;Handler&lt;/code&gt; 机制的简单移植和协程的支持，这里就写个 &lt;code&gt;Handler&lt;/code&gt; 来实现吧。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://images.ntutn.top/2022/08/d6cebada8649392ee9578f282fea2b1e.png&#34; alt=&#34;Pasted image 20220827025958&#34;&gt;&lt;/p&gt;
&lt;p&gt;当开始获取消息时发送了一条 &lt;code&gt;Message&lt;/code&gt; ，而后就开始执行单条消息的获取和处理了。注意不要捕获 &lt;code&gt;CancellationException&lt;/code&gt; 时重试，否则job取消时就死循环了。&lt;/p&gt;
&lt;h1 id=&#34;消息发送&#34;&gt;消息发送&lt;/h1&gt;
&lt;p&gt;简单消息的发送就不说了，唯一麻烦点的是用tg发送文件。接口定义：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-kotlin&#34; data-lang=&#34;kotlin&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;interface&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;BotApi&lt;/span&gt; {
&lt;span style=&#34;color:#228b22&#34;&gt;/**  
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt; * Use this method to send photos. On success, the sent Message is returned. * @param chatId Unique identifier for the target chat or username of the target channel (in the format @channelusername)  
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt; * @param photo Photo to send. Pass a file_id as String to send a photo that exists on the Telegram servers (recommended), pass an HTTP URL as a String for Telegram to get a photo from the Internet. The photo must be at most 10 MB in size. The photo&amp;#39;s width and height must not exceed 10000 in total. Width and height ratio must be at most 20. More information on Sending Files »  
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt; */&lt;/span&gt;&lt;span style=&#34;color:#707a7c&#34;&gt;@POST&lt;/span&gt;(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;/bot{token}/sendPhoto&amp;#34;&lt;/span&gt;)  
&lt;span style=&#34;color:#707a7c&#34;&gt;@Multipart&lt;/span&gt;  
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;suspend&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;sendPhoto&lt;/span&gt;(&lt;span style=&#34;color:#707a7c&#34;&gt;@Path&lt;/span&gt;(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;token&amp;#34;&lt;/span&gt;) token: BotToken, &lt;span style=&#34;color:#707a7c&#34;&gt;@Part&lt;/span&gt;(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;chat_id&amp;#34;&lt;/span&gt;) chatId: RequestBody, &lt;span style=&#34;color:#707a7c&#34;&gt;@Part&lt;/span&gt; photo: MultipartBody.Part): ResultWrapperBean&amp;lt;MessageBean&amp;gt;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;使用&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-kotlin&#34; data-lang=&#34;kotlin&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;String&lt;/span&gt;.toRequestBody(): RequestBody {  
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; RequestBody.create(MediaType.parse(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;text/plain&amp;#34;&lt;/span&gt;), &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;)  
}  
  
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;File&lt;/span&gt;.toMultiplePart(parameter: String): MultipartBody.Part {  
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; MultipartBody.Part.createFormData(parameter, name, RequestBody.create(MediaType.parse(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;multipart/form-data&amp;#34;&lt;/span&gt;), &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;))  
}

BotScope.launch(Dispatchers.IO) {  
    kotlin.runCatching {  
        BotApi.&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;get&lt;/span&gt;().sendPhoto(ConfigUtil.botToken, chatId.toRequestBody(), photoFile.toMultiplePart(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;photo&amp;#34;&lt;/span&gt;))  
    }.onFailure {  
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;it&lt;/span&gt;.printStackTrace()  
    }  
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h1 id=&#34;插件功能支持&#34;&gt;插件功能支持&lt;/h1&gt;
&lt;p&gt;因为 &lt;a href=&#34;https://www.ruiovo.top/&#34;&gt;我朋友&lt;/a&gt; 已经做了一个QQ摸鱼机器人，所以我想可以做个插件支持，“为了这碟醋做顿饺子”，生命在于折腾嘛。&lt;/p&gt;
&lt;h2 id=&#34;基本插件化原理&#34;&gt;基本插件化原理&lt;/h2&gt;
&lt;p&gt;java本身有加载外部jar的 &lt;code&gt;ClassLoader&lt;/code&gt; —— &lt;code&gt;URLClassLoader&lt;/code&gt; ，因此插件可以定义为单个外部jar包，插件与宿主之间借助SPI进行通信。&lt;/p&gt;
&lt;p&gt;因而，我首先定义插件API：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-kotlin&#34; data-lang=&#34;kotlin&#34;&gt;&lt;span style=&#34;color:#228b22&#34;&gt;/**  
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt; * 机器人功能接口，需要插件来实现  
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt; */&lt;/span&gt;  
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;interface&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;BotContentProvider&lt;/span&gt; {  
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;val&lt;/span&gt; pluginName: String  
  
    &lt;span style=&#34;color:#228b22&#34;&gt;/**  
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;     * 插件加载事件  
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;     */&lt;/span&gt;  
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;onPluginLoaded&lt;/span&gt;() {}  
  
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;onTextMessage&lt;/span&gt;(context: TextChatContext): Boolean = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;false&lt;/span&gt;  
}

  
&lt;span style=&#34;color:#228b22&#34;&gt;/**  
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt; * 机器人收到消息上下文对象，可以在此取到一些相关信息或进行一些操作  
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt; */&lt;/span&gt;  
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;interface&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;ChatContext&lt;/span&gt; {  
    &lt;span style=&#34;color:#228b22&#34;&gt;/**  
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;     * 发送方chat_id  
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;     */&lt;/span&gt;    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;val&lt;/span&gt; chatId: String  
  
    &lt;span style=&#34;color:#228b22&#34;&gt;/**  
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;     * 使用文本进行直接回复  
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;     * @param text 回复内容  
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;     */&lt;/span&gt;  
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;replyWithText&lt;/span&gt;(text: String)  
}  
  
&lt;span style=&#34;color:#228b22&#34;&gt;/**  
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt; * 文本消息上下文  
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt; */&lt;/span&gt;  
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;interface&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;TextChatContext&lt;/span&gt;: ChatContext {  
    &lt;span style=&#34;color:#228b22&#34;&gt;/**  
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;     * 收到的文本内容  
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;     */&lt;/span&gt;  
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;val&lt;/span&gt; text: String  
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;宿主通过implementation方式引入，插件通过compileOnly方式引入。当一条新消息到达时，宿主将调用插件的 &lt;code&gt;onTextMessage()&lt;/code&gt; 方法，如果插件进行了处理则返回true，消息不再传递给下一个插件。&lt;/p&gt;
&lt;p&gt;一个简单的EchoBot如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-kotlin&#34; data-lang=&#34;kotlin&#34;&gt;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;EchoBot&lt;/span&gt;: BotContentProvider {

	&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;onTextMessage&lt;/span&gt;(context: TextChatContext) {
		context.replyWithText(context.text)
	}
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;插件版本兼容&#34;&gt;插件版本兼容&lt;/h2&gt;
&lt;p&gt;然而这样的方案遇到一个问题，就是不同版本插件API的jar包不是ABI兼容的。如果API中新增了一个方法如 &lt;code&gt;onPhotoMessage&lt;/code&gt; ，即使这个方法有默认实现，第三方插件也是要重新编译才能被我们的新版本机器人使用的。这是因为Kotlin的接口默认实现是编译期间的魔法，它将类未实现接口的默认方法指向一个叫 &lt;code&gt;DefaultsImpls&lt;/code&gt; 的类。所以只有重新编译，第三方插件才能使用，因为他们没有实现我们新增的方法。&lt;/p&gt;
&lt;p&gt;我目前的方法是，给接口包名中加入版本号，每次升级时复制一份。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://images.ntutn.top/2022/08/18fd51b47d64a36b59035df69fa4fe3d.png&#34; alt=&#34;Pasted image 20220829014314&#34;&gt;&lt;/p&gt;
&lt;p&gt;然后加载插件时同时查找旧版本实现，通过适配器适配为新版本接口实现。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-kotlin&#34; data-lang=&#34;kotlin&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;BotContentProviderAdapter&lt;/span&gt;(&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;val&lt;/span&gt; adaptee: V1Adapter): V2Provider, LoggerOwner &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;by&lt;/span&gt; slf4jLoggerOwner&amp;lt;BotContentProviderAdapter&amp;gt;() {  
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;init&lt;/span&gt; {  
        logger.warn(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;{} 插件使用了旧版本API，现通过兼容方式装入，请联系开发者进行升级适配！&amp;#34;&lt;/span&gt;, adaptee.pluginName)  
    }  
  
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;override&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;val&lt;/span&gt; pluginName: String = adaptee.pluginName  
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;override&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;onPluginLoaded&lt;/span&gt;() {  
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;super&lt;/span&gt;.onPluginLoaded()  
        adaptee.onPluginLoaded()  
    }  
  
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;override&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;onTextMessage&lt;/span&gt;(context: ITextChatContext): Boolean {  
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; adaptee.onTextMessage(TextChatContextAdapter(context))  
    }  
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;其实还是很麻烦，不知道有没有更简单的方法。&lt;/p&gt;
&lt;h1 id=&#34;部署和运行&#34;&gt;部署和运行&lt;/h1&gt;
&lt;h2 id=&#34;基本部署&#34;&gt;基本部署&lt;/h2&gt;
&lt;p&gt;使用 &lt;a href=&#34;https://docs.gradle.org/current/userguide/application_plugin.html&#34;&gt;The Application Plugin&lt;/a&gt; 进行打包。tar包复制到服务器上，然后&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;tar -xvf ./starsea.tar
nohup starsea/starsea &amp;amp;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;偶然崩溃自动重启&#34;&gt;偶然崩溃自动重启&lt;/h2&gt;
&lt;p&gt;作为一个想要长期运行的机器人服务，偶尔崩掉一两次也是正常的，写一个脚本在程序崩溃时自动再次拉起来还是有必要的。当然我认为系统得至少稳定运行了一段时间，才能走崩溃自动拉起来的逻辑，否则万一发生了启动崩溃，拉起来就崩，崩了就拉起来，服务器：听我说谢谢你～&lt;/p&gt;
&lt;p&gt;我的策略是，启动时脚本创建一个标志文件，系统稳定运行一段时间如5分钟后就把这个文件删掉。如果发生崩溃且未找到这个文件，脚本就尝试再次把机器人拉起来。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;#!/bin/sh  
&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;&lt;/span&gt;  
&lt;span style=&#34;color:#228b22&#34;&gt;#  &lt;/span&gt;
&lt;span style=&#34;color:#228b22&#34;&gt;# Copyright © 2015-2021 the original authors.  &lt;/span&gt;
&lt;span style=&#34;color:#228b22&#34;&gt;#  &lt;/span&gt;
&lt;span style=&#34;color:#228b22&#34;&gt;# Licensed under the Apache License, Version 2.0 (the &amp;#34;License&amp;#34;);  &lt;/span&gt;
&lt;span style=&#34;color:#228b22&#34;&gt;# you may not use this file except in compliance with the License.  &lt;/span&gt;
&lt;span style=&#34;color:#228b22&#34;&gt;# You may obtain a copy of the License at  &lt;/span&gt;
&lt;span style=&#34;color:#228b22&#34;&gt;#  &lt;/span&gt;
&lt;span style=&#34;color:#228b22&#34;&gt;#      https://www.apache.org/licenses/LICENSE-2.0  &lt;/span&gt;
&lt;span style=&#34;color:#228b22&#34;&gt;#  &lt;/span&gt;
&lt;span style=&#34;color:#228b22&#34;&gt;# Unless required by applicable law or agreed to in writing, software  &lt;/span&gt;
&lt;span style=&#34;color:#228b22&#34;&gt;# distributed under the License is distributed on an &amp;#34;AS IS&amp;#34; BASIS,  &lt;/span&gt;
&lt;span style=&#34;color:#228b22&#34;&gt;# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  &lt;/span&gt;
&lt;span style=&#34;color:#228b22&#34;&gt;# See the License for the specific language governing permissions and  &lt;/span&gt;
&lt;span style=&#34;color:#228b22&#34;&gt;# limitations under the License.  &lt;/span&gt;
&lt;span style=&#34;color:#228b22&#34;&gt;#  &lt;/span&gt;
  
&lt;span style=&#34;color:#228b22&#34;&gt;# Attempt to set APP_HOME  &lt;/span&gt;
  
&lt;span style=&#34;color:#228b22&#34;&gt;# Resolve links: $0 may be a link  &lt;/span&gt;
&lt;span style=&#34;color:#00688b&#34;&gt;app_path&lt;/span&gt;=&lt;span style=&#34;color:#00688b&#34;&gt;$0&lt;/span&gt;  
  
&lt;span style=&#34;color:#228b22&#34;&gt;# Need this for daisy-chained symlinks.  &lt;/span&gt;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;while&lt;/span&gt;  
    &lt;span style=&#34;color:#00688b&#34;&gt;APP_HOME&lt;/span&gt;=&lt;span style=&#34;color:#cd5555&#34;&gt;${&lt;/span&gt;&lt;span style=&#34;color:#00688b&#34;&gt;app_path&lt;/span&gt;%&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;${&lt;/span&gt;&lt;span style=&#34;color:#00688b&#34;&gt;app_path&lt;/span&gt;##*/&lt;span style=&#34;color:#cd5555&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;}&lt;/span&gt;  &lt;span style=&#34;color:#228b22&#34;&gt;# leaves a trailing /; empty if no leading path  &lt;/span&gt;
    [ -h &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#00688b&#34;&gt;$app_path&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;&lt;/span&gt; ]  
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;do&lt;/span&gt;  
    &lt;span style=&#34;color:#00688b&#34;&gt;ls&lt;/span&gt;=&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;$(&lt;/span&gt; ls -ld &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#00688b&#34;&gt;$app_path&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;)&lt;/span&gt;  
    &lt;span style=&#34;color:#00688b&#34;&gt;link&lt;/span&gt;=&lt;span style=&#34;color:#cd5555&#34;&gt;${&lt;/span&gt;&lt;span style=&#34;color:#00688b&#34;&gt;ls&lt;/span&gt;#*&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39; -&amp;gt; &amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;}&lt;/span&gt;  
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;case&lt;/span&gt; &lt;span style=&#34;color:#00688b&#34;&gt;$link&lt;/span&gt; in             &lt;span style=&#34;color:#228b22&#34;&gt;#(  &lt;/span&gt;
      /*)   &lt;span style=&#34;color:#00688b&#34;&gt;app_path&lt;/span&gt;=&lt;span style=&#34;color:#00688b&#34;&gt;$link&lt;/span&gt; ;; &lt;span style=&#34;color:#228b22&#34;&gt;#(  &lt;/span&gt;
      *)    &lt;span style=&#34;color:#00688b&#34;&gt;app_path&lt;/span&gt;=&lt;span style=&#34;color:#00688b&#34;&gt;$APP_HOME$link&lt;/span&gt; ;;  
    esacdone  
  
&lt;span style=&#34;color:#00688b&#34;&gt;APP_HOME&lt;/span&gt;=&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;$(&lt;/span&gt; &lt;span style=&#34;color:#658b00&#34;&gt;cd&lt;/span&gt; &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;${&lt;/span&gt;&lt;span style=&#34;color:#00688b&#34;&gt;APP_HOME&lt;/span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;:-&lt;/span&gt;./&lt;span style=&#34;color:#cd5555&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;&lt;/span&gt; &amp;amp;&amp;amp; &lt;span style=&#34;color:#658b00&#34;&gt;pwd&lt;/span&gt; -P &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;)&lt;/span&gt; || &lt;span style=&#34;color:#658b00&#34;&gt;exit&lt;/span&gt;  
&lt;span style=&#34;color:#00688b&#34;&gt;DEMAND_LOCK&lt;/span&gt;=demand_lock.lock  
  
rm &lt;span style=&#34;color:#00688b&#34;&gt;$DEMAND_LOCK&lt;/span&gt;  
  
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;while&lt;/span&gt; &lt;span style=&#34;color:#658b00&#34;&gt;true&lt;/span&gt;  
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;do&lt;/span&gt;  
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; [ -f &lt;span style=&#34;color:#00688b&#34;&gt;$DEMAND_LOCK&lt;/span&gt; ]  
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;then&lt;/span&gt;  
        &lt;span style=&#34;color:#658b00&#34;&gt;break&lt;/span&gt;  
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;fi&lt;/span&gt;  
    touch &lt;span style=&#34;color:#00688b&#34;&gt;$DEMAND_LOCK&lt;/span&gt;  
    &lt;span style=&#34;color:#658b00&#34;&gt;echo&lt;/span&gt; &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;demand starting system...&amp;#34;&lt;/span&gt;  
    &lt;span style=&#34;color:#00688b&#34;&gt;$APP_HOME&lt;/span&gt;/starsea &lt;span style=&#34;color:#228b22&#34;&gt;# 启动一段时间后会删除这个文件 $DEMAND_LOCK    echo &amp;#34;system exited.&amp;#34;  &lt;/span&gt;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;done&lt;/span&gt;  
  
&lt;span style=&#34;color:#658b00&#34;&gt;echo&lt;/span&gt; &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;It seems that app exited in a short time. Please check and restart again.&amp;#34;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;然后在机器人启动时&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-kotlin&#34; data-lang=&#34;kotlin&#34;&gt;&lt;span style=&#34;color:#228b22&#34;&gt;// 运行5分钟后删除demand lock，这表示系统可以进入稳定运行阶段。如果刚启动就退出脚本不会重启程序  
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;handler.postDelayed({  
    File(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;demand_lock.lock&amp;#34;&lt;/span&gt;).takeIf { &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;it&lt;/span&gt;.exists() }?.delete() 
}, &lt;span style=&#34;color:#b452cd&#34;&gt;5&lt;/span&gt; * &lt;span style=&#34;color:#b452cd&#34;&gt;60&lt;/span&gt; * &lt;span style=&#34;color:#b452cd&#34;&gt;1000&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;主线程崩溃长时间未响应检测&#34;&gt;主线程崩溃/长时间未响应检测&lt;/h2&gt;
&lt;p&gt;与安卓上不同，java默认一个线程的崩溃并不会导致整个程序的退出。于去我们的需求讲这并不合适。&lt;/p&gt;
&lt;p&gt;按照我们现在的设计，主线程是相当重要的，崩溃或者严重卡顿是一定要退出的，否则都不会继续拉取和分发消息了，继续跑着也没有意义，不如直接崩掉，还能被我们上一步写的脚本重启。&lt;/p&gt;
&lt;p&gt;现有比较流行的ANR检测方法可以给我提供不错的参考：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;单独启动一个后台线程用于检测。&lt;/li&gt;
&lt;li&gt;首先设置一个陷阱flag，称bomb，同时向主线程post一个job去移除这个flag。&lt;/li&gt;
&lt;li&gt;后台线程休眠较长一段时间。&lt;/li&gt;
&lt;li&gt;后台线程判断flag是否还在，如果主线程没能及时“拆弹”，就说明他已经挂了或者严重卡顿了，此时让系统挂掉就好了。&lt;/li&gt;
&lt;li&gt;重复上面步骤。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;最终这部分代码如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-kotlin&#34; data-lang=&#34;kotlin&#34;&gt;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;object&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;ApplicationContext&lt;/span&gt;: Thread.UncaughtExceptionHandler, LoggerOwner &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;by&lt;/span&gt; slf4jLoggerOwner&amp;lt;ApplicationContext&amp;gt;() {  
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;val&lt;/span&gt; handler &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;by&lt;/span&gt; lazy { Handler(Looper.mainLooper()) }  
  
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;var&lt;/span&gt; exiting = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;false&lt;/span&gt;  
  
    &lt;span style=&#34;color:#228b22&#34;&gt;/**  
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;     * 将系统标记为稳定运行状态。demand_lock.lock文件是由启动脚本生成的。  
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;     */&lt;/span&gt;  
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;markStable&lt;/span&gt;() {  
        File(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;demand_lock.lock&amp;#34;&lt;/span&gt;).takeIf { &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;it&lt;/span&gt;.exists() }?.delete()  
    }  
  
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;init&lt;/span&gt;() {  
        &lt;span style=&#34;color:#228b22&#34;&gt;// 主线程挂掉立即终止运行  
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        Thread.setDefaultUncaughtExceptionHandler(&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;)  
  
        &lt;span style=&#34;color:#228b22&#34;&gt;// 主线程长期无响应终止运行  
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;var&lt;/span&gt; bomb: Boolean  
        thread {  
            Thread.currentThread().name = &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;main-watcher&amp;#34;&lt;/span&gt;  
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;while&lt;/span&gt; (&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;true&lt;/span&gt;) {  
                bomb = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;true&lt;/span&gt;  
                handler.post { bomb = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;false&lt;/span&gt; }  
                Thread.sleep(&lt;span style=&#34;color:#b452cd&#34;&gt;600&lt;/span&gt;_000)  
                &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (bomb) {  
                    logger.error(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;主线程长时间未响应！&amp;#34;&lt;/span&gt;)  
                    Thread.getAllStackTraces().forEach {  
                        logger.error(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;dump thread {}, {}&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;it&lt;/span&gt;.key, &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;it&lt;/span&gt;.value)  
                    }  
                    exitProcess(&lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;)  
                }  
            }  
        }  
  
        &lt;span style=&#34;color:#228b22&#34;&gt;// 运行5分钟后删除demand lock，这表示系统可以进入稳定运行阶段。如果刚启动就退出脚本不会重启程序  
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        handler.postDelayed({  
            markStable()  
        }, &lt;span style=&#34;color:#b452cd&#34;&gt;5&lt;/span&gt; * &lt;span style=&#34;color:#b452cd&#34;&gt;60&lt;/span&gt; * &lt;span style=&#34;color:#b452cd&#34;&gt;1000&lt;/span&gt;)  
    }  
  
    &lt;span style=&#34;color:#228b22&#34;&gt;/**  
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;     * 将当前系统状态标记为稳定并停机。如果因为意外问题停机请exitProcess。  
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;     */&lt;/span&gt;  
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;shutdown&lt;/span&gt;(delay: Long = &lt;span style=&#34;color:#b452cd&#34;&gt;3000L&lt;/span&gt;) {  
        markStable()  
        exiting = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;true&lt;/span&gt;  
        handler.postDelayed({  
            exitProcess(&lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;)  
        }, delay)  
    }  
  
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;override&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;uncaughtException&lt;/span&gt;(thread: Thread, tr: Throwable) {  
        logger.error(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;exception in thread {}&amp;#34;&lt;/span&gt;, thread, tr)  
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (thread.name == &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;main&amp;#34;&lt;/span&gt;) {  
            logger.error(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;Main thread crashed!&amp;#34;&lt;/span&gt;)  
            exitProcess(&lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;)  
        }  
    }  
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h1 id=&#34;其他&#34;&gt;其他&lt;/h1&gt;
&lt;h2 id=&#34;logger的封装&#34;&gt;Logger的封装&lt;/h2&gt;
&lt;p&gt;直接上代码。目的就是少写一点模板代码，没什么复杂的。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-kotlin&#34; data-lang=&#34;kotlin&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;interface&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;LoggerOwner&lt;/span&gt; {  
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;val&lt;/span&gt; logger: Logger  
}  
  
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;Slf4jLoggerOwner&lt;/span&gt;(&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;val&lt;/span&gt; tag: String) : LoggerOwner {  
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;val&lt;/span&gt; _logger &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;by&lt;/span&gt; lazy {  
        LoggerFactory.getLogger(tag)  
    }  
  
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;override&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;val&lt;/span&gt; logger: Logger  
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;get&lt;/span&gt;() = _logger  
}  
  
&lt;span style=&#34;color:#228b22&#34;&gt;/**  
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt; * 创建logger对象。  
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt; * 用于方法委托使用。  
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt; */&lt;/span&gt;  
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;inline&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;fun&lt;/span&gt; &amp;lt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;reified&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;T&lt;/span&gt;&amp;gt; &lt;span style=&#34;color:#008b45&#34;&gt;slf4jLoggerOwner&lt;/span&gt;(): Slf4jLoggerOwner = Slf4jLoggerOwner(T::&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt;.java.canonicalName?:&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;NO_NAME&amp;#34;&lt;/span&gt;)  
  
&lt;span style=&#34;color:#228b22&#34;&gt;/**  
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt; * 创建logger对象  
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt; * 用于直接使用  
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt; */&lt;/span&gt;  
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;inline&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;fun&lt;/span&gt; &amp;lt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;reified&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;T&lt;/span&gt;&amp;gt; &lt;span style=&#34;color:#008b45&#34;&gt;slf4jLogger&lt;/span&gt;(): Logger = slf4jLoggerOwner&amp;lt;T&amp;gt;().logger
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;使用方法一（类文件中）：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-kotlin&#34; data-lang=&#34;kotlin&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;Demo1&lt;/span&gt;: LoggerOwner &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;by&lt;/span&gt; slf4jLoggerOwner&amp;lt;Demo1&amp;gt;() {
	&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;demo1&lt;/span&gt;() {
		logger.info(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;demo 1&amp;#34;&lt;/span&gt;)
	}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;使用方法2（单个方法中）：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-kotlin&#34; data-lang=&#34;kotlin&#34;&gt;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;Demo2&lt;/span&gt;

&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;demo2&lt;/span&gt;() {
	&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;val&lt;/span&gt; logger = slf4jLogger&amp;lt;Demo2&amp;gt;()
	logger.info(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;demo 2&amp;#34;&lt;/span&gt;)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;- https://ntutn.top/posts/%E4%BB%8E%E5%A4%B4%E5%BC%80%E5%A7%8B%E5%88%B6%E4%BD%9C%E4%B8%80%E4%B8%AAtg%E6%9C%BA%E5%99%A8%E4%BA%BA/ - CC BY-SA 4.0</description>
        </item>
    
    
    
        <item>
        <title>Retrofit源码阅读</title>
        <link>https://ntutn.top/posts/retrofit%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/</link>
        <pubDate>Thu, 09 Jun 2022 17:02:54 +0800</pubDate>
        
        <guid>https://ntutn.top/posts/retrofit%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/</guid>
        <description>归零幻想 https://ntutn.top/posts/retrofit%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/ -&lt;p&gt;Retrofit是一个相当简洁的网络请求框架，其本质上只是对Okhttp的封装，实际上底层还是用Okhttp来执行网络请求。这两天终于比较闲一些，于是又想起了被我束之高阁的前辈的&lt;a href=&#34;https://www.jianshu.com/p/5fa78ef8e096&#34;&gt;武功秘籍&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&#34;retrofit的使用&#34;&gt;Retrofit的使用&lt;/h2&gt;
&lt;p&gt;参考官方例子，定义接口并使用&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-kotlin&#34; data-lang=&#34;kotlin&#34;&gt;  &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;interface&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;GitHub&lt;/span&gt; {
    &lt;span style=&#34;color:#707a7c&#34;&gt;@GET&lt;/span&gt;(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;/repos/{owner}/{repo}/contributors&amp;#34;&lt;/span&gt;)
    Call&amp;lt;List&amp;lt;Contributor&amp;gt;&amp;gt; contributors(&lt;span style=&#34;color:#707a7c&#34;&gt;@Path&lt;/span&gt;(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;owner&amp;#34;&lt;/span&gt;) String owner, &lt;span style=&#34;color:#707a7c&#34;&gt;@Path&lt;/span&gt;(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;repo&amp;#34;&lt;/span&gt;) String repo);
  }

    &lt;span style=&#34;color:#228b22&#34;&gt;// Create a very simple REST adapter which points the GitHub API.
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    Retrofit retrofit =
        new Retrofit.Builder()
            .baseUrl(API_URL)
            .addConverterFactory(GsonConverterFactory.create())
            .build();

    &lt;span style=&#34;color:#228b22&#34;&gt;// Create an instance of our GitHub API interface.
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    GitHub github = retrofit.create(GitHub.&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt;);

    &lt;span style=&#34;color:#228b22&#34;&gt;// Create a call instance for looking up Retrofit contributors.
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    Call&amp;lt;List&amp;lt;Contributor&amp;gt;&amp;gt; call = github.contributors(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;square&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;retrofit&amp;#34;&lt;/span&gt;);

    &lt;span style=&#34;color:#228b22&#34;&gt;// Fetch and print a list of the contributors to the library.
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    List&amp;lt;Contributor&amp;gt; contributors = call.execute().body();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;源码阅读&#34;&gt;源码阅读&lt;/h2&gt;
&lt;p&gt;首先来到梦的开始&lt;code&gt;retrofit2.Retrofit#create&lt;/code&gt;，可以看到这里是个动态代理，后续的处理交给&lt;code&gt;retrofit2.ServiceMethod#parseAnnotations&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://images.ntutn.top/2022/06/f5567d8937f9eb382f6f298e8221998f.png&#34; alt=&#34;image-20220607204925036&#34;&gt;&lt;/p&gt;
&lt;p&gt;而后ServiceMethod中解析注解中的信息&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://images.ntutn.top/2022/06/f8c181aff8fc7bd2e1d83a3b104431cb.png&#34; alt=&#34;image-20220607205316353&#34;&gt;&lt;/p&gt;
&lt;p&gt;继续阅读，果然在requestFactory的Builder中找到了&lt;code&gt;@GET&lt;/code&gt;、&lt;code&gt;@POST&lt;/code&gt;等注解的处理。&lt;/p&gt;
&lt;p&gt;继续HttpServiceMethod，暂时不看Kotlin Suspend Function部分，还是比较清晰的：就是处理了下call adapter，让请求的call对象转换到指定的线程工具上，如RxJava。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://images.ntutn.top/2022/06/f379ca7e8aa24bbe79701e55f95a83af.png&#34; alt=&#34;image-20220612235658307&#34;&gt;&lt;/p&gt;
&lt;p&gt;CallAdapted继承自HttpServiceMethod，而在HttpServiceMethod我们找到了网络请求对象OkhttpCall。&lt;/p&gt;
&lt;p&gt;然而OkhttpCall还是发起请求和处理响应的，发起请求还是用的RequestFactory。requestFactory是在上面解析注解时赋值的，很快找到了实际创建Okhttp对象的位置。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://images.ntutn.top/2022/06/f26b6c55e29d1ba59ed6325bb8a5bcd8.png&#34; alt=&#34;image-20220608152000407&#34;&gt;&lt;/p&gt;
&lt;p&gt;然后Response对象的解析&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://images.ntutn.top/2022/06/2e1af538596b09334e0f511ddce3d322.png&#34; alt=&#34;image-20220608152330130&#34;&gt;&lt;/p&gt;
&lt;p&gt;这里用responseConverter将原始的Response的body转换为解析好的Response对象。&lt;/p&gt;
&lt;p&gt;啪，没了。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;核心问题&#34;&gt;核心问题&lt;/h2&gt;
&lt;h3 id=&#34;如何自定义注解&#34;&gt;如何自定义注解?&lt;/h3&gt;
&lt;p&gt;读取注解信息，用于请求参数。处理方法参考：&lt;code&gt;retrofit2.RequestFactory.Builder#parseMethodAnnotation&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&#34;如何将方法转化成request对象&#34;&gt;如何将方法转化成Request对象？&lt;/h3&gt;
&lt;p&gt;借助动态代理实现接口定义方法，借助反射读取到方法形参和注解，借助形参类型和注解确定请求参数，最终在&lt;code&gt;retrofit2.RequestFactory#create&lt;/code&gt;构建出实际的OkhttpRequest。&lt;/p&gt;
&lt;h3 id=&#34;servicemethod的作用&#34;&gt;ServiceMethod的作用？&lt;/h3&gt;
&lt;p&gt;实现Okhttp Call到call adapter的委托。&lt;/p&gt;
&lt;h3 id=&#34;adapterconverter的设计思路如果想要实现将okhttp也变成可替换的应该如何设计代码&#34;&gt;adapter，converter的设计思路，如果想要实现将okhttp也变成可替换的应该如何设计代码？&lt;/h3&gt;
&lt;p&gt;Retrofit对象作为context，维护了各种所需参数和构造方法（factory）。在后续实际需要的位置创建出adapter。如可以定义NetlibAdapterFactory，RequestFactory中用到Okhttp的地方替换为由retrofit.netlibAdapterFactory创建。&lt;/p&gt;
&lt;h3 id=&#34;invocationhandler与泛型的使用&#34;&gt;InvocationHandler与泛型的使用？&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-kotlin&#34; data-lang=&#34;kotlin&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;object&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;StubHelper&lt;/span&gt; {
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;val&lt;/span&gt; TAG = &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;StubHelper&amp;#34;&lt;/span&gt;

    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;fun&lt;/span&gt; &amp;lt;&lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;T&lt;/span&gt;&amp;gt; &lt;span style=&#34;color:#008b45&#34;&gt;create&lt;/span&gt;(service: Class&amp;lt;T&amp;gt;): T {
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; Proxy.newProxyInstance(
            service.classLoader, arrayOf&amp;lt;Class&amp;lt;*&amp;gt;&amp;gt;(service),
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;object&lt;/span&gt; &lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;: &lt;/span&gt;&lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;InvocationHandler&lt;/span&gt; {
                &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;val&lt;/span&gt; emptyArgs = arrayOfNulls&amp;lt;Any&amp;gt;(&lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;)

                &lt;span style=&#34;color:#707a7c&#34;&gt;@Throws&lt;/span&gt;(Throwable::&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt;)
                &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;override&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;invoke&lt;/span&gt;(proxy: Any, method: Method, args: Array&amp;lt;Any&amp;gt;?): Any? {
                    Log.d(TAG, method.toGenericString())
                    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;null&lt;/span&gt;
                }
            }) &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;as&lt;/span&gt; T
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;- https://ntutn.top/posts/retrofit%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/ - CC BY-SA 4.0</description>
        </item>
    
    
    
        <item>
        <title>使用自动操作修改壁纸</title>
        <link>https://ntutn.top/posts/%E4%BD%BF%E7%94%A8%E8%87%AA%E5%8A%A8%E6%93%8D%E4%BD%9C%E4%BF%AE%E6%94%B9%E5%A3%81%E7%BA%B8/</link>
        <pubDate>Mon, 06 Jun 2022 12:28:23 +0800</pubDate>
        
        <guid>https://ntutn.top/posts/%E4%BD%BF%E7%94%A8%E8%87%AA%E5%8A%A8%E6%93%8D%E4%BD%9C%E4%BF%AE%E6%94%B9%E5%A3%81%E7%BA%B8/</guid>
        <description>归零幻想 https://ntutn.top/posts/%E4%BD%BF%E7%94%A8%E8%87%AA%E5%8A%A8%E6%93%8D%E4%BD%9C%E4%BF%AE%E6%94%B9%E5%A3%81%E7%BA%B8/ -&lt;p&gt;好久没水博客了，今天折腾折腾一个一直在系统里但是没用过的工具：自动操作（Automator）.&lt;/p&gt;
&lt;p&gt;首先打开自动操作，新建一个文稿。选择“应用程序”最终可以像其他app一样，点击就执行。但我希望的是每天自动更换，所以这里我选择“日历提醒”。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://images.ntutn.top/2022/06/3ebf8c39d50251a24eb49b2609740554.png&#34; alt=&#34;image-20220606143017895&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;下载壁纸&#34;&gt;下载壁纸&lt;/h2&gt;
&lt;p&gt;“自动操作”的使用方法还是很简单的，把左边的命令拖动过来稍加编辑就可以了。所以，我们得到了&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://images.ntutn.top/2022/06/896c884f3561a768223c71971628b88d.png&#34; alt=&#34;image-20220606143435257&#34;&gt;&lt;/p&gt;
&lt;p&gt;这里用的是Unsplash提供的随机壁纸服务，壁纸还是很合我的胃口的。图中URL：&lt;code&gt;https://source.unsplash.com/random/3584x2240&lt;/code&gt;。这里的“3584x2240”根据你的显示器分辨率填写。&lt;/p&gt;
&lt;h2 id=&#34;设置壁纸&#34;&gt;设置壁纸&lt;/h2&gt;
&lt;p&gt;虽然“自动操作”的资源库中有“设置壁纸”这个能力，但我实际测试发现它只能改当前屏幕的壁纸，对于我用双屏的来说就比较难受了。因而这里要用Apple Script来实现：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://images.ntutn.top/2022/06/12dd80f59b1dc9aee5923c92d81da6fe.png&#34; alt=&#34;image-20220606144009000&#34;&gt;&lt;/p&gt;
&lt;p&gt;图中的脚本为：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-script&#34; data-lang=&#34;script&#34;&gt;on run {input, parameters}
	
	set theFile to first item of input
	set filename to the POSIX path of theFile
	
	tell application &amp;quot;System Events&amp;quot;
		tell every desktop
			set picture to filename
		end tell
	end tell
	
	return filename
end run
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;清理垃圾&#34;&gt;清理垃圾&lt;/h2&gt;
&lt;p&gt;这个简单，删除所有不是今天创建的图片就行了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://images.ntutn.top/2022/06/d29f2ca3a42162fe097d1b253b5be475.png&#34; alt=&#34;image-20220606144228022&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;每天执行&#34;&gt;每天执行&lt;/h2&gt;
&lt;p&gt;保存后，打开日程应用，可以看到出现了一条刚刚添加的日程。使用Command+E快捷键修改日程，“重复”改为每天。最终结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://images.ntutn.top/2022/06/124d0a57cf1dbaa5394618b0fa142957.png&#34; alt=&#34;image-20220606123009808&#34;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;最后效果&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://images.ntutn.top/2022/06/1f49740d16ba84164d5cac3561f63e94.png&#34; alt=&#34;image-20220606144803374&#34;&gt;&lt;/p&gt;
&lt;p&gt;摸鱼结束，我去搬砖了。&lt;/p&gt;
- https://ntutn.top/posts/%E4%BD%BF%E7%94%A8%E8%87%AA%E5%8A%A8%E6%93%8D%E4%BD%9C%E4%BF%AE%E6%94%B9%E5%A3%81%E7%BA%B8/ - CC BY-SA 4.0</description>
        </item>
    
    
    
        <item>
        <title>About</title>
        <link>https://ntutn.top/about/</link>
        <pubDate>Sat, 30 Apr 2022 01:33:04 +0800</pubDate>
        
        <guid>https://ntutn.top/about/</guid>
        <description>归零幻想 https://ntutn.top/about/ -&lt;p&gt;归零幻想是本人的网名啦，这里是我的博客小站。本人在其他地方帐号大多也叫这个名字。&lt;/p&gt;
&lt;p&gt;本人2021年本科毕业于中国石油大学（华东），现在人在抖音。&lt;/p&gt;
&lt;p&gt;博客系统至今我写过三个版本&lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;，毕竟写出个CRUD就可以厚着脸皮说自己是个博客了。&lt;/p&gt;
&lt;p&gt;然而折腾折腾就不想折腾了，现在迁移到了&lt;a href=&#34;https://gohugo.io/&#34;&gt;hugo&lt;/a&gt;。选择这个而不是更主流的hexo、jeklly等是因为hugo是用golang编写的，它在不同设备上部署成本低，而且不会要求你装一堆依赖，污染本地开发环境。&lt;/p&gt;
&lt;p&gt;总之，感谢 &lt;a href=&#34;https://go.dev/&#34;&gt;golang&lt;/a&gt; ，感谢&lt;a href=&#34;https://gohugo.io/&#34;&gt;hugo&lt;/a&gt;，感谢&lt;a href=&#34;https://github.com/AmazingRise/hugo-theme-diary&#34;&gt;hugo-theme-diary&lt;/a&gt;，感谢&lt;a href=&#34;https://pages.github.com/&#34;&gt;Github Pages&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;如果希望和我交个朋友，你可以通过在评论区留言的方式和我联系。&lt;/p&gt;
&lt;p&gt;在未另行说明的情况下，本站内容遵守 &lt;a href=&#34;https://creativecommons.org/licenses/by-sa/4.0/deed.zh&#34;&gt;署名-相同方式共享 4.0 国际 (CC BY-SA 4.0)&lt;/a&gt;  。文章撰写过程中难免引用到一些站外资源，如果您认为某些内容侵犯了您的著作权，您可在评论区留下联系方式，我会及时与您联系。&lt;/p&gt;
&lt;section class=&#34;footnotes&#34; role=&#34;doc-endnotes&#34;&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id=&#34;fn:1&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;第一个版本是很遥远的过去了，&lt;a href=&#34;https://github.com/zerofancy/blogSystem&#34;&gt;第二个版本&lt;/a&gt;是用springboot写的，颇有杀鸡用牛刀之嫌。一方面不想继续交服务器租金了，另一方面原来部分代码写得很烂，当真懒得改了。加上新学了Kotlin，正想练手，这就有了&lt;a href=&#34;https://github.com/zerofancy/kmdblog&#34;&gt;第三个版本&lt;/a&gt;。&amp;#160;&lt;a href=&#34;#fnref:1&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
- https://ntutn.top/about/ - CC BY-SA 4.0</description>
        </item>
    
    
    
        <item>
        <title>Friends</title>
        <link>https://ntutn.top/friends/</link>
        <pubDate>Sat, 30 Apr 2022 01:23:47 +0800</pubDate>
        
        <guid>https://ntutn.top/friends/</guid>
        <description>归零幻想 https://ntutn.top/friends/ -&lt;p&gt;有空也去我朋友家坐坐哦～&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.semesse.me/&#34;&gt;色魔是色魔&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://www.xyx6.top/&#34;&gt;XYX&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://upccaishu.top/&#34;&gt;菜树&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.ruiovo.top/&#34;&gt;ruiOvO&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/Viadimir&#34;&gt;~浮生若梦&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.cnblogs.com/lglh/&#34;&gt;lglh&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
- https://ntutn.top/friends/ - CC BY-SA 4.0</description>
        </item>
    
    
    
        <item>
        <title>把你的光猫变成一个丐版nas</title>
        <link>https://ntutn.top/posts/%E6%8A%8A%E4%BD%A0%E7%9A%84%E5%85%89%E7%8C%AB%E5%8F%98%E6%88%90%E4%B8%80%E4%B8%AA%E4%B8%90%E7%89%88nas/</link>
        <pubDate>Tue, 12 Apr 2022 01:21:54 +0800</pubDate>
        
        <guid>https://ntutn.top/posts/%E6%8A%8A%E4%BD%A0%E7%9A%84%E5%85%89%E7%8C%AB%E5%8F%98%E6%88%90%E4%B8%80%E4%B8%AA%E4%B8%90%E7%89%88nas/</guid>
        <description>归零幻想 https://ntutn.top/posts/%E6%8A%8A%E4%BD%A0%E7%9A%84%E5%85%89%E7%8C%AB%E5%8F%98%E6%88%90%E4%B8%80%E4%B8%AA%E4%B8%90%E7%89%88nas/ -&lt;!-- raw HTML omitted --&gt;
&lt;h1 id=&#34;把你的光猫变成一个丐版nas&#34;&gt;把你的光猫变成一个丐版NAS&lt;/h1&gt;
&lt;p&gt;我的初衷是调研下光猫改桥接的可行性，结果拿到超级管理员密码后还是没有这个选项。但在这个过程中发现直接在光猫上跑个下载服务却是可行的。&lt;/p&gt;
&lt;h2 id=&#34;允许ftp访问和telnet访问&#34;&gt;允许FTP访问和telnet访问&lt;/h2&gt;
&lt;p&gt;访问 http://192.168.1.1 ，输入密码后进入光猫管理后台。这里我找到“上网帐号设置”，备份宽带帐号和密码。不得不说他系统还是挺拉的，密码框直接用审查元素功能把 type 改为 input 就可以看到密码了。&lt;/p&gt;
&lt;p&gt;第一步后台不要退出，访问 http://192.168.1.1/servmngr.html 。这里看到一个空白页面，审查元素后发现大有乾坤。 &lt;img src=&#34;https://images.ntutn.top/2022/04/78e9db7285fda2ee43fd5901902d3208.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;p&gt;将这些代码取消注释，此时网页还是空白的，但是用 Ctrl+A 可以看到实际是有内容的。在这个页面开启 telnet 访问，并设置密码。注意用户名为 admin 不要改，否则后面 telnet 登陆不进去。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;telnet 192.168.1.1&lt;/code&gt; 成功后执行&lt;code&gt;sh&lt;/code&gt;。然后&lt;code&gt;uname -a&lt;/code&gt;看下。这里我就不记录查看管理员密码步骤了，反正这个型号管理员面板也没有设置桥接的选项。&lt;/p&gt;
&lt;h2 id=&#34;开始整活&#34;&gt;开始整活&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;top&lt;/code&gt;，发现占用内存最高的是个两个 java 进程。&lt;code&gt;java -version&lt;/code&gt;，发现安装了 java8 。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-plain&#34; data-lang=&#34;plain&#34;&gt;# java -version
openjdk version &amp;#34;1.8.0-internal&amp;#34;
OpenJDK Runtime Environment (build 1.8.0-internal-jenkinsang_2022_01_15_04_03-b00)
JamVM (build 2.0.0, inline-threaded interpreter with stack-caching)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;free&lt;/code&gt;命令可知总内存约二十多兆，剩余仅 3 兆。这点空间是搞不了什么事情的，因此我尝试干掉前述两个 java 进程。&lt;code&gt;ps -aux | grep java&lt;/code&gt;，发现除了存在两个 java 进程，还写了脚本自动把这两个进程拉起来，即&lt;code&gt;/etc/monitor_java.sh&lt;/code&gt; 。统统 kill 掉。&lt;/p&gt;
&lt;p&gt;现在有 10 兆左右的内存了，对于 java 来说可能还是不太能搞事，但跑个 aria2 足够了！尝试插入 U 盘，发现在&lt;code&gt;/mnt/usb1_1&lt;/code&gt;自动挂载。&lt;/p&gt;
&lt;p&gt;交叉编译 aria2c ，这里我用的是这个脚本：https://gitee.com/logic_2050/auto-build-aria2-mips32-static 。在我的 debian11 编译过程中只遇到一个问题，手动&lt;code&gt;sudo apt install autoreconf&lt;/code&gt;即可。&lt;/p&gt;
&lt;p&gt;如何把文件弄到光猫里，以及取出来？每次插拔 U 盘也太麻烦了。于是我找到一个支持上传的简单文件服务器：https://github.com/mayth/go-simple-upload-server。仍然交叉编译到 mips 静态包。&lt;code&gt;env GOOS=linux GOARCH=mips GOMIPS=softfloat go build -trimpath -ldflags=&amp;quot;-s -w -extldflags=-static&amp;quot;&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;成品&#34;&gt;成品&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://images.ntutn.top/2022/04/bc80e51855b842dedd7268113042e378.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;拓展&#34;&gt;拓展&lt;/h2&gt;
&lt;h3 id=&#34;被我干掉的两个-java-进程是做什么的&#34;&gt;被我干掉的两个 java 进程是做什么的&lt;/h3&gt;
&lt;p&gt;光猫跑 java 属实有点离谱，一半内存都是他们占的，干掉后也不影响上网，甚至也不影响光猫后台管理。嗯，有点耐人寻味。&lt;/p&gt;
&lt;h3 id=&#34;ftp访问为空白&#34;&gt;FTP访问为空白&lt;/h3&gt;
&lt;p&gt;经测试，该型号FTP访问根目录是一片空白，但大多数子目录还是可以正常访问的，如&lt;code&gt;/mnt/usb1_1&lt;/code&gt;，完全能满足要求。&lt;/p&gt;
&lt;h3 id=&#34;无法执行重启后文件丢失&#34;&gt;无法执行/重启后文件丢失&lt;/h3&gt;
&lt;p&gt;有些目录下是无法写入的，有些虽然可以写入，但是重启会丢失，还有些目录下无法执行程序。&lt;/p&gt;
&lt;p&gt;我选择把整活用的程序放到&lt;code&gt;/fhconf/&lt;/code&gt;下，因为光猫自己的配置文件备份就放在这里，显然这里是不会重置的。&lt;/p&gt;
&lt;h3 id=&#34;支持-https&#34;&gt;支持 https&lt;/h3&gt;
&lt;p&gt;只要将你的电脑下的&lt;code&gt;/etc/ssl/certs/ca-certificates.crt&lt;/code&gt;文件复制到光猫下，并在aria2的配置文件中指定就可以了。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;ca-certificate=/fhconf/custom/aria2/ca-certificates.crt
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;oom&#34;&gt;OOM&lt;/h3&gt;
&lt;p&gt;尽管aria2确实已经很省资源了，但当尝试BT下载一个比较大的文件时（超过2GB）还是很容易占用超过10M内存，然后关键进程OOM就巴比Q了。我尝试过修改配置文件，关闭disk-cache、关闭预分配甚至限制下载速度等均无法解决。所以该方案的实用性其实并不是很高。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;也无所谓，生命在于折腾嘛。
也许设置swap可以解决这个问题，但默认没有这个命令，估计还得去编译busybox。唉，算了吧……&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!-- raw HTML omitted --&gt;
- https://ntutn.top/posts/%E6%8A%8A%E4%BD%A0%E7%9A%84%E5%85%89%E7%8C%AB%E5%8F%98%E6%88%90%E4%B8%80%E4%B8%AA%E4%B8%90%E7%89%88nas/ - CC BY-SA 4.0</description>
        </item>
    
    
    
        <item>
        <title>AUIL学习</title>
        <link>https://ntutn.top/posts/auil%E5%AD%A6%E4%B9%A0/</link>
        <pubDate>Sun, 13 Feb 2022 18:11:08 +0800</pubDate>
        
        <guid>https://ntutn.top/posts/auil%E5%AD%A6%E4%B9%A0/</guid>
        <description>归零幻想 https://ntutn.top/posts/auil%E5%AD%A6%E4%B9%A0/ -&lt;!-- raw HTML omitted --&gt;
&lt;h1 id=&#34;auil-源码学习-重点问题&#34;&gt;AUIL 源码学习 重点问题&lt;/h1&gt;
&lt;p&gt;AUIL是个比较知名的图片加载库，源码结构比较清晰和简单，我在阅读学习中整理了以下内容。&lt;/p&gt;
&lt;h2 id=&#34;memorycache&#34;&gt;MemoryCache&lt;/h2&gt;
&lt;p&gt;顾名思义，这个是在内存中缓存Bitmap相关的代码。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://images.ntutn.top/2022/02/04ac71a8c8e1622e2bc287f2fd6e92cf.svg&#34; alt=&#34;auil&#34;&gt;&lt;/p&gt;
&lt;p&gt;MemoryCache结合了策略模式和装饰器模式，初始化时可选择不同缓存策略。&lt;/p&gt;
&lt;p&gt;一个Cache类内部持有一定量的Bitmap元素，并根据某种策略自动移除未使用的Bitmap。看结构我们应该从BaseMemoryCache开始看起。&lt;/p&gt;
&lt;p&gt;BaseMemoryCache中持有了所有放入的元素的弱引用，而它的子类根据策略持有了部分缓存对象的强引用。&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;h2 id=&#34;整个框架分多少个模块每个模块的作用是什么&#34;&gt;整个框架分多少个模块，每个模块的作用是什么&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;ImageLoader 门面。&lt;/li&gt;
&lt;li&gt;ImageAware 对最终处理和展示图片操作的封装。&lt;/li&gt;
&lt;li&gt;MemoryCache bitmap在内存中的缓存。&lt;/li&gt;
&lt;li&gt;BitmapProcessor 图片处理器，处理原始图片。分为预处理和后处理，预处理的结果会存入缓存，而后处理每次展示都会执行。&lt;/li&gt;
&lt;li&gt;BitmapDisplayer 控制图片展示，可为其附加一定的展示效果。&lt;/li&gt;
&lt;li&gt;DiskCache bitmap在磁盘中的缓存&lt;/li&gt;
&lt;li&gt;ImageDecoder 将图片解码为Bitmap，并缩放到合适尺寸&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;如何仅通过interface就将框架的整个流程串联起来&#34;&gt;如何仅通过interface就将框架的整个流程串联起来&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://images.ntutn.top/2022/02/09ba58caadf71408c7a97bc8e1443154.svg&#34; alt=&#34;模块调用顺序&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;如何进行内存管理的lru是种什么算法有没有比lru更好的&#34;&gt;如何进行内存管理的，LRU是种什么算法，有没有比LRU更好的？&lt;/h2&gt;
&lt;p&gt;AUIL的图片缓存有二级，一是所有缓存过的图片都会持有WeakReference，可能随时回收；二是部分图片会持有强引用，不会被回收。这里的部分图片的总共大小可以设置，达到阈值之后使用一定的算法淘汰一些图片。这里最常用的就是LRU。&lt;/p&gt;
&lt;p&gt;LRU是淘汰缓存文件的算法，它每次淘汰最久未使用的文件。是一种最常用的页面置换算法。除了LRU之外，AUIL预置的算法还有FIFO（先入先出）、LargestLimitted（淘汰最大的文件）、LFU（淘汰使用频率最低的）。三者各有优劣。&lt;/p&gt;
&lt;p&gt;如，LRU因为图片展示频率在时间上的不均匀性，可能将一些高频展示的图片淘汰掉，导致缓存命中率下降；LFU对于新图片频率统计无法比较好把控。&lt;/p&gt;
&lt;h2 id=&#34;用到了多少个线程池这些线程池之间的区别是什么如果只用一个线程池可以么&#34;&gt;用到了多少个线程池，这些线程池之间的区别是什么，如果只用一个线程池可以么？&lt;/h2&gt;
&lt;p&gt;使用了三个线程池：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;taskExecutor&lt;/li&gt;
&lt;li&gt;taskExecutorForCachedImages&lt;/li&gt;
&lt;li&gt;taskDistributor&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;taskExecutor和taskExecutorForCachedImages都是用来执行图片处理和展示任务的，他们处理顺序都是个LIFO（后进先出）的队列，而taskDistributor是个普通的线程池，用于框架内其他任务。&lt;/p&gt;
&lt;p&gt;taskExecutorForCachedImages是专门为缓存中读取的图片展示用的线程池，因为这类图片响应会很快，所以AUIL专门给他们准备了一个线程池。
综上，如果用一个线程池则最终效果会大打折扣。&lt;/p&gt;
- https://ntutn.top/posts/auil%E5%AD%A6%E4%B9%A0/ - CC BY-SA 4.0</description>
        </item>
    
    
    
        <item>
        <title>给APP添加构建信息</title>
        <link>https://ntutn.top/posts/%E7%BB%99app%E6%B7%BB%E5%8A%A0%E6%9E%84%E5%BB%BA%E4%BF%A1%E6%81%AF/</link>
        <pubDate>Sun, 16 Jan 2022 23:24:16 +0800</pubDate>
        
        <guid>https://ntutn.top/posts/%E7%BB%99app%E6%B7%BB%E5%8A%A0%E6%9E%84%E5%BB%BA%E4%BF%A1%E6%81%AF/</guid>
        <description>归零幻想 https://ntutn.top/posts/%E7%BB%99app%E6%B7%BB%E5%8A%A0%E6%9E%84%E5%BB%BA%E4%BF%A1%E6%81%AF/ -&lt;!-- raw HTML omitted --&gt;
&lt;h1 id=&#34;给app添加构建信息&#34;&gt;给APP添加构建信息&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;这两天在琢磨一个问题，一个APP是怎么知道自己是怎么来的呢？
一个应用得知道自己是怎么来的，这样出了问题才知道该找谁。举个例子，当应用发生了一个线上crash，崩溃信息收集上来，然后我们打开堆栈一看懵了——这个发生崩溃的&lt;code&gt;v5.c&lt;/code&gt;是哪个类呢？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://images.ntutn.top/2022/01/9616ad8a32ec122442705981e9e97847.png&#34; alt=&#34;crash&#34;&gt;&lt;/p&gt;
&lt;p&gt;显然，代码被混淆过，我们要拿到编译时生成的&lt;code&gt;mapping.txt&lt;/code&gt;来还原堆栈，如图&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://images.ntutn.top/2022/01/aaa2591c565385ad28ce781047c567e5.png&#34; alt=&#34;retrace&#34;&gt;&lt;/p&gt;
&lt;p&gt;**然而，我们编译了很多次，客官您要的是哪次的mapping文件呢？**显然，我们不仅要保留每次构建的相关信息，还得能准确区分开每次构建的产物，能做到有问题立即查询到对应构建信息。&lt;/p&gt;
&lt;p&gt;应用需要知道自己是“&lt;em&gt;怎么来的&lt;/em&gt;”。&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;h2 id=&#34;区分不同构建结果&#34;&gt;区分不同构建结果&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;可以收集当前commit id，commit不同一定是不同构建。&lt;/li&gt;
&lt;li&gt;可以生成一个较长的随机数每次构建不同。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;看上去前者更优雅，但一个commit id上并不一定只有一个成功的构建，比如你做一应用叫“快音”，测试通过后调整了一些编译选项打出线上包，此时只根据commit id就无法确定是对应测试包的构建还是线上包了。&lt;/p&gt;
&lt;p&gt;所以，最实在的方法还是后者。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-kotlin&#34; data-lang=&#34;kotlin&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;runShellCommand&lt;/span&gt;(command: String): String {
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;val&lt;/span&gt; byteOut = ByteArrayOutputStream()
    project.exec {
        commandLine = command.split(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34; &amp;#34;&lt;/span&gt;)
        standardOutput = byteOut
    }
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; String(byteOut.toByteArray())
}
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;val&lt;/span&gt; buildNumber = UUID.randomUUID()
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;val&lt;/span&gt; gitBranch = runShellCommand(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;git branch --show-current&amp;#34;&lt;/span&gt;).trim()
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;val&lt;/span&gt; gitCommitId = runShellCommand(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;git rev-parse HEAD&amp;#34;&lt;/span&gt;).trim()
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;val&lt;/span&gt; buildTimeMILLIS = System.currentTimeMillis()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;将信息传给应用&#34;&gt;将信息传给应用&lt;/h2&gt;
&lt;p&gt;不知道大家有没有这种习惯，在开发时加一些测试代码时判断只在Debug版本生效，即&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-kotlin&#34; data-lang=&#34;kotlin&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (BuildConfig.DEBUG) {
    Toast.makeText(applicationContext, &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;test&amp;#34;&lt;/span&gt;, Toast.LENGTH_SHORT).show()
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这样即使我真的忘记删除这段代码也不会影响到线上，让用户看到个“test”感到莫名其妙。这里用的&lt;code&gt;BuildConfig&lt;/code&gt;就是在Gradle构建时生成的一个类，里面包含了一些有关当前构建的信息&lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;
&lt;p&gt;而幸运的是，官方也提供了方法让我们可以往&lt;code&gt;BuildConfig&lt;/code&gt;里面自己加东西，于是&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-kotlin&#34; data-lang=&#34;kotlin&#34;&gt;android {
    defaultConfig {
        buildConfigField(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;String&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;BUILD_NUMBER&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;\&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;$buildNumber&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;\&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;&lt;/span&gt;)
        buildConfigField(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;String&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;GIT_BRANCH&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;\&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;$gitBranch&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;\&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;&lt;/span&gt;)
        buildConfigField(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;String&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;GIT_COMMIT_ID&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;\&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;$gitCommitId&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;\&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;&lt;/span&gt;)
        buildConfigField(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;Long&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;BUILD_TIME_MILLIS&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;${buildTimeMILLIS}&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;L&amp;#34;&lt;/span&gt;)
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;然后这些字段就会出现在&lt;code&gt;BuildConfig&lt;/code&gt;中&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://images.ntutn.top/2022/01/55dc59fdd208c87b155b6a3947fc77f4.png&#34; alt=&#34;BuildConfig自定义字段&#34;&gt;&lt;/p&gt;
&lt;p&gt;我们在报告崩溃信息时就可以带上，这样排查时就知道从何开始找起了。&lt;/p&gt;
&lt;h2 id=&#34;保存构建信息&#34;&gt;保存构建信息&lt;/h2&gt;
&lt;p&gt;自定义一个task来进行发布，反正都是Kotlin代码，怎么保存这里不展开了。最终我们的服务端不但记录每一次构建时的最终产物，还记录了&lt;code&gt;mapping.txt&lt;/code&gt;文件，记录了buildNumber，当后面排查问题时就能比较简单复现场景了。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-kotlin&#34; data-lang=&#34;kotlin&#34;&gt;tasks.create(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;apkReleaseAndUpload&amp;#34;&lt;/span&gt;) {
    dependsOn(tasks[&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;assemble&amp;#34;&lt;/span&gt;])
    doLast {
        println(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;发布任务开始（构建版本号&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;$buildNumber&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;）&amp;#34;&lt;/span&gt;)
        &lt;span style=&#34;color:#228b22&#34;&gt;// 保存构建信息
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;hr&gt;
&lt;p&gt;进行到这里，我们就做到了之前说的目标，应用知道自己是怎么来的（保留了构建相关信息），我们排查问题也有个大概方向。&lt;/p&gt;
&lt;section class=&#34;footnotes&#34; role=&#34;doc-endnotes&#34;&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id=&#34;fn:1&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;&lt;a href=&#34;https://developer.android.com/studio/build/gradle-tips#share-custom-fields-and-resource-values-with-your-app-code&#34;&gt;与应用代码共享自定义字段和资源值 &lt;/a&gt;&amp;#160;&lt;a href=&#34;#fnref:1&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
- https://ntutn.top/posts/%E7%BB%99app%E6%B7%BB%E5%8A%A0%E6%9E%84%E5%BB%BA%E4%BF%A1%E6%81%AF/ - CC BY-SA 4.0</description>
        </item>
    
    
  </channel>
</rss> 