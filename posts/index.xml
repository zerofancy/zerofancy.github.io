<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on 归零幻想</title>
    <link>https://ntutn.top/posts/</link>
    <description>Recent content in Posts on 归零幻想</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <copyright>CC BY-SA 4.0</copyright>
    <lastBuildDate>Sun, 24 Oct 2021 03:11:37 +0800</lastBuildDate><atom:link href="https://ntutn.top/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>android项目开发：持久化</title>
      <link>https://ntutn.top/posts/%E6%8C%81%E4%B9%85%E5%8C%96/</link>
      <pubDate>Sun, 24 Oct 2021 03:11:37 +0800</pubDate>
      
      <guid>https://ntutn.top/posts/%E6%8C%81%E4%B9%85%E5%8C%96/</guid>
      <description>《第一行代码》阅读记录，有关数据持久化存储，略过了数据库的方式。
持久化 文件存储 先暂时只是写了个demo，有需要再深入看。
private fun saveText(inputText: String) { try { val output = openFileOutput(&amp;#34;data&amp;#34;, Context.MODE_PRIVATE) val writer = BufferedWriter(OutputStreamWriter(output)) writer.use { it.write(inputText) } } catch (e: IOException) { e.printStackTrace() } } private fun loadText(): String { val content = StringBuilder() try { val input = openFileInput(&amp;#34;data&amp;#34;) val reader = BufferedReader(InputStreamReader(input)) reader.use { r -&amp;gt; r.forEachLine { content.appendLine(it) } } } catch (e: IOException) { e.printStackTrace() } return content.toString() } SharedPreference saveButton.</description>
    </item>
    
    <item>
      <title>android项目开发：Kotlin</title>
      <link>https://ntutn.top/posts/kotlin/</link>
      <pubDate>Tue, 12 Oct 2021 03:11:37 +0800</pubDate>
      
      <guid>https://ntutn.top/posts/kotlin/</guid>
      <description>Kotlin 变量和函数 变量 用var和val定义变量，并有类型自动推导的支持。
val用来声明一个不可变的变量，var用来声明一个可变的变量。
val a = 10 var b: Int = 12 Kotlin完全抛弃了java中的基本数据类型，完全使用对象数据类型。
   java基本数据类型 Kotlin对象数据类型 数据类型说明     int Int 整型   long Long 长整型   short Short 短整型   float Float 单精度浮点型   double Double 双精度浮点型   boolean Boolean 布尔型   char Char 字符型   byte Byte 字节型    函数 语法：
fun main(args: Array&amp;lt;String&amp;gt;) { println(&amp;#34;Hello World!</description>
    </item>
    
    <item>
      <title>干掉macOS的OCSP</title>
      <link>https://ntutn.top/posts/%E5%B9%B2%E6%8E%89macos%E7%9A%84ocsp/</link>
      <pubDate>Sun, 21 Feb 2021 03:11:37 +0800</pubDate>
      
      <guid>https://ntutn.top/posts/%E5%B9%B2%E6%8E%89macos%E7%9A%84ocsp/</guid>
      <description>苹果这两天摊上事了，有不少用户说自己的设备打开应用程序会卡好几分钟，然后分析发现是苹果的OCSP校验导致的。
当启动一个新应用程序的时候，系统会把其hash发送到ocsp.apple.com用于校验，而这次是这个服务挂了但是能ping通……
这个事情引起不小的讨论，主要集中在有关隐私的担忧上。本来我没有太在意，但测试发现这好像是我每次休眠恢复后触摸板卡几秒的元凶……
那对不起了。
echo &amp;#34;127.0.0.1 ocsp.apple.com&amp;#34; | sudo tee -a /etc/hosts 反正还有SEP把门呢。</description>
    </item>
    
    <item>
      <title>android项目开发：通知</title>
      <link>https://ntutn.top/posts/%E9%80%9A%E7%9F%A5/</link>
      <pubDate>Tue, 12 Jan 2021 03:11:37 +0800</pubDate>
      
      <guid>https://ntutn.top/posts/%E9%80%9A%E7%9F%A5/</guid>
      <description>仍然是第一行代码的笔记，这篇是有关通知的，最基本的用法。
通知的相关知识 通知是什么不再赘述，这里只记录些重要但没接触的概念。
通知渠道在8.0（O）引入。要求APP将通知分类，通过不同渠道进行分发，用户可以选择性禁用某个渠道的通知，或者调整优先等级。
通知可以有不同的重要等级，有四种：IMPORTANCE_HIGH、IMPORTANCE_DEFAULT、IMPORTANCE_LOW、IMPORTANCE_MIN。根据重要等级不同，通知可能有不同的展现策略，比如在前台提示甚至播放声音。
在通知渠道创建时通知的重要等级也就确定了，之后不能再被APP修改。
通知dmeo package top.ntutn.notificationtest import android.app.NotificationChannel import android.app.NotificationManager import android.app.PendingIntent import android.content.Context import android.content.Intent import android.graphics.BitmapFactory import android.os.Build import androidx.appcompat.app.AppCompatActivity import android.os.Bundle import androidx.core.app.NotificationCompat import top.ntutn.notificationtest.databinding.ActivityMainBinding class MainActivity : AppCompatActivity() { private lateinit var binding: ActivityMainBinding override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) binding = ActivityMainBinding.inflate(layoutInflater) setContentView(binding.root) initView() } private fun initView(){ val manager = getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager if(Build.VERSION.SDK_INT &amp;gt;= Build.VERSION_CODES.O){ // 通知渠道  val channel = NotificationChannel(&amp;#34;normal&amp;#34;,&amp;#34;Normal&amp;#34;,NotificationManager.</description>
    </item>
    
    <item>
      <title>android项目开发：Broadcast</title>
      <link>https://ntutn.top/posts/broadcast/</link>
      <pubDate>Thu, 24 Dec 2020 03:11:37 +0800</pubDate>
      
      <guid>https://ntutn.top/posts/broadcast/</guid>
      <description>仍然是《第一行代码》的学习笔记，安卓内置广播机制。
Android中每个应用程序都可以对自己感兴趣的广播进行注册，包括来自系统的，和其他应用程序的。
广播分为标准广播和有序广播。
 标准广播异步执行，所有BroadcastReceiver几乎同时收到广播的消息。 有序广播 同步执行，只有前一个Receiver逻辑执行完后才会传递给下一个，且可以将广播截断。  接收系统广播 BroadcastReceiver的onReceive()方法是在主线程调用的，不应执行耗时操作。但开一个新线程操作也是不可靠的1。
监听时间变化（动态注册） class MainActivity : AppCompatActivity() { private val timeReceiver = object : BroadcastReceiver() { override fun onReceive(context: Context?, intent: Intent?) { text.text = Date(System.currentTimeMillis()).toString() } } override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) val intentFilter = IntentFilter() intentFilter.addAction(Intent.ACTION_TIME_TICK) registerReceiver(timeReceiver, intentFilter) } override fun onDestroy() { super.onDestroy() unregisterReceiver(timeReceiver) } } 开机启动（静态注册） &amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;utf-8&amp;#34;?&amp;gt; &amp;lt;manifest xmlns:android=&amp;#34;http://schemas.android.com/apk/res/android&amp;#34; package=&amp;#34;top.ntutn.broadcasttest&amp;#34;&amp;gt; &amp;lt;uses-permission android:name=&amp;#34;android.permission.RECEIVE_BOOT_COMPLETED&amp;#34; /&amp;gt; &amp;lt;application android:allowBackup=&amp;#34;true&amp;#34; android:icon=&amp;#34;@mipmap/ic_launcher&amp;#34; android:label=&amp;#34;@string/app_name&amp;#34; android:roundIcon=&amp;#34;@mipmap/ic_launcher_round&amp;#34; android:supportsRtl=&amp;#34;true&amp;#34; android:theme=&amp;#34;@style/Theme.</description>
    </item>
    
    <item>
      <title>android项目开发：Fragment</title>
      <link>https://ntutn.top/posts/fragment/</link>
      <pubDate>Mon, 21 Dec 2020 03:11:37 +0800</pubDate>
      
      <guid>https://ntutn.top/posts/fragment/</guid>
      <description>Fragment Fragment的使用方式 静态添加Fragment Fragment的写法
&amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;utf-8&amp;#34;?&amp;gt; &amp;lt;LinearLayout xmlns:android=&amp;#34;http://schemas.android.com/apk/res/android&amp;#34; android:orientation=&amp;#34;vertical&amp;#34; android:layout_width=&amp;#34;match_parent&amp;#34; android:layout_height=&amp;#34;match_parent&amp;#34;&amp;gt; &amp;lt;Button android:id=&amp;#34;@+id/button&amp;#34; android:layout_width=&amp;#34;wrap_content&amp;#34; android:layout_height=&amp;#34;wrap_content&amp;#34; android:text=&amp;#34;button&amp;#34; android:layout_gravity=&amp;#34;center_horizontal&amp;#34;/&amp;gt; &amp;lt;/LinearLayout&amp;gt; package top.ntutn.fragmenttest import android.os.Bundle import android.view.LayoutInflater import android.view.View import android.view.ViewGroup import androidx.fragment.app.Fragment class LeftFragment : Fragment() { override fun onCreateView( inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle? ): View? { return inflater.inflate(R.layout.left_fragment, container, false) } } 静态添加Fragment
&amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;utf-8&amp;#34;?&amp;gt; &amp;lt;LinearLayout xmlns:android=&amp;#34;http://schemas.android.com/apk/res/android&amp;#34; xmlns:tools=&amp;#34;http://schemas.android.com/tools&amp;#34; android:layout_width=&amp;#34;match_parent&amp;#34; android:layout_height=&amp;#34;match_parent&amp;#34; android:orientation=&amp;#34;horizontal&amp;#34; tools:context=&amp;#34;.MainActivity&amp;#34;&amp;gt; &amp;lt;fragment android:id=&amp;#34;@+id/leftFragment&amp;#34; android:name=&amp;#34;top.ntutn.fragmenttest.LeftFragment&amp;#34; android:layout_width=&amp;#34;0dp&amp;#34; android:layout_height=&amp;#34;match_parent&amp;#34; android:layout_weight=&amp;#34;1&amp;#34;/&amp;gt; &amp;lt;fragment android:id=&amp;#34;@+id/rightFragment&amp;#34; android:name=&amp;#34;top.</description>
    </item>
    
    <item>
      <title>android项目开发：UI设计</title>
      <link>https://ntutn.top/posts/ui%E8%AE%BE%E8%AE%A1/</link>
      <pubDate>Mon, 21 Dec 2020 03:11:37 +0800</pubDate>
      
      <guid>https://ntutn.top/posts/ui%E8%AE%BE%E8%AE%A1/</guid>
      <description>仍然是《第一行代码》的学习笔记，这里记录的东西相对少一点，UI上的东西还是更多在实际项目中感受到。比如我想没有必要写TextView的介绍吧。
控件的使用方法 dp是一种屏幕密度无关的尺寸单位，可以保证在不同分辨率的手机上显示效果尽可能一致。
match_parent表示让当前控件大小和父布局的大小一致。
wrap_content表示让当前控件的大小能正好包裹里面的内容。
android:gravity指定控件内的内容对齐方式，有top、bottom、start、end、center等可选，可以用|指定多个值。比如center等价于center_vertical|center_horizonal。
基本布局 LinearLayout 线性布局，通过android:orientation指定方向。
有一个重要属性：android:layout_weight，它将控件已经占用的空间减掉后按照比重分给各个控件。一般我们直接指定android:layout_width为0dp，而给它指定一个比重，这样控件的尺寸将占满剩余空间。
RelativeLayout 相对布局，复杂，但有迹可循。
&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;utf-8&amp;quot;?&amp;gt; &amp;lt;RelativeLayout xmlns:android=&amp;quot;http://schemas.android.com/apk/res/android&amp;quot; xmlns:tools=&amp;quot;http://schemas.android.com/tools&amp;quot; android:layout_width=&amp;quot;match_parent&amp;quot; android:layout_height=&amp;quot;match_parent&amp;quot; tools:context=&amp;quot;.MainActivity&amp;quot;&amp;gt; &amp;lt;Button android:id=&amp;quot;@+id/button1&amp;quot; android:layout_width=&amp;quot;wrap_content&amp;quot; android:layout_height=&amp;quot;wrap_content&amp;quot; android:layout_alignParentLeft=&amp;quot;true&amp;quot; android:layout_alignParentTop=&amp;quot;true&amp;quot; android:text=&amp;quot;Button1&amp;quot; /&amp;gt; &amp;lt;Button android:id=&amp;quot;@+id/button2&amp;quot; android:layout_width=&amp;quot;wrap_content&amp;quot; android:layout_height=&amp;quot;wrap_content&amp;quot; android:layout_alignParentTop=&amp;quot;true&amp;quot; android:layout_alignParentRight=&amp;quot;true&amp;quot; android:text=&amp;quot;Button2&amp;quot; /&amp;gt; &amp;lt;Button android:id=&amp;quot;@+id/button3&amp;quot; android:layout_width=&amp;quot;wrap_content&amp;quot; android:layout_height=&amp;quot;wrap_content&amp;quot; android:layout_centerInParent=&amp;quot;true&amp;quot; android:text=&amp;quot;Button3&amp;quot; /&amp;gt; &amp;lt;Button android:id=&amp;quot;@+id/button4&amp;quot; android:layout_width=&amp;quot;wrap_content&amp;quot; android:layout_height=&amp;quot;wrap_content&amp;quot; android:layout_alignParentLeft=&amp;quot;true&amp;quot; android:layout_alignParentBottom=&amp;quot;true&amp;quot; android:text=&amp;quot;Button4&amp;quot; /&amp;gt; &amp;lt;Button android:id=&amp;quot;@+id/button5&amp;quot; android:layout_width=&amp;quot;wrap_content&amp;quot; android:layout_height=&amp;quot;wrap_content&amp;quot; android:layout_alignParentRight=&amp;quot;true&amp;quot; android:layout_alignParentBottom=&amp;quot;true&amp;quot; android:text=&amp;quot;Button5&amp;quot; /&amp;gt; &amp;lt;/RelativeLayout&amp;gt; 以上这段布局文件描述的就是一个相对布局，共有5个按钮，分别在父布局的左上、右上、中间、左下、右下位置。
相对布局不仅可以相对于父布局，也可以相对于控件。以下描述了button3在中间，左上button1，右上button2，左下button4，右下button5的布局场景。
&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;utf-8&amp;quot;?&amp;gt; &amp;lt;RelativeLayout xmlns:android=&amp;quot;http://schemas.android.com/apk/res/android&amp;quot; xmlns:tools=&amp;quot;http://schemas.android.com/tools&amp;quot; android:layout_width=&amp;quot;match_parent&amp;quot; android:layout_height=&amp;quot;match_parent&amp;quot; tools:context=&amp;quot;.</description>
    </item>
    
    <item>
      <title>android项目开发：Activity</title>
      <link>https://ntutn.top/posts/activity/</link>
      <pubDate>Tue, 15 Dec 2020 03:11:37 +0800</pubDate>
      
      <guid>https://ntutn.top/posts/activity/</guid>
      <description>title: android项目开发：Activity author: 归零幻想 publishDate: 2020-12-15 editDate: 2020-12-15 tags: [android, 第一行代码, Kotlin, Activity]
 仍然是《第一行代码》的读书笔记，可能引用原书的定义和描述，或代码案例。
 Activity Activity基本用法 Android讲究设计逻辑与视图分离，一般Activity都会对应一个布局文件（XML文件）。
所有的Activity都要在AndroidManifest中注册才生效。
Activity可以创建菜单。首先在res/menu下创建一个xml文件（Android Studio中也提供了可视化编辑的方法）：
&amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;utf-8&amp;#34;?&amp;gt; &amp;lt;menu xmlns:app=&amp;#34;http://schemas.android.com/apk/res-auto&amp;#34; xmlns:android=&amp;#34;http://schemas.android.com/apk/res/android&amp;#34;&amp;gt; &amp;lt;item android:id=&amp;#34;@+id/add_item&amp;#34; android:title=&amp;#34;Add&amp;#34;/&amp;gt; &amp;lt;item android:id=&amp;#34;@+id/remove_item&amp;#34; android:title=&amp;#34;Remove&amp;#34;/&amp;gt; &amp;lt;/menu&amp;gt; 重写两个方法
override fun onCreateOptionsMenu(menu: Menu?): Boolean { menuInflater.inflate(R.menu.main, menu) return true } override fun onOptionsItemSelected(item: MenuItem): Boolean { when (item.itemId) { R.id.add_item -&amp;gt; Toast.makeText(this, &amp;#34;Add a book.&amp;#34;, Toast.LENGTH_LONG).show() R.id.remove_item -&amp;gt; Toast.makeText(this, &amp;#34;Remove a book.&amp;#34;, Toast.LENGTH_LONG).show() } return true } 用finish()方法可以关闭一个Activity。</description>
    </item>
    
    <item>
      <title>写产品和写demo的区别</title>
      <link>https://ntutn.top/posts/%E5%86%99%E4%BA%A7%E5%93%81%E5%92%8C%E5%86%99demo%E7%9A%84%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Tue, 15 Dec 2020 03:11:37 +0800</pubDate>
      
      <guid>https://ntutn.top/posts/%E5%86%99%E4%BA%A7%E5%93%81%E5%92%8C%E5%86%99demo%E7%9A%84%E5%8C%BA%E5%88%AB/</guid>
      <description>上次写的功能灰度报了几例crash，定位是我这里某个变量NPE了。
说实话，在Java中NPE是我们最常打交道的异常了，但Kotlin提供的类型机制下，NPE很少了。而这里出现NPE，其实是因为我认定在当前这个流程中这个变量不会为空——你总是要先弹出菜单再点击菜单项吧，所以用了data!!.id的方式使用。
这个变量被赋值的地方只有三处，不存在多线程问题，我想破脑袋也不知道哪里为空了。最后处理只得暂时加上判空，先不崩再说。
请教同事，同事说我这是还没有分清 写产品和写demo的区别 。
写产品和写demo的区别？仔细一想，的确有道理。『写demo』只要能跑通就行了，而写产品你是要为自己写的每一行代码负责的。我之前写过不少代码，但他们大概都算『写demo』。作业只要演示的时候不崩就行了，考试只要通过样例就行了，练手的项目写起来更是随心，反正自己就是用户，啥时候崩了啥时候debug，方便的很……
但『写产品』不同，你的程序不止要能完成需要的功能，还要在用户不按套路出牌的时候不出错。今天你迟到一分钟，咱班四十个学生等你一分钟就是一节课，你浪费了大家一节课时间…… 虽然这么算不对，但也不能算全错。你的产品面向千千万万用户，任何小瑕疵都可能放大成一场事故。记得那个著名的ATM机的bug，就是因为用户选择了取消，然后插入了银行卡……
回到我这个Issue，虽然从业务逻辑的角度看用户操作后这个变量是不会为null的，但仍然应该有判空，有兜底的逻辑，这样你的程序才会更加健壮。
Kotlin的空安全 与Java不同，Kotlin的类型系统在设计时就考虑了变量是否可空1，其用一个?表示变量是否能为空。
var a: String = &amp;#34;abc&amp;#34; // 默认情况下，常规初始化意味着非空 a = null // 编译错误 var b: String? = &amp;#34;abc&amp;#34; // 可以设置为空 b = null // ok print(b) 判空 Kotlin有一定的类型推断能力，判空后进行赋值操作前能识别出变量是非空的类型。
val b: String? = &amp;#34;Kotlin&amp;#34; if (b != null &amp;amp;&amp;amp; b.length &amp;gt; 0) { print(&amp;#34;String of length ${b.length}&amp;#34;) } else { print(&amp;#34;Empty string&amp;#34;) } 安全调用 Kotlin中提供了?.来安全调用一个可能为空的变量。b?.test()相当于if (b != null) b.test()。
值得注意的是，这个操作符是可以和赋值语句一起用的。如：</description>
    </item>
    
    <item>
      <title>android项目开发：项目结构</title>
      <link>https://ntutn.top/posts/%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84/</link>
      <pubDate>Tue, 08 Dec 2020 03:11:37 +0800</pubDate>
      
      <guid>https://ntutn.top/posts/%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84/</guid>
      <description>虽然已经在字节实习并拿到转正offer，但实际我自己感受我现在对安卓基础知识掌握的程度还差很多，感觉写业务代码本身并不能带来多少提升。
恰逢前两天看到黄正楠那里有一本看上去不错的书1，而在淘宝也在打折，就买了一本。
那么从Hello Wrold开始，先看看安卓项目的项目结构。
[TOC]
.gradle和.idea Android Studio自动生成的文件，无需关心。
app 项目中的代码、资源等内容。
build 编译时自动生成的文件，不需要关心。
libs 存放项目中的第三方jar包，这个目录下的jar包会自动添加到项目的构建路径下。
src androidTest Android Test测试用例，可以对项目进行一些自动化测试。
 实际上在公司里发现基本不写测试用例，全靠QA瞎几把点。
 test 用来编写单元测试用例，对项目进行自动化测试。
 这里的测试用例是不依赖安卓框架的。
 main java 存放所有java代码（和Kotlin代码）的地方。
res 项目的资源文件夹，项目中使用到的所有图片、布局、字符串等资源都存在这个目录下。
图片存放在drawable目录下，布局存放在layout目录下，字符串存放在values目录下。
mipmap存放图标，之所以有很多mipmap目录是为了适配各种设备。若只有一份图片，那么放在xxhdpi下就可以了。
AndroidManifest.xml 整个Android项目的配置文件，程序中定义的四大组件都需要在这个文件中注册。此外，还可以在这个文件中添加应用程序的权限声明。
.gitignore 类似外层的.gitignore，用来在版本控制系统中排除app模块中的指定文件。
build.gradle app模块的gradle构建脚本，指定很多项目构建相关的配置。
插件com.android.application用于应用程序模块，com.android.library表示库模块。前者可以直接运行，后者只能作为代码库依附于应用程序模块运行。
proguard-rules.pro 指定项目代码的混淆方式。
build 编译时自动生成的内容。
gradle gradle wrapper的配置文件。Android Studio会根据本地的缓存i去=情况决定是否需要联网下载gradle。
.gitignore 排除文件或文件夹的git版本控制。
 对于所有项目都会用到的.gitignore条目，不妨加入~/.gitignore全局配置。
 build.gradle 项目全局的构建脚本。
repositories中，google()对应谷歌自家代码仓库依赖，jcenter()中则是很多第三方开源库。
gradle.properties 全局gradle的配置文件。
gradlew和gradlew.bat 这两个文件是用来在命令行界面执行gradle命令的，其中gradlew是在Linux或Mac系统中使用的，gradlew.bat是在Windows系统中使用的。
local.properties 用于指定本机中的Android SDK路径。
settings.gradle 用来指定项目中所有引入的模块。
  《第一行代码》 &amp;#x21a9;&amp;#xfe0e;
   </description>
    </item>
    
    <item>
      <title>B站的搬运机制和盗视频行为有区别吗</title>
      <link>https://ntutn.top/posts/b%E7%AB%99%E7%9A%84%E6%90%AC%E8%BF%90%E6%9C%BA%E5%88%B6%E5%92%8C%E7%9B%97%E8%A7%86%E9%A2%91%E8%A1%8C%E4%B8%BA%E6%9C%89%E5%8C%BA%E5%88%AB%E5%90%97/</link>
      <pubDate>Tue, 24 Nov 2020 03:11:37 +0800</pubDate>
      
      <guid>https://ntutn.top/posts/b%E7%AB%99%E7%9A%84%E6%90%AC%E8%BF%90%E6%9C%BA%E5%88%B6%E5%92%8C%E7%9B%97%E8%A7%86%E9%A2%91%E8%A1%8C%E4%B8%BA%E6%9C%89%E5%8C%BA%E5%88%AB%E5%90%97/</guid>
      <description>在知乎看到这样的问题1，写下我的观点，也同步写到这里。
 『搬运』同『转载』，『盗视频』特指『无授权转载视频』并隐含指『借此获得收益』。
  b站用户被指责双标， 最大的锅是b站而不是up主 。
b站没有明显区分转载作品和原创作品，在我看来就是享受了转载内容带来的红利又想规避因此带来的舆论和法律问题。
 如何判断视频是转载的还是原创的？你看这里它只能投一个币这是搬运的。
 收益  『搬运』视频是不能获得收益的。 很大程度这与是否获得授权无关，甚至与界定是否『商业使用』无关。up主没有获得收益，但显而易见b站是有收益的。比如一篇文章，转载到我的个人博客大概可以算非商业使用，因为博客中 没有任何广告，没有打赏或捐赠选项，没有对任何产品的商业宣传。
 当然这一点不是up主的锅，但至少 请收起『搬运是给你免费做宣传』的说辞。
授权问题 『转载』行为是应当获取授权的，退一步讲至少是应当标明出处的。b站自己产生的内容默认会标注『禁止转载』，但大多网站不会有明显标注，所以给转载者留下余地，有人认为未标注默认应该是允许转载。在我看来这一点是不成立的，至少 在github，如果一个项目没有任何LICENSE说明和文件，应该被理解为保留授权 ，即使大多数情况只是作者忘了。
标注出处 转载应标注出处，如何才算『标注出处』呢？很多视频中一句『来自Youtube』就算标注了出处了，标题还是翻译后的，你根据这句话能找到来源？
即使标注了出处，基本上也只能写在视频的简介中。很多人不习惯看视频简介，尤其是b站还会默认折叠比较长的简介。 还是b站的锅
我认为，合适的转载应该明显标出作品来源，并 至少要提供出足以找到来源作品的信息 。书籍杂志没办法，但对于互联网的文章，提供来源链接才算诚意。当然有些平台带超链接会无法过审，那可以再做权衡。
倡议   对于内容创作者，顺手标注是否允许转载，比如我在自己博客标注了『在未另行说明的情况下，本站内容遵守 署名-相同方式共享 4.0 国际 (CC BY-SA 4.0)』 ，这样非商业转载就无须另外询问我的意见了。
  对于转载内容的人，建议在来源未写明是否授权转载的情况下，主动向原作者申请授权。知乎曾经流行过『来自网络，侵删』式的标注，虽然也表达了态度，但实际上并不能规避因此带来的侵权法律风险。能找到作者情况下，申请授权才是正理。
  对于用户，自觉抵制不标注出处甚至不标注『转载』的转载内容。
    B站的搬运机制和盗视频行为有区别吗？ - 知乎 &amp;#x21a9;&amp;#xfe0e;
   </description>
    </item>
    
    <item>
      <title>android项目开发：多线程编程</title>
      <link>https://ntutn.top/posts/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/</link>
      <pubDate>Fri, 21 Aug 2020 03:11:37 +0800</pubDate>
      
      <guid>https://ntutn.top/posts/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/</guid>
      <description>仍然是《第一行代码》的笔记，不过略过了deprated的内容，并探究了下Handler的工作机制。
 上班了，果然没有那么多大块时间写博客了。
 Handler 主线程不能进行耗时处理，子线程不能访问UI，所以我们需要异步消息处理机制。
使用 class MainActivity : AppCompatActivity() { private lateinit var binding: ActivityMainBinding private val handler = object : Handler(Looper.getMainLooper()) { override fun handleMessage(msg: Message) { when(msg.what){ MSG_UPDATE_TEXT -&amp;gt; binding.textView.text = &amp;#34;Nice to meet you. &amp;#34; } } } override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) binding = ActivityMainBinding.inflate(layoutInflater) setContentView(binding.root) initView() } private fun initView() { binding.apply { changeTextButton.setOnClickListener { thread { val msg = Message() msg.what = MSG_UPDATE_TEXT handler.</description>
    </item>
    
    <item>
      <title>EventBus初探</title>
      <link>https://ntutn.top/posts/eventbus%E5%88%9D%E6%8E%A2/</link>
      <pubDate>Fri, 21 Aug 2020 03:11:37 +0800</pubDate>
      
      <guid>https://ntutn.top/posts/eventbus%E5%88%9D%E6%8E%A2/</guid>
      <description>公司项目中大量运用了EventBus1，这两天在做的需求相关的代码也用到了，于是还是要先去研究下这个EventBus是什么。
EventBus，顾名思义，事件总线，是一个安卓上的事件管理平台。用事件驱动的机制来简化事件传递的逻辑。在这层意义上也许可以类比Qt的信号槽机制，或者安卓的广播。当你需要把一个事件传递给多个对象，EventBus就变得非常有用。
该图片来自EventBus的github仓库
EventBus的使用 首先当然是添加依赖
implementation &amp;#39;org.greenrobot:eventbus:3.2.0&amp;#39; 写个demo展示下：
点击按钮后，将两处文本的值修改为文本框中的值。注意：上面的那个红色的文本处于一个fragment中。
为此，我们先准备一个Event：
data class ButtonEvent(val text: String) 点击按钮时，发送这个Event：
button.setOnClickListener { EventBus.getDefault().post(ButtonEvent(editTextTextPersonName.text.toString())) } 然后在需要接收这个请求的地方，比如我们在MainActivity的onCreate()中注册EventBus：
EventBus.getDefault().register(this) 在onDestory()中解除
EventBus.getDefault().unregister(this) 然后就可以接收那个Event了。
@Subscribe fun onButtonEvent(buttonEvent: ButtonEvent){ textView.text=buttonEvent.text } 同样对于Fragment，我们只需要做同样的事情，就可以监听这个Event了。很明显，这对于一个事件有多个处理的场景是很方便的。
订阅者的threadMode 安卓应用启动时，系统会创建一个主线程，负责向UI组件分发事件2，所有对UI的操作应该放到主线程中。EventBus是一种重要的跨线程更新UI的方式。3
@Subscribe注解有一个参数threadMode，有以下取值：
ThreadMode.POSTING 默认值，在同一线程中调用，开销最小。
ThreadMode.MAIN 在主线程中调用。
 如果发送事件的是主线程，则直接调用。
 ThreadMode.MAIN_ORDERED 在主线程中调用，同步调用（排队）。
ThreadMode.BACKGROUND 在后台线程中调用。
ThreadMode.ASYNC 在单独线程中调用，用于耗时操作。
对于EventBus更新UI，我同样写了demo：
package com.example.eventbustimerdemo import android.os.Bundle import androidx.appcompat.app.AppCompatActivity import kotlinx.android.synthetic.main.activity_main.* import org.greenrobot.eventbus.EventBus import org.greenrobot.eventbus.Subscribe import org.greenrobot.eventbus.ThreadMode class MainActivity : AppCompatActivity() { override fun onCreate(savedInstanceState: Bundle?</description>
    </item>
    
    <item>
      <title>Typora&#43;git自动同步你的笔记</title>
      <link>https://ntutn.top/posts/typora&#43;git%E8%87%AA%E5%8A%A8%E5%90%8C%E6%AD%A5%E4%BD%A0%E7%9A%84%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Mon, 02 Mar 2020 03:11:37 +0800</pubDate>
      
      <guid>https://ntutn.top/posts/typora&#43;git%E8%87%AA%E5%8A%A8%E5%90%8C%E6%AD%A5%E4%BD%A0%E7%9A%84%E7%AC%94%E8%AE%B0/</guid>
      <description>这两天看了群里某个大佬的笔记，突然觉得自己用VSCode记笔记的方案不香了。VSCode虽然对markdown的支持不错，但毕竟本职工作不是这个，直接拿来做笔记还是不够方便，太笨重了。于是我终于想起之前同学给我安利的markdown编辑器：Typora。
dalao的笔记 首先看看大佬的笔记：
好想去偷他的笔记。不过话说他这笔记软件也不错啊，看起来简约清晰，我也有试一试的想法了。
他用的笔记软件：https://github.com/tsujan/FeatherNotes
然后就被编译安装劝退了。一个是不太想这么折腾，另一个是这个软件没有提供编译好的包，感觉还是不够放心啊，毕竟如果以后开发者不维护了要再折腾一遍会非常麻烦。
Typora，同学安利的markdown编辑工具 与多数markdown编辑工具不同，Typora是所见即所得的markdown编辑工具。为什么程序员偏爱markdown？就是因为markdown可以让我们写作的时候只关注内容本身，而不用太在意排版的问题。而Typora又改变了传统的左右分栏或者点击切换预览的传统markdown编辑模式，用起来就更舒服了。
安装 在Ubuntu下安装还是非常方便的：
# or run: # sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys BA300B7755AFCFAE wget -qO - https://typora.io/linux/public-key.asc | sudo apt-key add - # add Typora&amp;#39;s repository sudo add-apt-repository &amp;#39;deb https://typora.io/linux ./&amp;#39; sudo apt-get update # install typora sudo apt-get install typora 其他系统参考官网。
复制图片 不过有一点要注意：我们写文档常常要插入一些图片，为了后面和git好配合，我们需要将这些图片也放到当前文件夹里。按下Ctrl+逗号打开设置，将图片复制到当前文件夹下。如图。
重要的快捷键 都是重点等于没有重点。我们只要记住能让我们离开鼠标提高效率的就行了。
   快捷键 功能     Ctrl+S 保存   Ctrl+Z 撤销   Ctrl+Y 重做   Ctrl+Shift+L 侧边栏   Ctrl+/ 切换源代码模式   表格中，Ctrl+Enter 添加一行    用git管理笔记 首先什么是git？有些少年区分不了git和github，这是姿势水平还不够啊。听说过GitLab没？听说过码云没？不是修福报的那个马云哦。</description>
    </item>
    
    <item>
      <title>Java自动装箱自动拆箱踩坑</title>
      <link>https://ntutn.top/posts/java%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1%E8%87%AA%E5%8A%A8%E6%8B%86%E7%AE%B1%E8%B8%A9%E5%9D%91/</link>
      <pubDate>Sun, 01 Mar 2020 03:11:37 +0800</pubDate>
      
      <guid>https://ntutn.top/posts/java%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1%E8%87%AA%E5%8A%A8%E6%8B%86%E7%AE%B1%E8%B8%A9%E5%9D%91/</guid>
      <description>int和Integer有什么区别？前者是基础数据类型，后者是封装的Java对象。但在有Autoboxing和Unboxing的情况下我们常常就把两者等同看待，无非后者能放null。
事情要首先从一道力扣题目说起：
删除排序数组中的重复项 II 给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素最多出现两次，返回移除后数组的新长度。
不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。
示例 1: 给定 nums = [1,1,1,2,2,3], 函数应返回新长度 length = 5, 并且原数组的前五个元素被修改为 1, 1, 2, 2, 3 。 你不需要考虑数组中超出新长度后面的元素。 示例 2: 给定 nums = [0,0,1,1,1,1,2,3,3], 函数应返回新长度 length = 7, 并且原数组的前五个元素被修改为 0, 0, 1, 1, 2, 3, 3 。 你不需要考虑数组中超出新长度后面的元素。
Answer 针对这个题目，我写出了这样的代码：
/* * @lc app=leetcode.cn id=80 lang=java * * [80] 删除排序数组中的重复项 II */ // @lc code=start class Solution { public int removeDuplicates(int[] nums) { int l = 0, r = 0; int ans1 = Integer.</description>
    </item>
    
    <item>
      <title>三门问题</title>
      <link>https://ntutn.top/posts/%E4%B8%89%E9%97%A8%E9%97%AE%E9%A2%98/</link>
      <pubDate>Mon, 16 Sep 2019 03:11:37 +0800</pubDate>
      
      <guid>https://ntutn.top/posts/%E4%B8%89%E9%97%A8%E9%97%AE%E9%A2%98/</guid>
      <description>参赛者面前有三扇关闭着的门，其中一扇的后面是一辆汽车，选中后面有车的那扇门就可以赢得该汽车， 而另外两扇门后面则各藏有一只山羊。当参赛者选定了一扇门，但未去开启它的时候，主持人会开启剩 下两扇门中的一扇，露出其中一只山羊。主持人其后会问参赛者要不要更换选择，选另一扇仍然关着的门。
 那么，应不应该更换呢？   分析 假如你选择了A，那你中奖概率应为1/3.
主持人在B、C中选了个没奖的，这与你的选择其实没影响，因为你没选的肯定有个没奖的。
换与不换其实就相当于问你选A还是不选A。
程序模拟 有点绕，咱学软件的，就干脆让电脑跑一跑。
代码 import java.util.Random; class Test{ public static void main(String[] args) { Random ran=new Random(); int c1=0,c2=0; for(int i=0;i&amp;lt;1e6;i++){ boolean boxes[]={false,false,false}; boxes[ran.nextInt(boxes.length)]=true;//某个门后有奖  int sel=ran.nextInt(boxes.length);//随便选择一扇门  int p=0; while(p==sel||boxes[p]){//主持人选择一扇没奖的门（且不与参与者选同一扇）  p=ran.nextInt(boxes.length); } if(boxes[sel]){//不更换中奖  c1++; } if(boxes[0+1+2-sel-p]){//更换中奖  c2++; } } System.out.println(c1/1e6); System.out.println(c2/1e6); } } 运行结果 0.332419 0.667581 看来是更换比较好了。</description>
    </item>
    
    <item>
      <title>在Windows10上安装血战上海滩</title>
      <link>https://ntutn.top/posts/%E5%9C%A8windows10%E4%B8%8A%E5%AE%89%E8%A3%85%E8%A1%80%E6%88%98%E4%B8%8A%E6%B5%B7%E6%BB%A9/</link>
      <pubDate>Sat, 01 Jun 2019 03:11:37 +0800</pubDate>
      
      <guid>https://ntutn.top/posts/%E5%9C%A8windows10%E4%B8%8A%E5%AE%89%E8%A3%85%E8%A1%80%E6%88%98%E4%B8%8A%E6%B5%B7%E6%BB%A9/</guid>
      <description>《血战上海滩》是由北京欢乐亿派科技有限公司开发的单机FPS游戏，发行于2003年，是一个非常经典的老游戏了。 近来我打算把这个游戏找出来再玩一遍，可是在Windows10上安装还是有些问题……
下载 下载不用多说，自己找资源吧，一共三百多兆的单机游戏。
 现在很多单机游戏下载时网站都会给你带上一个“启动器”来显示广告，恶心的很。找到文件夹中，注意血战上海滩的游戏文件是一个帽子的图标，大小为1.87M，SHA1为FE5A102AA9DE633FB6E388EAAEEA38BC43E8E7E4
 启动 直接双击exe，然后……它免费帮你调了一下分辨率，就没反应了。
貌似兼容性是个比较大的问题……于是在网上找了好久，终于知道，可以用命令行控制游戏窗口运行：
shanghai.exe -windows 修改屏幕分辨率实现全屏 倒是能运行了，只是……画面都在左上角，没法玩啊……
所以再加上自动修改屏幕分辨率就可以全屏了。修改屏幕分辨率可以用setres
下载链接下载并将exe文件放到血战上海滩的游戏文件夹。
于是用下面的命令：
setres h800 v600 shanghai.exe -windows setres h1920 v1080 1920*1080是我电脑的屏幕分辨率，注意换成自己的。
隐藏显示任务栏 然而，这样还是有问题，就是这样“全屏”后任务栏并没有消失，虽然可以设置自动隐藏任务栏但总归还是不爽，于是写了个简单C#程序在启动游戏隐藏任务栏（虽然很简单，但没找到只用命令实现的方法）
using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; using System.Runtime.InteropServices; namespace ShowTaskBar { class Program { private const int SW_HIDE = 0; //隐藏任务栏  private const int SW_RESTORE = 9;//显示任务栏 [DllImport(&amp;#34;user32.dll&amp;#34;)] public static extern int ShowWindow(int hwnd, int nCmdShow); [DllImport(&amp;#34;user32.dll&amp;#34;)] public static extern int FindWindow(string lpClassName, string lpWindowName); static void Main(string[] args) { ShowWindow(FindWindow(&amp;#34;Shell_TrayWnd&amp;#34;, null), SW_HIDE); } } } using System; using System.</description>
    </item>
    
    <item>
      <title>二叉树ADT的实现</title>
      <link>https://ntutn.top/posts/%E4%BA%8C%E5%8F%89%E6%A0%91adt%E7%9A%84%E5%AE%9E%E7%8E%B0/</link>
      <pubDate>Tue, 14 May 2019 03:11:37 +0800</pubDate>
      
      <guid>https://ntutn.top/posts/%E4%BA%8C%E5%8F%89%E6%A0%91adt%E7%9A%84%E5%AE%9E%E7%8E%B0/</guid>
      <description>人工智能知识点整理Question
假设二叉数的数据元素为字符，采用二叉链式存储结构。请编码实现二叉树ADT，其中包括创建二叉树、遍历二叉树（深度、广度）、求二叉树的深度（高度）、计算二叉树的元素个数、计算二叉树的叶子数、二叉树的格式输出等。
根据输入的符号，执行相应的操作。如下：
 C：根据完全前序序列创建二叉树，#表示空结点（空子树）；输入：二叉树的完全前序序列，创建成功输出 Created success! H：求二叉树的高度； 输出： Height=高度 L：计算二叉树的叶子数；输出：Leaves=叶子个数 N：计算二叉树中元素总个数；输出：Nodes=结点个数 1：先序遍历二叉树；输出：Preorder is:序列 . 2：中序遍历二叉树；输出：Inorder is:序列 . 3：后序遍历二叉树；输出：Postorder is:序列 . 4：广度遍历二叉树；输出：BFSorder is:序列 . F：查找值为x的结点个数；输出：The count of x is 个数 . P：以目录缩格文本形式输出所有节点。输出：The tree is:（换行，下面各行是输出的二叉树） X：退出  Example Input C ABC##DE#G##F### H L N 1 2 3 4 F A P X Output Created success! Height=5 Leaves=3 Nodes=7 Preorder is:A B C D E G F . Inorder is:C B E G D F A .</description>
    </item>
    
    <item>
      <title>图书管理系统</title>
      <link>https://ntutn.top/posts/%E5%9B%BE%E4%B9%A6%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/</link>
      <pubDate>Sat, 13 Apr 2019 03:11:37 +0800</pubDate>
      
      <guid>https://ntutn.top/posts/%E5%9B%BE%E4%B9%A6%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/</guid>
      <description>翻出了以前写的C++作业，图书管理系统，虽然挺简单的，但留下纪念下吧。
#include &amp;lt;iostream&amp;gt;#include&amp;lt;cstdlib&amp;gt;#include&amp;lt;cstring&amp;gt;#include&amp;lt;fstream&amp;gt;using namespace std; class CUser { private: int code; //表示用户编号；  char name[20]; //表示用户姓名 public: CUser() { ; }; // 默认构造函数  CUser(int id, char na[]) { code=id; strcpy(name,na); }; //构造函数，初始化用户信息  void setcode(int n) { code=n; }; //用来设置用户编号  int getcode() { return code; }; //用来获取用户编号  void setname(char na[]) { strcpy(name,na); }; //用来设置用户姓名  char* getname() { return name; }; //用来获取用户姓名  void show() { cout&amp;lt;&amp;lt;&amp;#34;用户编号：&amp;#34;&amp;lt;&amp;lt;code&amp;lt;&amp;lt;endl; cout&amp;lt;&amp;lt;&amp;#34;姓名：&amp;#34;&amp;lt;&amp;lt;name&amp;lt;&amp;lt;endl; }; //用来显示用户的基本信息 }; class CBook { private: int code; //图书编号  char name[20]; //图书名称  bool Is_Stock; //true为在架，false为借出  bool Is_Existing; //true为存在, false为删除 public: CBook() { ; }; //默认构造函数  CBook(int no,char na[]) { code=no; strcpy(name,na); Is_Stock=true; Is_Existing=true; }; //构造函数，初始化图书信息  void setcode(int n) { code=n; }; //设置图书编号  int getcode() { return code; }; //获取图书编号  void setname(char na[]) { strcpy(name,na); }; //设置图书名称  char* getname() { return name; }; //获取图书名称  bool get_Stock() { return Is_Stock; }; //获取图书是否在库信息  void set_Stock(bool isstock) { Is_Stock=isstock; };// 设置图书是否在库信息  bool get_Existing() { return Is_Existing; };//获取存在标志  void set_Existing(bool isex) { Is_Existing=isex; };//设置存在标志 }; class CReader:public CUser { private: bool Is_Existing; //true存在，false删除  bool Is_Borrowing; //true借过书，false没有借书  CBook brbook; //表示读者所借的图书 public: CReader() { CUser(); }; //构造函数，初始化读者信息  CReader(int id, char na[]) { CUser(id,na); }; //构造函数，初始化读者信息  bool get_Existing() { return Is_Existing; }; //用来获取删除标志  void set_Existing(bool isex) { Is_Existing=isex; }; //用来设置删除标志  bool get_Borrowing() { return Is_Borrowing; }; //用来获取读者借阅情况  void set_Borrowing(bool isbo) { Is_Borrowing=isbo; }; //用来设置读者借阅情况  void setbrbook(CBook bt) { brbook=bt; Is_Borrowing=true; }; //用来记录读者结束信息  CBook getbrbook() { return brbook; }; //用来获取读者结束信息  void show() { CUser::show(); if(Is_Borrowing) { cout&amp;lt;&amp;lt;&amp;#34;当前借书：&amp;#34;&amp;lt;&amp;lt;brbook.</description>
    </item>
    
    <item>
      <title>使用映像劫持技术屏蔽电脑中的广告进程</title>
      <link>https://ntutn.top/posts/%E4%BD%BF%E7%94%A8%E6%98%A0%E5%83%8F%E5%8A%AB%E6%8C%81%E6%8A%80%E6%9C%AF%E5%B1%8F%E8%94%BD%E7%94%B5%E8%84%91%E4%B8%AD%E7%9A%84%E5%B9%BF%E5%91%8A%E8%BF%9B%E7%A8%8B/</link>
      <pubDate>Thu, 28 Mar 2019 03:11:37 +0800</pubDate>
      
      <guid>https://ntutn.top/posts/%E4%BD%BF%E7%94%A8%E6%98%A0%E5%83%8F%E5%8A%AB%E6%8C%81%E6%8A%80%E6%9C%AF%E5%B1%8F%E8%94%BD%E7%94%B5%E8%84%91%E4%B8%AD%E7%9A%84%E5%B9%BF%E5%91%8A%E8%BF%9B%E7%A8%8B/</guid>
      <description>映像劫持（Image File Execution Options），简单的说法，就是当你打开的是程序A，而运行的确是程序B。映像劫持其实是Windows内设的用来调试程序的功能，但是现在却往往被病毒恶意利用。当用户双击对应的程序后，操作系统就会给外壳程序（例如“explorer.exe”）发布相应的指令，其中包含有执行程序的路径和文件名，然后由外壳程序来执行该程序。事实上在该过程中，Windows还会在注册表的上述路径中查询所有的映像劫持子键，如果存在和该程序名称完全相同的子键，就查询对应子健中包含的“dubugger”键值名，并用其指定的程序路径来代替原始的程序，之后执行的是遭到“劫持”的虚假程序。
 国内很多软件都有重度广告，“资讯”、“新闻”、“弹窗”，不胜其烦。直接找到广告进程删除掉，结果一自动更新，又回来了。
于是，我想到了“映像劫持”：
Windows Registry Editor Version 5.00 [HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\SLBService.exe] &amp;#34;Debugger&amp;#34;=&amp;#34;winlogon&amp;#34; [HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\TsService.exe] &amp;#34;Debugger&amp;#34;=&amp;#34;winlogon&amp;#34; [HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\FoxitDesktopAd.exe] &amp;#34;Debugger&amp;#34;=&amp;#34;winlogon&amp;#34; [HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\FoxitProtect.exe] &amp;#34;Debugger&amp;#34;=&amp;#34;winlogon&amp;#34; [HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\LCServer.exe] &amp;#34;Debugger&amp;#34;=&amp;#34;winlogon&amp;#34; [HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\LRServer.exe] &amp;#34;Debugger&amp;#34;=&amp;#34;winlogon&amp;#34; [HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\2345MiniPage.exe] &amp;#34;Debugger&amp;#34;=&amp;#34;winlogon&amp;#34; [HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\SohuNews.exe] &amp;#34;Debugger&amp;#34;=&amp;#34;winlogon&amp;#34; [HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\PinyinUp.exe] &amp;#34;Debugger&amp;#34;=&amp;#34;winlogon&amp;#34; [HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\SGDownload.</description>
    </item>
    
    <item>
      <title>人工智能知识点整理</title>
      <link>https://ntutn.top/posts/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/</link>
      <pubDate>Thu, 03 Jan 2019 03:11:37 +0800</pubDate>
      
      <guid>https://ntutn.top/posts/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/</guid>
      <description>人工智能考试前整理的，很详细，虽然实际考试还是有好些想不起来，但总归起了一些作用的。
 第1章绪论 人工智能的起源 现代人工智能的起源是1956年的达特茅斯会议。
参加者：麦卡锡、明斯基、香农、罗切斯特、纽厄尔、西蒙、萨缪尔、伯恩斯坦、摩尔、所罗门诺夫。
会议的主要成就就是让人工智能成了一个独立的研究学科。
定下来人工智能的英文名称是“Artificial Intelligence”
知识的定义、概念、基本单位 定义 柏拉图在《泰阿泰德篇》中给出知识的定义，即“被证实的、真的和被相信的陈述”，简称知识的JTB（Justified True Belief）条件。
然而，这个延续了两千多年的定义在1963年，被哲学家盖梯尔否定了。
概念 知识的基本单位就是概念。
概念的定义  概念的符号：即概念的名称，说明这个概念叫什么。 概念的内涵：即命题来表示，命题就是能判断真假的陈述句。 概念的外延：即经典集合来表示，用来说明与概念对应的事件对象是哪些。  概念的三个功能 指物功能：既指向客观世界的对象，表示客观世界的对象的可观测性，对象的客观的信仰，是指对相对于人或者仪器的知觉感知特性，依赖于人的主观感受。
指心功能：即指向人心智世界里的对象，代表心智世界里的对象表示。
指名功能：指向认知世界或者符号世界表示对象的符号名称，这些符号名称组成各种语言。
人工智能的三个流派  专注于实现AI指名功能的人工智能流派，称为符号主义。 专注于实现AI指心功能的人工智能流派，称为连接主义。 专注于实现AI指物功能的人工智能流派，称为行为主义。     概念的功能 人工智能的流派 观点 思想实验 挑战     指名功能 符号主义 指名对了，指物自然正确 图灵测试、中文屋实验 完全实现指名功能也不见得有智能。概念的组合爆炸问题；概念的组合悖论问题；经典概念在现实中很难获得。知识很难获取   指物功能 连接主义 发现大脑的结构及处理信息的机制，揭示人工智能的本质机理，进而在机器上实现响应模拟 缸中之脑实验 指心没有问题，指物也存在问题。   指心功能 行为主义 只要实现指物功能，就认为具有智能了 完美伪装者和斯巴达人 外在表现与内心没有联系，无法测试    第2章概念表示 概念定义及三个组成部分 知识由概念组成，概念是构成人类知识世界的基本单元。</description>
    </item>
    
  </channel>
</rss>
