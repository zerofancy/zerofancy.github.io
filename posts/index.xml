<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on 归零幻想</title>
    <link>https://ntutn.top/posts/</link>
    <description>Recent content in Posts on 归零幻想</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <copyright>CC BY-SA 4.0</copyright>
    <lastBuildDate>Tue, 30 Aug 2022 02:49:11 +0800</lastBuildDate><atom:link href="https://ntutn.top/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>从头开始制作一个tg机器人</title>
      <link>https://ntutn.top/posts/%E4%BB%8E%E5%A4%B4%E5%BC%80%E5%A7%8B%E5%88%B6%E4%BD%9C%E4%B8%80%E4%B8%AAtg%E6%9C%BA%E5%99%A8%E4%BA%BA/</link>
      <pubDate>Tue, 30 Aug 2022 02:49:11 +0800</pubDate>
      
      <guid>https://ntutn.top/posts/%E4%BB%8E%E5%A4%B4%E5%BC%80%E5%A7%8B%E5%88%B6%E4%BD%9C%E4%B8%80%E4%B8%AAtg%E6%9C%BA%E5%99%A8%E4%BA%BA/</guid>
      <description>工作之外，总想折腾点什么东西。最近看朋友搞的QQ摸鱼机器人有点意思，就想自己也搞一个。tg提供的API比较全面，所以就想搞个tg版。
直接贴代码：https://github.com/rfkhx/starsea
基本消息处理和分发 其实仅就这个需求而言，并没有用多线程的必要性，一个死循环中拉取消息，拉到后交给对应模块处理，处理完继续下一次循环拉下一条消息就可以了。不过为了把代码结构写得更清楚一点，并希望能在这个过程中学到点东西，我决定仿照安卓的线程机制组织，将安卓中的 Handler、Looper 移植到我的项目中，借助这个过程更深入理解整个机制。
类似安卓，我在后台线程进行网络请求，主线程进行结果的分发处理。
Message Message 就是消息对象。我对消息对象的定义如下：
data class Message( val what: Int, val arg: Int = -1, val payload: Any? = null, var time: Long = 0L, var target: Handler? = null, val callback: Runnable? = null ) 要理解整个消息机制，还是得先看这几个参数。
 what 表示这是一条什么样的消息。一个 Handler 中可能定义和处理多种不同的消息，通过这个参数进行区分。 arg、payload 表示消息携带的参数。 arg 是简单的， Int 类型的参数，而 payload 则用于传递复杂对象。按需使用 time 表示 Message 预期被处理的时间。只有到了这个时间之后消息才可以被取出处理。这对应我们经常用的 handler.postDelayed 方法 target 处理消息的 Handler callback 消息处理时执行特定回调。实际上和继承相关 Handler 并在相关方法中处理消息是等同的  MessageQueue 记得安卓中有个比较经典和基础的问题，主线程实际执行了 Looper.</description>
    </item>
    
    <item>
      <title>Retrofit源码阅读</title>
      <link>https://ntutn.top/posts/retrofit%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/</link>
      <pubDate>Thu, 09 Jun 2022 17:02:54 +0800</pubDate>
      
      <guid>https://ntutn.top/posts/retrofit%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/</guid>
      <description>Retrofit是一个相当简洁的网络请求框架，其本质上只是对Okhttp的封装，实际上底层还是用Okhttp来执行网络请求。这两天终于比较闲一些，于是又想起了被我束之高阁的前辈的武功秘籍。
Retrofit的使用 参考官方例子，定义接口并使用
public interface GitHub { @GET(&amp;#34;/repos/{owner}/{repo}/contributors&amp;#34;) Call&amp;lt;List&amp;lt;Contributor&amp;gt;&amp;gt; contributors(@Path(&amp;#34;owner&amp;#34;) String owner, @Path(&amp;#34;repo&amp;#34;) String repo); } // Create a very simple REST adapter which points the GitHub API.  Retrofit retrofit = new Retrofit.Builder() .baseUrl(API_URL) .addConverterFactory(GsonConverterFactory.create()) .build(); // Create an instance of our GitHub API interface.  GitHub github = retrofit.create(GitHub.class); // Create a call instance for looking up Retrofit contributors.  Call&amp;lt;List&amp;lt;Contributor&amp;gt;&amp;gt; call = github.contributors(&amp;#34;square&amp;#34;, &amp;#34;retrofit&amp;#34;); // Fetch and print a list of the contributors to the library.</description>
    </item>
    
    <item>
      <title>使用自动操作修改壁纸</title>
      <link>https://ntutn.top/posts/%E4%BD%BF%E7%94%A8%E8%87%AA%E5%8A%A8%E6%93%8D%E4%BD%9C%E4%BF%AE%E6%94%B9%E5%A3%81%E7%BA%B8/</link>
      <pubDate>Mon, 06 Jun 2022 12:28:23 +0800</pubDate>
      
      <guid>https://ntutn.top/posts/%E4%BD%BF%E7%94%A8%E8%87%AA%E5%8A%A8%E6%93%8D%E4%BD%9C%E4%BF%AE%E6%94%B9%E5%A3%81%E7%BA%B8/</guid>
      <description>好久没水博客了，今天折腾折腾一个一直在系统里但是没用过的工具：自动操作（Automator）.
首先打开自动操作，新建一个文稿。选择“应用程序”最终可以像其他app一样，点击就执行。但我希望的是每天自动更换，所以这里我选择“日历提醒”。
下载壁纸 “自动操作”的使用方法还是很简单的，把左边的命令拖动过来稍加编辑就可以了。所以，我们得到了
这里用的是Unsplash提供的随机壁纸服务，壁纸还是很合我的胃口的。图中URL：https://source.unsplash.com/random/3584x2240。这里的“3584x2240”根据你的显示器分辨率填写。
设置壁纸 虽然“自动操作”的资源库中有“设置壁纸”这个能力，但我实际测试发现它只能改当前屏幕的壁纸，对于我用双屏的来说就比较难受了。因而这里要用Apple Script来实现：
图中的脚本为：
on run {input, parameters} set theFile to first item of input set filename to the POSIX path of theFile tell application &amp;quot;System Events&amp;quot; tell every desktop set picture to filename end tell end tell return filename end run 清理垃圾 这个简单，删除所有不是今天创建的图片就行了。
每天执行 保存后，打开日程应用，可以看到出现了一条刚刚添加的日程。使用Command+E快捷键修改日程，“重复”改为每天。最终结果：
 最后效果
摸鱼结束，我去搬砖了。</description>
    </item>
    
    <item>
      <title>把你的光猫变成一个丐版nas</title>
      <link>https://ntutn.top/posts/%E6%8A%8A%E4%BD%A0%E7%9A%84%E5%85%89%E7%8C%AB%E5%8F%98%E6%88%90%E4%B8%80%E4%B8%AA%E4%B8%90%E7%89%88nas/</link>
      <pubDate>Tue, 12 Apr 2022 01:21:54 +0800</pubDate>
      
      <guid>https://ntutn.top/posts/%E6%8A%8A%E4%BD%A0%E7%9A%84%E5%85%89%E7%8C%AB%E5%8F%98%E6%88%90%E4%B8%80%E4%B8%AA%E4%B8%90%E7%89%88nas/</guid>
      <description>把你的光猫变成一个丐版NAS 我的初衷是调研下光猫改桥接的可行性，结果拿到超级管理员密码后还是没有这个选项。但在这个过程中发现直接在光猫上跑个下载服务却是可行的。
允许FTP访问和telnet访问 访问 http://192.168.1.1 ，输入密码后进入光猫管理后台。这里我找到“上网帐号设置”，备份宽带帐号和密码。不得不说他系统还是挺拉的，密码框直接用审查元素功能把 type 改为 input 就可以看到密码了。
第一步后台不要退出，访问 http://192.168.1.1/servmngr.html 。这里看到一个空白页面，审查元素后发现大有乾坤。 将这些代码取消注释，此时网页还是空白的，但是用 Ctrl+A 可以看到实际是有内容的。在这个页面开启 telnet 访问，并设置密码。注意用户名为 admin 不要改，否则后面 telnet 登陆不进去。
telnet 192.168.1.1 成功后执行sh。然后uname -a看下。这里我就不记录查看管理员密码步骤了，反正这个型号管理员面板也没有设置桥接的选项。
开始整活 top，发现占用内存最高的是个两个 java 进程。java -version，发现安装了 java8 。
# java -version openjdk version &amp;#34;1.8.0-internal&amp;#34; OpenJDK Runtime Environment (build 1.8.0-internal-jenkinsang_2022_01_15_04_03-b00) JamVM (build 2.0.0, inline-threaded interpreter with stack-caching) free命令可知总内存约二十多兆，剩余仅 3 兆。这点空间是搞不了什么事情的，因此我尝试干掉前述两个 java 进程。ps -aux | grep java，发现除了存在两个 java 进程，还写了脚本自动把这两个进程拉起来，即/etc/monitor_java.sh 。统统 kill 掉。
现在有 10 兆左右的内存了，对于 java 来说可能还是不太能搞事，但跑个 aria2 足够了！尝试插入 U 盘，发现在/mnt/usb1_1自动挂载。</description>
    </item>
    
    <item>
      <title>AUIL学习</title>
      <link>https://ntutn.top/posts/auil%E5%AD%A6%E4%B9%A0/</link>
      <pubDate>Sun, 13 Feb 2022 18:11:08 +0800</pubDate>
      
      <guid>https://ntutn.top/posts/auil%E5%AD%A6%E4%B9%A0/</guid>
      <description>AUIL 源码学习 重点问题 AUIL是个比较知名的图片加载库，源码结构比较清晰和简单，我在阅读学习中整理了以下内容。
MemoryCache 顾名思义，这个是在内存中缓存Bitmap相关的代码。
MemoryCache结合了策略模式和装饰器模式，初始化时可选择不同缓存策略。
一个Cache类内部持有一定量的Bitmap元素，并根据某种策略自动移除未使用的Bitmap。看结构我们应该从BaseMemoryCache开始看起。
BaseMemoryCache中持有了所有放入的元素的弱引用，而它的子类根据策略持有了部分缓存对象的强引用。
整个框架分多少个模块，每个模块的作用是什么  ImageLoader 门面。 ImageAware 对最终处理和展示图片操作的封装。 MemoryCache bitmap在内存中的缓存。 BitmapProcessor 图片处理器，处理原始图片。分为预处理和后处理，预处理的结果会存入缓存，而后处理每次展示都会执行。 BitmapDisplayer 控制图片展示，可为其附加一定的展示效果。 DiskCache bitmap在磁盘中的缓存 ImageDecoder 将图片解码为Bitmap，并缩放到合适尺寸  如何仅通过interface就将框架的整个流程串联起来 如何进行内存管理的，LRU是种什么算法，有没有比LRU更好的？ AUIL的图片缓存有二级，一是所有缓存过的图片都会持有WeakReference，可能随时回收；二是部分图片会持有强引用，不会被回收。这里的部分图片的总共大小可以设置，达到阈值之后使用一定的算法淘汰一些图片。这里最常用的就是LRU。
LRU是淘汰缓存文件的算法，它每次淘汰最久未使用的文件。是一种最常用的页面置换算法。除了LRU之外，AUIL预置的算法还有FIFO（先入先出）、LargestLimitted（淘汰最大的文件）、LFU（淘汰使用频率最低的）。三者各有优劣。
如，LRU因为图片展示频率在时间上的不均匀性，可能将一些高频展示的图片淘汰掉，导致缓存命中率下降；LFU对于新图片频率统计无法比较好把控。
用到了多少个线程池，这些线程池之间的区别是什么，如果只用一个线程池可以么？ 使用了三个线程池：
 taskExecutor taskExecutorForCachedImages taskDistributor  taskExecutor和taskExecutorForCachedImages都是用来执行图片处理和展示任务的，他们处理顺序都是个LIFO（后进先出）的队列，而taskDistributor是个普通的线程池，用于框架内其他任务。
taskExecutorForCachedImages是专门为缓存中读取的图片展示用的线程池，因为这类图片响应会很快，所以AUIL专门给他们准备了一个线程池。 综上，如果用一个线程池则最终效果会大打折扣。</description>
    </item>
    
    <item>
      <title>给APP添加构建信息</title>
      <link>https://ntutn.top/posts/%E7%BB%99app%E6%B7%BB%E5%8A%A0%E6%9E%84%E5%BB%BA%E4%BF%A1%E6%81%AF/</link>
      <pubDate>Sun, 16 Jan 2022 23:24:16 +0800</pubDate>
      
      <guid>https://ntutn.top/posts/%E7%BB%99app%E6%B7%BB%E5%8A%A0%E6%9E%84%E5%BB%BA%E4%BF%A1%E6%81%AF/</guid>
      <description>给APP添加构建信息  这两天在琢磨一个问题，一个APP是怎么知道自己是怎么来的呢？ 一个应用得知道自己是怎么来的，这样出了问题才知道该找谁。举个例子，当应用发生了一个线上crash，崩溃信息收集上来，然后我们打开堆栈一看懵了——这个发生崩溃的v5.c是哪个类呢？
 显然，代码被混淆过，我们要拿到编译时生成的mapping.txt来还原堆栈，如图
**然而，我们编译了很多次，客官您要的是哪次的mapping文件呢？**显然，我们不仅要保留每次构建的相关信息，还得能准确区分开每次构建的产物，能做到有问题立即查询到对应构建信息。
应用需要知道自己是“怎么来的”。
区分不同构建结果  可以收集当前commit id，commit不同一定是不同构建。 可以生成一个较长的随机数每次构建不同。  看上去前者更优雅，但一个commit id上并不一定只有一个成功的构建，比如你做一应用叫“快音”，测试通过后调整了一些编译选项打出线上包，此时只根据commit id就无法确定是对应测试包的构建还是线上包了。
所以，最实在的方法还是后者。
fun runShellCommand(command: String): String { val byteOut = ByteArrayOutputStream() project.exec { commandLine = command.split(&amp;#34; &amp;#34;) standardOutput = byteOut } return String(byteOut.toByteArray()) } val buildNumber = UUID.randomUUID() val gitBranch = runShellCommand(&amp;#34;git branch --show-current&amp;#34;).trim() val gitCommitId = runShellCommand(&amp;#34;git rev-parse HEAD&amp;#34;).trim() val buildTimeMILLIS = System.currentTimeMillis() 将信息传给应用 不知道大家有没有这种习惯，在开发时加一些测试代码时判断只在Debug版本生效，即
if (BuildConfig.DEBUG) { Toast.makeText(applicationContext, &amp;#34;test&amp;#34;, Toast.LENGTH_SHORT).show() } 这样即使我真的忘记删除这段代码也不会影响到线上，让用户看到个“test”感到莫名其妙。这里用的BuildConfig就是在Gradle构建时生成的一个类，里面包含了一些有关当前构建的信息1。</description>
    </item>
    
    <item>
      <title>android项目开发：持久化</title>
      <link>https://ntutn.top/posts/%E6%8C%81%E4%B9%85%E5%8C%96/</link>
      <pubDate>Sun, 24 Oct 2021 03:11:37 +0800</pubDate>
      
      <guid>https://ntutn.top/posts/%E6%8C%81%E4%B9%85%E5%8C%96/</guid>
      <description>《第一行代码》阅读记录，有关数据持久化存储，略过了数据库的方式。
持久化 文件存储 先暂时只是写了个demo，有需要再深入看。
private fun saveText(inputText: String) { try { val output = openFileOutput(&amp;#34;data&amp;#34;, Context.MODE_PRIVATE) val writer = BufferedWriter(OutputStreamWriter(output)) writer.use { it.write(inputText) } } catch (e: IOException) { e.printStackTrace() } } private fun loadText(): String { val content = StringBuilder() try { val input = openFileInput(&amp;#34;data&amp;#34;) val reader = BufferedReader(InputStreamReader(input)) reader.use { r -&amp;gt; r.forEachLine { content.appendLine(it) } } } catch (e: IOException) { e.printStackTrace() } return content.toString() } SharedPreference saveButton.</description>
    </item>
    
    <item>
      <title>android项目开发：Kotlin</title>
      <link>https://ntutn.top/posts/kotlin/</link>
      <pubDate>Tue, 12 Oct 2021 03:11:37 +0800</pubDate>
      
      <guid>https://ntutn.top/posts/kotlin/</guid>
      <description>Kotlin 变量和函数 变量 用var和val定义变量，并有类型自动推导的支持。
val用来声明一个不可变的变量，var用来声明一个可变的变量。
val a = 10 var b: Int = 12 Kotlin完全抛弃了java中的基本数据类型，完全使用对象数据类型。
   java基本数据类型 Kotlin对象数据类型 数据类型说明     int Int 整型   long Long 长整型   short Short 短整型   float Float 单精度浮点型   double Double 双精度浮点型   boolean Boolean 布尔型   char Char 字符型   byte Byte 字节型    函数 语法：
fun main(args: Array&amp;lt;String&amp;gt;) { println(&amp;#34;Hello World!</description>
    </item>
    
    <item>
      <title>Java默认修饰符问题</title>
      <link>https://ntutn.top/posts/java%E9%BB%98%E8%AE%A4%E4%BF%AE%E9%A5%B0%E7%AC%A6%E9%97%AE%E9%A2%98/</link>
      <pubDate>Tue, 12 Oct 2021 03:11:37 +0800</pubDate>
      
      <guid>https://ntutn.top/posts/java%E9%BB%98%E8%AE%A4%E4%BF%AE%E9%A5%B0%E7%AC%A6%E9%97%AE%E9%A2%98/</guid>
      <description>问题描述 和工具线配合完成某个需求，我这边的改动很少，但一鼓作气搞完后却遇到了奇怪的报错。已知工具线的代码大多是java的，而我这边自然是力推Kotlin。我们的代码参考如下：
代码参考 工具线定义了一个接口用于callback
package a; interface IPublishCallback { void onFinish(); } 工具线在执行完发布逻辑后无论成功还是失败都会调用我们的callback
package a; public class PublishUtil { public static void publishVideo(String videoName, IPublishCallback callback) { Runnable runnable = () -&amp;gt; { try { System.out.println(&amp;#34;[&amp;#34; + videoName + &amp;#34;]开始执行耗时发布操作……&amp;#34;); Thread.sleep(1000L); } catch (InterruptedException e) { e.printStackTrace(); } callback.onFinish(); }; Thread thread = new Thread(runnable); thread.start(); try { thread.join(); } catch (InterruptedException e) { e.printStackTrace(); } } } 我们这边的实现是Kotlin的，就是调用了下工具线的方法
package b import a.</description>
    </item>
    
    <item>
      <title>作为一名男性，你愿意和丁真互换人生吗</title>
      <link>https://ntutn.top/posts/%E4%BD%9C%E4%B8%BA%E4%B8%80%E5%90%8D%E7%94%B7%E6%80%A7%E4%BD%A0%E6%84%BF%E6%84%8F%E5%92%8C%E4%B8%81%E7%9C%9F%E4%BA%92%E6%8D%A2%E4%BA%BA%E7%94%9F%E5%90%97/</link>
      <pubDate>Sun, 22 Aug 2021 03:11:37 +0800</pubDate>
      
      <guid>https://ntutn.top/posts/%E4%BD%9C%E4%B8%BA%E4%B8%80%E5%90%8D%E7%94%B7%E6%80%A7%E4%BD%A0%E6%84%BF%E6%84%8F%E5%92%8C%E4%B8%81%E7%9C%9F%E4%BA%92%E6%8D%A2%E4%BA%BA%E7%94%9F%E5%90%97/</guid>
      <description>忘记是哪一天了，一个叫『丁真』的人突然刷屏，热搜十条有6条都是他。但我见怪不怪了，微博热搜本来就是个笑话。
然后看看贴吧，知乎……全是他。
那就看看，这回是谁，为啥火了。一个放牛小伙，正巧被摄影师拍了，眼睛澄澈，笑容阳光，剩下的全是营销。
『为何贴吧男性普遍仇视辱骂丁真？』我玩贴吧，但对丁真没啥恶感，只是对这一堆热搜有恶感：**明明这两天有更值得关注的事情的。**好吧，咱也不知道，咱也不敢问，你们知道有几条热搜被盖过去了就行了。
『作为一名男性，你愿意和丁真互换人生吗？』好么，没完没了了，还不惜故意挑起性别对立。我就引用某个网友1的回答
碰到问题，不想跟爱因斯坦换脑子 兜里没钱，也没想过跟王思聪换爹 现在更不可能跟丁真换运气 一无所有，就是一无所有的人生 百病缠身，就是百病缠身的人生 腰缠万贯，就是腰缠万贯的人生 我的成功是我的，谁也夺不走 我的失败也是我的，不想跟谁换 说白了，我只想做好自己，好好过独属自己的独一无二的无法复刻的人生 不管这人生多么操蛋 也不想成为一个无穷欲望堆积成的肉块 我小时候也放牛来着，还不是一步步卷过来的。
  @在下头不是很铁了，原回答在某回答的回复里，但无法直接通过链接打开，大概是被限流了。转载已获授权。&amp;#160;&amp;#x21a9;&amp;#xfe0e;
   </description>
    </item>
    
    <item>
      <title>装饰模式实现分享功能</title>
      <link>https://ntutn.top/posts/%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0%E5%88%86%E4%BA%AB%E5%8A%9F%E8%83%BD/</link>
      <pubDate>Mon, 19 Jul 2021 03:11:37 +0800</pubDate>
      
      <guid>https://ntutn.top/posts/%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0%E5%88%86%E4%BA%AB%E5%8A%9F%E8%83%BD/</guid>
      <description>代码 业务代码不可能直接贴出来，我按照大致的设计写了如下demo。
import java.lang.IllegalArgumentException fun main() { listOf( ShareData(listOf(&amp;#34;图1&amp;#34;, &amp;#34;图2&amp;#34;, &amp;#34;图3&amp;#34;), true), ShareData(listOf(&amp;#34;图1&amp;#34;, &amp;#34;图2&amp;#34;, &amp;#34;图3&amp;#34;), false), ShareData(listOf(&amp;#34;视频1&amp;#34;, &amp;#34;视频2&amp;#34;, &amp;#34;视频3&amp;#34;), true), ShareData(listOf(&amp;#34;视频1&amp;#34;, &amp;#34;视频2&amp;#34;, &amp;#34;视频3&amp;#34;), false), ShareData(listOf(&amp;#34;图1&amp;#34;, &amp;#34;视频2&amp;#34;, &amp;#34;图3&amp;#34;), true), ShareData(listOf(&amp;#34;图1&amp;#34;, &amp;#34;视频2&amp;#34;, &amp;#34;图3&amp;#34;), false) ).forEach { println(&amp;#34;测试$it&amp;#34;) if (it.handler.requestPermission()) { it.handler.doShare(it) } else { println(&amp;#34;申请权限失败&amp;#34;) } println() } } class ShareData(val urls: List&amp;lt;String&amp;gt;, val isFromSDK: Boolean) { companion object { const val IMAGE = 0x1 const val VIDEO = 0x2 const val MIX = IMAGE.</description>
    </item>
    
    <item>
      <title>安卓连连看游戏设计</title>
      <link>https://ntutn.top/posts/%E5%AE%89%E5%8D%93%E8%BF%9E%E8%BF%9E%E7%9C%8B%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1/</link>
      <pubDate>Sun, 25 Apr 2021 03:11:37 +0800</pubDate>
      
      <guid>https://ntutn.top/posts/%E5%AE%89%E5%8D%93%E8%BF%9E%E8%BF%9E%E7%9C%8B%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1/</guid>
      <description>字节取消大小周了，于是周末时间多起来了。虽然想着到处去玩，但现在疫情形势又不好了，于是安心呆在家里当一个肥宅。除了补一补番剧，就是把之前就想过的连连看游戏做出来了。
连连看游戏规则简单，点击两个相同的元素，如果他们能在两次拐弯以内连接起来，那么就可以消除。消除后就会出现空位，可以连接的就更多了。在规定时间内连续操作，直到消除所有元素。
虽然规则比较简单，但真正动手实现一遍还是很费工夫的。游戏既然做好了，那么我水一篇博客不过分吧:&amp;gt;
1
项目的代码我放到了github。写的贼丑，轻喷。 https://github.com/zerofancy/match
资源准备 连连看需要一些素材图，可以考虑用水果、动物甚至我同学的头像等，但我想把难度设计高一点，手机屏幕就这么大，图片很小也能有比较高的辨识度，思来想去还是麻将比较合适。
幸运的是，我找到了这么一套免费的图片素材，Mahjong Icons，只要提供一个指向这个页面的超链接就可以免费用。
另外还需要一个应用图标，这个我是直接在Icon Park上找了一个。
接下来将素材导入到项目，为了随处使用方便，我还定义到了一个类中：
package top.ntutn.match /** * 麻将牌 */ object Mahjong { val bamboos = listOf( R.drawable.bamboo1, R.drawable.bamboo2, R.drawable.bamboo3, R.drawable.bamboo4, R.drawable.bamboo5, R.drawable.bamboo6, R.drawable.bamboo7, R.drawable.bamboo8, R.drawable.bamboo9 ) val dragons = listOf( R.drawable.dragon_chun, R.drawable.dragon_green, R.drawable.dragon_haku ) val faceDown = R.drawable.face_down val mans = listOf( R.drawable.man1, R.drawable.man2, R.drawable.man3, R.drawable.man4, R.drawable.man5, R.drawable.man6, R.drawable.man7, R.drawable.man8, R.drawable.man9 ) val pins = listOf( R.drawable.pin1, R.drawable.pin2, R.drawable.pin3, R.drawable.pin4, R.</description>
    </item>
    
    <item>
      <title>ClassLoader双亲委托机制探究</title>
      <link>https://ntutn.top/posts/classloader%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%89%98%E6%9C%BA%E5%88%B6%E6%8E%A2%E7%A9%B6/</link>
      <pubDate>Sun, 11 Apr 2021 03:11:37 +0800</pubDate>
      
      <guid>https://ntutn.top/posts/classloader%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%89%98%E6%9C%BA%E5%88%B6%E6%8E%A2%E7%A9%B6/</guid>
      <description>最近在研究抖音进入热点内流的耗时问题，种种线索指向了类加载耗时上。为此，我研究了Java类加载的双亲委托机制，并尝试给出了优化建议。
双亲委托机制 双亲委托机制中最重要的是loadClass方法，让我们看看它是怎么实现的。
protected Class&amp;lt;?&amp;gt; loadClass(String name, boolean resolve) throws ClassNotFoundException { // First, check if the class has already been loaded  Class&amp;lt;?&amp;gt; c = findLoadedClass(name); // 已加载过直接返回  if (c == null) { try { if (parent != null) { c = parent.loadClass(name, false); //尝试让parent加载  } else { c = findBootstrapClassOrNull(name); // bootstrap class loader是否加载过  } } catch (ClassNotFoundException e) { // ClassNotFoundException thrown if class not found  // from the non-null parent class loader  } if (c == null) { // If still not found, then invoke findClass in order  // to find the class.</description>
    </item>
    
    <item>
      <title>DebugEntrance和DebugConfig</title>
      <link>https://ntutn.top/posts/debugentrance%E5%92%8Cdebugconfig/</link>
      <pubDate>Mon, 22 Feb 2021 03:11:37 +0800</pubDate>
      
      <guid>https://ntutn.top/posts/debugentrance%E5%92%8Cdebugconfig/</guid>
      <description>工欲善其事，必先利其器。毕设是一个相对复杂的项目了，我觉得要想顺利完成肯定是需要一些手段帮助我调试的。于是这里我准备了debug页面，主要功能就两个：提供某个功能的入口以及存储配置（最好能直接在手机上修改）
DebugEntrance 就是一个各种测试功能的入口。
这个一看实现就很简单，不细说了。
DebugConfig 因为字节自己的ABManager用着挺顺手，感觉自己项目调试时有类似这么个东西会比较舒服，于是搞了这么个东西。
使用 先看使用：
@ZeroConfig(key = &amp;#34;retrofit_config&amp;#34;, title = &amp;#34;Retrofit配置&amp;#34;, owner = &amp;#34;liuhaixin.zero&amp;#34;) data class RetrofitConfig(val baseUrl: String = RetrofitUtil.BASE_URL) private val retrofitConfig by zeroConfig&amp;lt;RetrofitConfig&amp;gt;() private val retrofit by lazy { Retrofit.Builder() .baseUrl(retrofitConfig?.baseUrl ?: BASE_URL) .addConverterFactory(GsonConverterFactory.create()) .client(okHttpClient) .build() } 看上去还是有点让人心动的吧。
属性委托、泛型实化 首先是一段来自菜鸟教程的描述：
 属性委托指的是一个类的某个属性值不是在类中直接进行定义，而是将其托付给一个代理类，从而实现对该类属性的统一管理。
val/var &amp;lt;属性名&amp;gt;: &amp;lt;类型&amp;gt; by &amp;lt;表达式&amp;gt; by 关键字之后的表达式就是委托, 属性的 get() 方法(以及set() 方法)将被委托给这个对象的 getValue() 和 setValue() 方法。属性委托不必实现任何接口, 但必须提供 getValue() 函数(对于 var属性,还需要 setValue() 函数)。
 借助这个特征，我们可以定义这样一个委托类：</description>
    </item>
    
    <item>
      <title>ViewBinding、ViewModel和LiveData</title>
      <link>https://ntutn.top/posts/viewbindingviewmodel%E5%92%8Clivedata/</link>
      <pubDate>Mon, 22 Feb 2021 03:11:37 +0800</pubDate>
      
      <guid>https://ntutn.top/posts/viewbindingviewmodel%E5%92%8Clivedata/</guid>
      <description>毕设项目没有历史包袱，我可以尽量向best practice努力。
ViewBinding 无数人痛恨findViewById，并且为了干掉它做了许多尝试，比如ButterKnife、kotlin-android-extensions。
现在，有了ViewBinding，项目中真的可以不写findViewById了。至少目前为止我的毕设项目还没有一个findViewById。
其实与ViewBinding相似的，还有一个DataBinding，但我不太喜欢，感觉在xml里面写代码不是一个好主意。
使用 首先在build.gradle（或build.gradle.kts）中的android块添加
buildFeatures { viewBinding = true } 在xml中正常定义你的布局
&amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;utf-8&amp;#34;?&amp;gt; &amp;lt;LinearLayout xmlns:android=&amp;#34;http://schemas.android.com/apk/res/android&amp;#34; xmlns:tools=&amp;#34;http://schemas.android.com/tools&amp;#34; android:layout_width=&amp;#34;match_parent&amp;#34; android:layout_height=&amp;#34;match_parent&amp;#34; android:orientation=&amp;#34;vertical&amp;#34; tools:context=&amp;#34;.MainActivity&amp;#34;&amp;gt; &amp;lt;TextView android:id=&amp;#34;@+id/text_view&amp;#34; android:layout_width=&amp;#34;match_parent&amp;#34; android:layout_height=&amp;#34;wrap_content&amp;#34; android:text=&amp;#34;Hello World!&amp;#34; /&amp;gt; &amp;lt;Button android:id=&amp;#34;@+id/test_button&amp;#34; android:layout_width=&amp;#34;match_parent&amp;#34; android:layout_height=&amp;#34;wrap_content&amp;#34; android:text=&amp;#34;toast&amp;#34; /&amp;gt; &amp;lt;Button android:id=&amp;#34;@+id/change_button&amp;#34; android:layout_width=&amp;#34;match_parent&amp;#34; android:layout_height=&amp;#34;wrap_content&amp;#34; android:text=&amp;#34;change&amp;#34; /&amp;gt; &amp;lt;/LinearLayout&amp;gt; 接下来就可以愉快使用了
package top.ntutn.viewmodeldemo import android.os.Bundle import android.widget.Toast import androidx.appcompat.app.AppCompatActivity import top.ntutn.viewmodeldemo.databinding.ActivityMainBinding class MainActivity : AppCompatActivity() { private lateinit var binding: ActivityMainBinding override fun onCreate(savedInstanceState: Bundle?) { super.</description>
    </item>
    
    <item>
      <title>干掉macOS的OCSP</title>
      <link>https://ntutn.top/posts/%E5%B9%B2%E6%8E%89macos%E7%9A%84ocsp/</link>
      <pubDate>Sun, 21 Feb 2021 03:11:37 +0800</pubDate>
      
      <guid>https://ntutn.top/posts/%E5%B9%B2%E6%8E%89macos%E7%9A%84ocsp/</guid>
      <description>苹果这两天摊上事了，有不少用户说自己的设备打开应用程序会卡好几分钟，然后分析发现是苹果的OCSP校验导致的。
当启动一个新应用程序的时候，系统会把其hash发送到ocsp.apple.com用于校验，而这次是这个服务挂了但是能ping通……
这个事情引起不小的讨论，主要集中在有关隐私的担忧上。本来我没有太在意，但测试发现这好像是我每次休眠恢复后触摸板卡几秒的元凶……
那对不起了。
echo &amp;#34;127.0.0.1 ocsp.apple.com&amp;#34; | sudo tee -a /etc/hosts 反正还有SEP把门呢。</description>
    </item>
    
    <item>
      <title>【译】用BuildSrc和Kotlin_DSL管理Gradle依赖</title>
      <link>https://ntutn.top/posts/%E8%AF%91%E7%94%A8buildsrc%E5%92%8Ckotlin_dsl%E7%AE%A1%E7%90%86gradle%E4%BE%9D%E8%B5%96/</link>
      <pubDate>Sun, 21 Feb 2021 03:00:37 +0800</pubDate>
      
      <guid>https://ntutn.top/posts/%E8%AF%91%E7%94%A8buildsrc%E5%92%8Ckotlin_dsl%E7%AE%A1%E7%90%86gradle%E4%BE%9D%E8%B5%96/</guid>
      <description>多模块工程中一个更好的引入依赖的方法 翻译自Gradle Dependency Management With BuildSrc and Kotlin DSL
 第一次尝试翻译英文文章……
要点 主要集中在如何用buildSrc目录和Kotlin DSL脚本构建一个Gradle依赖管理系统，你也会学到这样做相对使用传统Groovy代码的好处。
如果你倾向于通过视频来看这篇博客，文末附有一个Youtube视频。
问题 众所周知在一个快速发展的项目中维护依赖是一个乏味的工作，而传统的Groovy脚本没有code navigation、自动补全，再加上性能问题和运行时错误让这一切变得更糟糕。
更重要的是，多数安卓开发者不懂Groovy，甚至我也不知道我之前在用Groovy做啥。
感谢Gradle团队和社区的工作提供了一个顺畅安全的构建流程，他们提出的最棒的主意之一就是用Kotlin DSL脚本写buildSrc目录。
解决 依赖库引入和自定义task不应该放到构建脚本中，它们应该被声明到一个独立文件中再被构建脚本使用。在这个实现的早期，开发者习惯于创建一个Gradle文件来声明所有库并在构建脚本中使用。
这确实在一定程度上解决了问题，你可以在这篇文章读到这种方法。但这个简单方案不能解决类似自动补全和code navigation的问题，这使得在长远上看这个方案不够可靠。在这之外，buildSrc似乎有希望解决这个问题。
 这个目录被当作一个included build看待。在发现这个目录之后，Gradle自动编译和测试它的代码，并将编译结果放到你的构建脚本的class path中。在一个多模块的工程中只能有一个这样的目录，并且要放到工程的顶级目录中。应该优先通过script plugins因为这样更便于管理、重构和测试代码。 ——Gradle团队
 创建buildSrc目录 使用Kotlin DSL脚本不但能解决构建脚本中的这些问题，还能得到先进的IDE支持，包括code navigation、编译时错误提示等。最重要的，我们再也不用使用Groovy了。
我们要做的第一件事是创建一个buildSrc目录：
 在工程上右键 点击New并选择Directory 把它命名为buildSrc  如果你仍然不懂怎么创建这个目录，请看这里：
然后我们需要在这个目录里创建一个叫做build.gradle.kts的文件，在这个文件里导入插件和存储库。
plugins{ `kotlin-dsl` } repositories { jcenter() } 完成后你还需要点击gradle的“sync now”按钮，因为gradle把它当作了一个新建目录中的普通文件。现在你可以实现Kotlin DSL脚本了。
下一步是创建一个类似这样的目录结构src&amp;gt;main&amp;gt;java，完成后如上图所示。
现在我们可以创建Kotlin文件来声明依赖库，管理版本或者实现自定义task。
现在我们的目标是实现一个依赖管理系统，所以我们创建一个叫做Dependencies.kt的文件（你可以用你喜欢的任何名字）。
完成后我们就可以通过Kotlin代码来声明依赖库和版本了。这里我们用object来声明特定的类型，例如版本号、AndroidX依赖库等。
首先我们创建一个用来用Kotlin风格定义所有依赖库版本号的object。
object Versions{ val constraint_layout_version = &amp;#34;1.1.3&amp;#34; val lifecycle_version = &amp;#34;2.2.0&amp;#34; val coroutines_version = &amp;#34;1.</description>
    </item>
    
    <item>
      <title>我的黑历史被github埋到北极了</title>
      <link>https://ntutn.top/posts/%E6%88%91%E7%9A%84%E9%BB%91%E5%8E%86%E5%8F%B2%E8%A2%ABgithub%E5%9F%8B%E5%88%B0%E5%8C%97%E6%9E%81%E4%BA%86/</link>
      <pubDate>Tue, 26 Jan 2021 03:11:37 +0800</pubDate>
      
      <guid>https://ntutn.top/posts/%E6%88%91%E7%9A%84%E9%BB%91%E5%8E%86%E5%8F%B2%E8%A2%ABgithub%E5%9F%8B%E5%88%B0%E5%8C%97%E6%9E%81%E4%BA%86/</guid>
      <description>昨天整理自己的github仓库的时候发现自己的个人主页多了个徽章：Arctic Code Vault Contributor
So what happened?
GitHub Code Vault是什么  GitHub Code Vault（GitHub 代码保险库）是由 GitHub Archive Program（GitHub 代码永久保存计划）设立的代码档案库，旨在保存开源软件以供未来使用。1
 天灾人祸，世界末日，地球回到原始时代重新发展，或者betacat污染了所有开源代码库啦，人类就可以找到这份代码库，重建网络世界。
该项目给github上活跃的开源代码库建立快照，将他们存储在胶片上运往北极。据称这些代码将被保存至少1000年。
每个细节都充满了科幻的味道，比如考虑一前年后的人类不一定读懂今天的代码，在《GitHub Code Vault 指南》中介绍了二进制、计算机、软件、编译等基本概念，以及如何解码胶片上的信息。 当然，这个指南本身并没有被压缩和编码，他们没有犯某些网站的RARSetup.rar的错误。
考虑到地球文明重建，人类不一定造出了计算机，于是还放了一份科技树指南，包含理解软件所需的多层技术基础，如微处理器、网络、电子、半导体，甚至工业社会前的技术。有了这些技术，让人类可以重新造出现代计算机。
我的被选中的代码库 ctodo https://github.com/zerofancy/ctodo
一个终端todo工具。c不是指C语言，而是console（事实上这个项目是java写的）。
项目代码本身写的很垃圾，也就这个主意有点意思。在终端直接管理TODO List，听上去不错，但我没有坚持用太久。后来还是觉得有GUI的todo工具更好，比如微软的待办事项。
然而即使是这个主意，我也找到了更好的实现：devtodo，所以我的那个仓库也就不再维护了。
noveldownloader https://github.com/zerofancy/noveldownloader
一个用Java+selenium写的小说下载器，基本原理就是模仿用户不断点“下一页”
没错，这个项目就是我看小说不想买正版又忍受不了盗版的广告时写的。当然因为是自用所以代码写的很随意，这不说放到1000年后，就是一两年后也是妥妥的黑历史啊……
吃瓜 Dress被选中了 你们的照片现在已经被冰封在北极了。。。
女装一时爽，破照留千年。坦白讲，除了公司的项目，我克隆过的最大的项目就是Dress
虽然该项目会忽略大于100KB的二进制文件，但这个限制会随着star数逐渐解除。考虑到这个项目的star数……为1000年后的考古学家的头发默哀3秒。
996.icu被选中了 https://996.icu/#/zh_CN
我的代码留点bug给后世解决不算什么，但996.icu也被选中了。这下真的被钉到历史的耻辱柱上了……
面向Stackoverflow编程 不同时快照一份 stackoverflow ，后代也不会抄啊。2
大家还贡献了什么 dotfile、Github Pages、个人演讲库和个人网站、给女朋友的信，听说鸿蒙的ppt也在里面……
参考  除了bug，GitHub可能还把你的女装照冻到了北极，1000年后还能读那种 https://archiveprogram.github.com/ GitHub Archive Program: the journey of the world’s open source code to the Arctic    GitHub Code Vault 指南&amp;#160;&amp;#x21a9;&amp;#xfe0e;</description>
    </item>
    
    <item>
      <title>android项目开发：通知</title>
      <link>https://ntutn.top/posts/%E9%80%9A%E7%9F%A5/</link>
      <pubDate>Tue, 12 Jan 2021 03:11:37 +0800</pubDate>
      
      <guid>https://ntutn.top/posts/%E9%80%9A%E7%9F%A5/</guid>
      <description>仍然是第一行代码的笔记，这篇是有关通知的，最基本的用法。
通知的相关知识 通知是什么不再赘述，这里只记录些重要但没接触的概念。
通知渠道在8.0（O）引入。要求APP将通知分类，通过不同渠道进行分发，用户可以选择性禁用某个渠道的通知，或者调整优先等级。
通知可以有不同的重要等级，有四种：IMPORTANCE_HIGH、IMPORTANCE_DEFAULT、IMPORTANCE_LOW、IMPORTANCE_MIN。根据重要等级不同，通知可能有不同的展现策略，比如在前台提示甚至播放声音。
在通知渠道创建时通知的重要等级也就确定了，之后不能再被APP修改。
通知dmeo package top.ntutn.notificationtest import android.app.NotificationChannel import android.app.NotificationManager import android.app.PendingIntent import android.content.Context import android.content.Intent import android.graphics.BitmapFactory import android.os.Build import androidx.appcompat.app.AppCompatActivity import android.os.Bundle import androidx.core.app.NotificationCompat import top.ntutn.notificationtest.databinding.ActivityMainBinding class MainActivity : AppCompatActivity() { private lateinit var binding: ActivityMainBinding override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) binding = ActivityMainBinding.inflate(layoutInflater) setContentView(binding.root) initView() } private fun initView(){ val manager = getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager if(Build.VERSION.SDK_INT &amp;gt;= Build.VERSION_CODES.O){ // 通知渠道  val channel = NotificationChannel(&amp;#34;normal&amp;#34;,&amp;#34;Normal&amp;#34;,NotificationManager.</description>
    </item>
    
    <item>
      <title>截图不可信,我们能信什么</title>
      <link>https://ntutn.top/posts/%E6%88%AA%E5%9B%BE%E4%B8%8D%E5%8F%AF%E4%BF%A1%E6%88%91%E4%BB%AC%E8%83%BD%E4%BF%A1%E4%BB%80%E4%B9%88/</link>
      <pubDate>Mon, 04 Jan 2021 03:11:37 +0800</pubDate>
      
      <guid>https://ntutn.top/posts/%E6%88%AA%E5%9B%BE%E4%B8%8D%E5%8F%AF%E4%BF%A1%E6%88%91%E4%BB%AC%E8%83%BD%E4%BF%A1%E4%BB%80%E4%B9%88/</guid>
      <description>这两天网上流传一件事，又有一个拼多多员工猝死了，而这名员工是98年出生的，年仅23岁。
如何看待网传拼多多员工加班后猝死一事？拼多多需要承担哪些责任？ - 知乎
之前虽然一直有程序员猝死的案例，但总感觉离自己很远，甚至拿程序员钱多话少死的快这种梗自嘲，但这次我慌了，因为我也是98年的。
之后也在对这个事情保持关注，然后突然在知乎流传一张截图，截图为拼多多自己在上述问题下的回答，并称该回答已经被删除。
这是要搞事情的节奏啊。当然接下来拼多多自然说自己没说过，于是有了第二个问题：拼多多疑似回应「员工猝死」后秒删，是真的吗？拼多多又称截图系谣言，你相信吗？ - 知乎
然后知乎小管家发布内容证明拼多多说过：拼多多疑似回应「员工猝死」后秒删，是真的吗？拼多多又称截图系谣言，你相信吗？ - 知乎小管家的回答 - 知乎
好吧，拼多多栽了，那么我们有没有别的方法证明这件事情发生过？万一下次是腾讯出了什么问题，小管家扛得住压力吗？
截图不可靠 截图真的是个很神奇的东西，一行字只要被截成图可信度好像就上升了不少，但截图伪造起来也太容易了。
有三人成虎旧事，人们总结了『耳听为虚，眼见为实』的真理，但现在信息时代眼见也不一定为实了。
 图片有可能被软件处理过 网页内容可能被修改过 发布内容的账号可能是个高仿 图片可能没截全，存在被断章取义的现象  在这方面，比如F12，永远的神。
互联网档案馆  互联网档案馆（英语：Internet Archive）是美国的一个由Alexa创始人布鲁斯特·卡利创办于1996年的非营利性的、提供互联网多媒体资料文件阅览服务的数字图书馆，总部位于加利福尼亚州旧金山的列治文区，其使命是“普及所有知识”（英语：universal access to all knowledge.）。该“档案馆”提供的数字资料有如网站、网页、图形材料音乐、视频、音频、软件、动态图像和数百万书籍等的永久性免费储存及获取的副本。 迄至2012年10月，其信息储量达到10PB。除此之外，该档案馆也是网络开放与自由化的倡议者之一。1
 比如上面提到的小管家的这个回答：拼多多疑似回应「员工猝死」后秒删，是真的吗？拼多多又称截图系谣言，你相信吗？ - 知乎小管家的回答 - 知乎
我们日后需要证明小管家说过，那么先打开互联网档案馆：
https://archive.org/
添加小管家这条回答
然后archive.org的爬虫会抓取这个链接并保存下来。
如果有一天知乎倒闭了，我们仍然能用这个链接证明小管家说过这句话。
https://web.archive.org/web/20210104115016/https://www.zhihu.com/question/437783708/answer/1660566169
  互联网档案馆&amp;#160;&amp;#x21a9;&amp;#xfe0e;
   </description>
    </item>
    
    <item>
      <title>android项目开发：Broadcast</title>
      <link>https://ntutn.top/posts/broadcast/</link>
      <pubDate>Thu, 24 Dec 2020 03:11:37 +0800</pubDate>
      
      <guid>https://ntutn.top/posts/broadcast/</guid>
      <description>仍然是《第一行代码》的学习笔记，安卓内置广播机制。
Android中每个应用程序都可以对自己感兴趣的广播进行注册，包括来自系统的，和其他应用程序的。
广播分为标准广播和有序广播。
 标准广播异步执行，所有BroadcastReceiver几乎同时收到广播的消息。 有序广播 同步执行，只有前一个Receiver逻辑执行完后才会传递给下一个，且可以将广播截断。  接收系统广播 BroadcastReceiver的onReceive()方法是在主线程调用的，不应执行耗时操作。但开一个新线程操作也是不可靠的1。
监听时间变化（动态注册） class MainActivity : AppCompatActivity() { private val timeReceiver = object : BroadcastReceiver() { override fun onReceive(context: Context?, intent: Intent?) { text.text = Date(System.currentTimeMillis()).toString() } } override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) val intentFilter = IntentFilter() intentFilter.addAction(Intent.ACTION_TIME_TICK) registerReceiver(timeReceiver, intentFilter) } override fun onDestroy() { super.onDestroy() unregisterReceiver(timeReceiver) } } 开机启动（静态注册） &amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;utf-8&amp;#34;?&amp;gt; &amp;lt;manifest xmlns:android=&amp;#34;http://schemas.android.com/apk/res/android&amp;#34; package=&amp;#34;top.ntutn.broadcasttest&amp;#34;&amp;gt; &amp;lt;uses-permission android:name=&amp;#34;android.permission.RECEIVE_BOOT_COMPLETED&amp;#34; /&amp;gt; &amp;lt;application android:allowBackup=&amp;#34;true&amp;#34; android:icon=&amp;#34;@mipmap/ic_launcher&amp;#34; android:label=&amp;#34;@string/app_name&amp;#34; android:roundIcon=&amp;#34;@mipmap/ic_launcher_round&amp;#34; android:supportsRtl=&amp;#34;true&amp;#34; android:theme=&amp;#34;@style/Theme.</description>
    </item>
    
    <item>
      <title>禁用macOS的窗口标签</title>
      <link>https://ntutn.top/posts/%E7%A6%81%E7%94%A8macos%E7%9A%84%E7%AA%97%E5%8F%A3%E6%A0%87%E7%AD%BE/</link>
      <pubDate>Tue, 22 Dec 2020 03:11:37 +0800</pubDate>
      
      <guid>https://ntutn.top/posts/%E7%A6%81%E7%94%A8macos%E7%9A%84%E7%AA%97%E5%8F%A3%E6%A0%87%E7%AD%BE/</guid>
      <description>作为一个对更新相对激进的用户，我当然是第一时间升级了最新的macOS Big Sur。说实在的，这名字给我的第一印象并不好，因为被我看成了『Big Bug』。
圆角变大了，还有我一开始比较喜欢的功能，姑且称之为窗口标签。在BigSur中，当你打开两个全屏的Android Studio，它们将出现在同一个窗口，窗口上方出现不同的标签页，和浏览器一样。
好景不长，这个功能表现很不稳定，我不得不考虑干掉这个功能。如果只是没有成功触发也就算了，大不了当没升级用，但它常常会把一些弹出窗口也搞成和原窗口并列的标签。比如当你rename一个文件时，弹出的窗口有时就会并列到标签上，然后Android Studio就卡死了。
好吧，既然它开始影响我的工作效率了，我就找了找禁用的方法1。
defaults write com.google.android.studio AppleWindowTabbingMode manual   来自https://www.reddit.com/r/androiddev/comments/jtbl4m/has_anyone_updated_to_macos_big_sur_and_is/&amp;#160;&amp;#x21a9;&amp;#xfe0e;
   </description>
    </item>
    
    <item>
      <title>android项目开发：Fragment</title>
      <link>https://ntutn.top/posts/fragment/</link>
      <pubDate>Mon, 21 Dec 2020 03:11:37 +0800</pubDate>
      
      <guid>https://ntutn.top/posts/fragment/</guid>
      <description>Fragment Fragment的使用方式 静态添加Fragment Fragment的写法
&amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;utf-8&amp;#34;?&amp;gt; &amp;lt;LinearLayout xmlns:android=&amp;#34;http://schemas.android.com/apk/res/android&amp;#34; android:orientation=&amp;#34;vertical&amp;#34; android:layout_width=&amp;#34;match_parent&amp;#34; android:layout_height=&amp;#34;match_parent&amp;#34;&amp;gt; &amp;lt;Button android:id=&amp;#34;@+id/button&amp;#34; android:layout_width=&amp;#34;wrap_content&amp;#34; android:layout_height=&amp;#34;wrap_content&amp;#34; android:text=&amp;#34;button&amp;#34; android:layout_gravity=&amp;#34;center_horizontal&amp;#34;/&amp;gt; &amp;lt;/LinearLayout&amp;gt; package top.ntutn.fragmenttest import android.os.Bundle import android.view.LayoutInflater import android.view.View import android.view.ViewGroup import androidx.fragment.app.Fragment class LeftFragment : Fragment() { override fun onCreateView( inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle? ): View? { return inflater.inflate(R.layout.left_fragment, container, false) } } 静态添加Fragment
&amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;utf-8&amp;#34;?&amp;gt; &amp;lt;LinearLayout xmlns:android=&amp;#34;http://schemas.android.com/apk/res/android&amp;#34; xmlns:tools=&amp;#34;http://schemas.android.com/tools&amp;#34; android:layout_width=&amp;#34;match_parent&amp;#34; android:layout_height=&amp;#34;match_parent&amp;#34; android:orientation=&amp;#34;horizontal&amp;#34; tools:context=&amp;#34;.MainActivity&amp;#34;&amp;gt; &amp;lt;fragment android:id=&amp;#34;@+id/leftFragment&amp;#34; android:name=&amp;#34;top.ntutn.fragmenttest.LeftFragment&amp;#34; android:layout_width=&amp;#34;0dp&amp;#34; android:layout_height=&amp;#34;match_parent&amp;#34; android:layout_weight=&amp;#34;1&amp;#34;/&amp;gt; &amp;lt;fragment android:id=&amp;#34;@+id/rightFragment&amp;#34; android:name=&amp;#34;top.</description>
    </item>
    
    <item>
      <title>android项目开发：UI设计</title>
      <link>https://ntutn.top/posts/ui%E8%AE%BE%E8%AE%A1/</link>
      <pubDate>Mon, 21 Dec 2020 03:11:37 +0800</pubDate>
      
      <guid>https://ntutn.top/posts/ui%E8%AE%BE%E8%AE%A1/</guid>
      <description>仍然是《第一行代码》的学习笔记，这里记录的东西相对少一点，UI上的东西还是更多在实际项目中感受到。比如我想没有必要写TextView的介绍吧。
控件的使用方法 dp是一种屏幕密度无关的尺寸单位，可以保证在不同分辨率的手机上显示效果尽可能一致。
match_parent表示让当前控件大小和父布局的大小一致。
wrap_content表示让当前控件的大小能正好包裹里面的内容。
android:gravity指定控件内的内容对齐方式，有top、bottom、start、end、center等可选，可以用|指定多个值。比如center等价于center_vertical|center_horizonal。
基本布局 LinearLayout 线性布局，通过android:orientation指定方向。
有一个重要属性：android:layout_weight，它将控件已经占用的空间减掉后按照比重分给各个控件。一般我们直接指定android:layout_width为0dp，而给它指定一个比重，这样控件的尺寸将占满剩余空间。
RelativeLayout 相对布局，复杂，但有迹可循。
&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;utf-8&amp;quot;?&amp;gt; &amp;lt;RelativeLayout xmlns:android=&amp;quot;http://schemas.android.com/apk/res/android&amp;quot; xmlns:tools=&amp;quot;http://schemas.android.com/tools&amp;quot; android:layout_width=&amp;quot;match_parent&amp;quot; android:layout_height=&amp;quot;match_parent&amp;quot; tools:context=&amp;quot;.MainActivity&amp;quot;&amp;gt; &amp;lt;Button android:id=&amp;quot;@+id/button1&amp;quot; android:layout_width=&amp;quot;wrap_content&amp;quot; android:layout_height=&amp;quot;wrap_content&amp;quot; android:layout_alignParentLeft=&amp;quot;true&amp;quot; android:layout_alignParentTop=&amp;quot;true&amp;quot; android:text=&amp;quot;Button1&amp;quot; /&amp;gt; &amp;lt;Button android:id=&amp;quot;@+id/button2&amp;quot; android:layout_width=&amp;quot;wrap_content&amp;quot; android:layout_height=&amp;quot;wrap_content&amp;quot; android:layout_alignParentTop=&amp;quot;true&amp;quot; android:layout_alignParentRight=&amp;quot;true&amp;quot; android:text=&amp;quot;Button2&amp;quot; /&amp;gt; &amp;lt;Button android:id=&amp;quot;@+id/button3&amp;quot; android:layout_width=&amp;quot;wrap_content&amp;quot; android:layout_height=&amp;quot;wrap_content&amp;quot; android:layout_centerInParent=&amp;quot;true&amp;quot; android:text=&amp;quot;Button3&amp;quot; /&amp;gt; &amp;lt;Button android:id=&amp;quot;@+id/button4&amp;quot; android:layout_width=&amp;quot;wrap_content&amp;quot; android:layout_height=&amp;quot;wrap_content&amp;quot; android:layout_alignParentLeft=&amp;quot;true&amp;quot; android:layout_alignParentBottom=&amp;quot;true&amp;quot; android:text=&amp;quot;Button4&amp;quot; /&amp;gt; &amp;lt;Button android:id=&amp;quot;@+id/button5&amp;quot; android:layout_width=&amp;quot;wrap_content&amp;quot; android:layout_height=&amp;quot;wrap_content&amp;quot; android:layout_alignParentRight=&amp;quot;true&amp;quot; android:layout_alignParentBottom=&amp;quot;true&amp;quot; android:text=&amp;quot;Button5&amp;quot; /&amp;gt; &amp;lt;/RelativeLayout&amp;gt; 以上这段布局文件描述的就是一个相对布局，共有5个按钮，分别在父布局的左上、右上、中间、左下、右下位置。
相对布局不仅可以相对于父布局，也可以相对于控件。以下描述了button3在中间，左上button1，右上button2，左下button4，右下button5的布局场景。
&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;utf-8&amp;quot;?&amp;gt; &amp;lt;RelativeLayout xmlns:android=&amp;quot;http://schemas.android.com/apk/res/android&amp;quot; xmlns:tools=&amp;quot;http://schemas.android.com/tools&amp;quot; android:layout_width=&amp;quot;match_parent&amp;quot; android:layout_height=&amp;quot;match_parent&amp;quot; tools:context=&amp;quot;.</description>
    </item>
    
    <item>
      <title>android项目开发：Activity</title>
      <link>https://ntutn.top/posts/activity/</link>
      <pubDate>Tue, 15 Dec 2020 03:11:37 +0800</pubDate>
      
      <guid>https://ntutn.top/posts/activity/</guid>
      <description>title: android项目开发：Activity author: 归零幻想 publishDate: 2020-12-15 editDate: 2020-12-15 tags: [android, 第一行代码, Kotlin, Activity]
 仍然是《第一行代码》的读书笔记，可能引用原书的定义和描述，或代码案例。
 Activity Activity基本用法 Android讲究设计逻辑与视图分离，一般Activity都会对应一个布局文件（XML文件）。
所有的Activity都要在AndroidManifest中注册才生效。
Activity可以创建菜单。首先在res/menu下创建一个xml文件（Android Studio中也提供了可视化编辑的方法）：
&amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;utf-8&amp;#34;?&amp;gt; &amp;lt;menu xmlns:app=&amp;#34;http://schemas.android.com/apk/res-auto&amp;#34; xmlns:android=&amp;#34;http://schemas.android.com/apk/res/android&amp;#34;&amp;gt; &amp;lt;item android:id=&amp;#34;@+id/add_item&amp;#34; android:title=&amp;#34;Add&amp;#34;/&amp;gt; &amp;lt;item android:id=&amp;#34;@+id/remove_item&amp;#34; android:title=&amp;#34;Remove&amp;#34;/&amp;gt; &amp;lt;/menu&amp;gt; 重写两个方法
override fun onCreateOptionsMenu(menu: Menu?): Boolean { menuInflater.inflate(R.menu.main, menu) return true } override fun onOptionsItemSelected(item: MenuItem): Boolean { when (item.itemId) { R.id.add_item -&amp;gt; Toast.makeText(this, &amp;#34;Add a book.&amp;#34;, Toast.LENGTH_LONG).show() R.id.remove_item -&amp;gt; Toast.makeText(this, &amp;#34;Remove a book.&amp;#34;, Toast.LENGTH_LONG).show() } return true } 用finish()方法可以关闭一个Activity。</description>
    </item>
    
    <item>
      <title>写产品和写demo的区别</title>
      <link>https://ntutn.top/posts/%E5%86%99%E4%BA%A7%E5%93%81%E5%92%8C%E5%86%99demo%E7%9A%84%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Tue, 15 Dec 2020 03:11:37 +0800</pubDate>
      
      <guid>https://ntutn.top/posts/%E5%86%99%E4%BA%A7%E5%93%81%E5%92%8C%E5%86%99demo%E7%9A%84%E5%8C%BA%E5%88%AB/</guid>
      <description>上次写的功能灰度报了几例crash，定位是我这里某个变量NPE了。
说实话，在Java中NPE是我们最常打交道的异常了，但Kotlin提供的类型机制下，NPE很少了。而这里出现NPE，其实是因为我认定在当前这个流程中这个变量不会为空——你总是要先弹出菜单再点击菜单项吧，所以用了data!!.id的方式使用。
这个变量被赋值的地方只有三处，不存在多线程问题，我想破脑袋也不知道哪里为空了。最后处理只得暂时加上判空，先不崩再说。
请教同事，同事说我这是还没有分清 写产品和写demo的区别 。
写产品和写demo的区别？仔细一想，的确有道理。『写demo』只要能跑通就行了，而写产品你是要为自己写的每一行代码负责的。我之前写过不少代码，但他们大概都算『写demo』。作业只要演示的时候不崩就行了，考试只要通过样例就行了，练手的项目写起来更是随心，反正自己就是用户，啥时候崩了啥时候debug，方便的很……
但『写产品』不同，你的程序不止要能完成需要的功能，还要在用户不按套路出牌的时候不出错。今天你迟到一分钟，咱班四十个学生等你一分钟就是一节课，你浪费了大家一节课时间…… 虽然这么算不对，但也不能算全错。你的产品面向千千万万用户，任何小瑕疵都可能放大成一场事故。记得那个著名的ATM机的bug，就是因为用户选择了取消，然后插入了银行卡……
回到我这个Issue，虽然从业务逻辑的角度看用户操作后这个变量是不会为null的，但仍然应该有判空，有兜底的逻辑，这样你的程序才会更加健壮。
Kotlin的空安全 与Java不同，Kotlin的类型系统在设计时就考虑了变量是否可空1，其用一个?表示变量是否能为空。
var a: String = &amp;#34;abc&amp;#34; // 默认情况下，常规初始化意味着非空 a = null // 编译错误 var b: String? = &amp;#34;abc&amp;#34; // 可以设置为空 b = null // ok print(b) 判空 Kotlin有一定的类型推断能力，判空后进行赋值操作前能识别出变量是非空的类型。
val b: String? = &amp;#34;Kotlin&amp;#34; if (b != null &amp;amp;&amp;amp; b.length &amp;gt; 0) { print(&amp;#34;String of length ${b.length}&amp;#34;) } else { print(&amp;#34;Empty string&amp;#34;) } 安全调用 Kotlin中提供了?.来安全调用一个可能为空的变量。b?.test()相当于if (b != null) b.test()。
值得注意的是，这个操作符是可以和赋值语句一起用的。如：</description>
    </item>
    
    <item>
      <title>android项目开发：项目结构</title>
      <link>https://ntutn.top/posts/%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84/</link>
      <pubDate>Tue, 08 Dec 2020 03:11:37 +0800</pubDate>
      
      <guid>https://ntutn.top/posts/%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84/</guid>
      <description>虽然已经在字节实习并拿到转正offer，但实际我自己感受我现在对安卓基础知识掌握的程度还差很多，感觉写业务代码本身并不能带来多少提升。
恰逢前两天看到黄正楠那里有一本看上去不错的书1，而在淘宝也在打折，就买了一本。
那么从Hello Wrold开始，先看看安卓项目的项目结构。
[TOC]
.gradle和.idea Android Studio自动生成的文件，无需关心。
app 项目中的代码、资源等内容。
build 编译时自动生成的文件，不需要关心。
libs 存放项目中的第三方jar包，这个目录下的jar包会自动添加到项目的构建路径下。
src androidTest Android Test测试用例，可以对项目进行一些自动化测试。
 实际上在公司里发现基本不写测试用例，全靠QA瞎几把点。
 test 用来编写单元测试用例，对项目进行自动化测试。
 这里的测试用例是不依赖安卓框架的。
 main java 存放所有java代码（和Kotlin代码）的地方。
res 项目的资源文件夹，项目中使用到的所有图片、布局、字符串等资源都存在这个目录下。
图片存放在drawable目录下，布局存放在layout目录下，字符串存放在values目录下。
mipmap存放图标，之所以有很多mipmap目录是为了适配各种设备。若只有一份图片，那么放在xxhdpi下就可以了。
AndroidManifest.xml 整个Android项目的配置文件，程序中定义的四大组件都需要在这个文件中注册。此外，还可以在这个文件中添加应用程序的权限声明。
.gitignore 类似外层的.gitignore，用来在版本控制系统中排除app模块中的指定文件。
build.gradle app模块的gradle构建脚本，指定很多项目构建相关的配置。
插件com.android.application用于应用程序模块，com.android.library表示库模块。前者可以直接运行，后者只能作为代码库依附于应用程序模块运行。
proguard-rules.pro 指定项目代码的混淆方式。
build 编译时自动生成的内容。
gradle gradle wrapper的配置文件。Android Studio会根据本地的缓存i去=情况决定是否需要联网下载gradle。
.gitignore 排除文件或文件夹的git版本控制。
 对于所有项目都会用到的.gitignore条目，不妨加入~/.gitignore全局配置。
 build.gradle 项目全局的构建脚本。
repositories中，google()对应谷歌自家代码仓库依赖，jcenter()中则是很多第三方开源库。
gradle.properties 全局gradle的配置文件。
gradlew和gradlew.bat 这两个文件是用来在命令行界面执行gradle命令的，其中gradlew是在Linux或Mac系统中使用的，gradlew.bat是在Windows系统中使用的。
local.properties 用于指定本机中的Android SDK路径。
settings.gradle 用来指定项目中所有引入的模块。
  《第一行代码》&amp;#160;&amp;#x21a9;&amp;#xfe0e;
   </description>
    </item>
    
    <item>
      <title>从QBASIC开始</title>
      <link>https://ntutn.top/posts/%E4%BB%8Eqbasic%E5%BC%80%E5%A7%8B/</link>
      <pubDate>Wed, 02 Dec 2020 03:11:37 +0800</pubDate>
      
      <guid>https://ntutn.top/posts/%E4%BB%8Eqbasic%E5%BC%80%E5%A7%8B/</guid>
      <description>{ &amp;#34;title&amp;#34;: &amp;#34;从QBASIC开始&amp;#34;, &amp;#34;author&amp;#34;: &amp;#34;归零幻想&amp;#34;, &amp;#34;publishTime&amp;#34;: &amp;#34;2020-12-02T03:11:37&amp;#34;, &amp;#34;editTime&amp;#34;: &amp;#34;2020-12-02T03:11:37&amp;#34;, &amp;#34;tags&amp;#34;: [ &amp;#34;BASIC&amp;#34;, &amp;#34;QBASIC&amp;#34;, &amp;#34;回忆&amp;#34;, &amp;#34;知乎&amp;#34; ], &amp;#34;targetFile&amp;#34;: &amp;#34;article/2.html&amp;#34;, &amp;#34;aliasFiles&amp;#34;: [ &amp;#34;QBASIC.html&amp;#34; ], &amp;#34;template&amp;#34;: &amp;#34;article&amp;#34; } 前两天看到一个知乎问题，拍了一张数学课本的截图，里面是一段程序，问如何才能运行这种程序。1
看到这熟悉的语法有些感慨，毕竟这门语言就是我编程入门学习的第一门语言了。
记得那时没有什么娱乐手段，只能翻翻我姐的旧书——当然多数看不懂。少数能看懂的，就包括一本QBASIC的编程入门教程。
单词不认识，字母总还是认识的。于是我学的Hello World其实是P-R-I-N-T-&amp;ldquo;H-E-L-L-O-W-O-R-L-D&amp;rdquo;。看着都觉得累…… 没有电脑，就直接在脑袋里推演，在纸上执行程序。家里人还以为我在学英语～
顺序、分支、循环，GOTO，随着开始学一点英语，更加体会到BASIC的语法的友好。
直到有一天，我爸下定决心办了5元30M的上网套餐，我终于也开始与现代信息世界接触了。有时去跟我爸到工厂干活，晚上回来很晚，我坐在摩托车的后座，熟练地摸出他的手机，打开浏览器上网，冷得受不了就换一只手。去QQ空间收个菜2，然后开始找BASIC教程。
啥？QBASIC已经是DOS时代的东西了？那现在都用什么写程序？哦，微软推出了Visual Basic，还声称只有你想不到的，没有VB做不到的。3我当时就不乐意了，你VB能出来帮我写作业吗？然而转念一想，这也能辩解说是你没想到让他出来帮写作业的方法。好吧，这逻辑无敌了。
吐槽归吐槽，看到VB的语法，还是熟悉的配方，还是原来的味道。那就学VB吧。于是QB入门教程吃透后连一行代码都没有写（不算在纸上写），就开始学VB了。VB也是直到我姐大学，买了笔记本，在她回家的时候，才开始真正在IDE里面实际运行。
这段时期我还接触了有斯凯的mrp应用。起因是有人看到说手机上不只是能装QQ，还能装一些别的软件、游戏。只是这个入口在很多手机上隐藏了。
对照着网上的提示，我试着在手机上输入指令4，成功弹出来那个界面，我那时是非常激动了。
mrp应用对我的影响不小，接触了很多优秀的作品，现在我还隐约有印象的还有 冒泡音乐、 劲舞团 、 雷神之锤 等。 甚至后来流行的水果忍者的低配版在这上面都有移植。
当时的QQ在这上面一共有三个版本，QQ2008、QQ2009和QQ2010。其中QQ2008甚至都不支持以2开头的10位QQ号。腾讯估计当时也没想到现在QQ用户会有这么多吧。那时腾讯还在这个平台上推出过自己的QQ浏览器，一度是国产山寨手机最好用的浏览器之一5。
记得当时还发生过令人非常担心的事情：mrp大神“默水瓶”删除了自己网站上的全部内容并留下一段话，大意是说自己已经坚持不下去了，一个人在出租屋里，没有钱，也没有朋友。 9月1日，要么去上学，要么去死。 从此这个ID就消失在互联网上了，再后来连这段话也被海量的信息淹没。很多人在论坛表示愿意提供帮助，愿意成为他的朋友。他没有回复， 希望他看到了吧。
再后来安卓就打入中国了。斯凯大概错过了一个很好的发展时机吧。
离开mrp的话题，当我来到大学，我发现我学习的VB其实也是过时的，后来微软转向了.net，又开始学了一点VB.net。然后VB.net虽然不至于过时，但在国内.net开发基本都是C#的，VB找不到工作的。算了，老子不学了， 微软真是一个很擅长杀死自己产品的公司 ，咱跟不起。
不过VB也没白学，至少VBA和VBS还用得到。比如可以写个软件启动器，或者写过恶作剧整蛊我的朋友们。啊，后来只要是我发的文件，就算是txt后缀他们都不敢打开……
下面哪些文件是安全的？
看片神器.exe baidu.com 屏保line.scr 百度阿里腾讯.bat command.cmd story.vbs gift.vbe 好吧，这些都不怎么安全，你知道为什么吗？
  请问像这种程序可以用什么软件操作? - 知乎&amp;#160;&amp;#x21a9;&amp;#xfe0e;
 纯文字版QQ农场，点超链接收菜等操作，记得当时腾讯还用这个推广过自己QQ浏览器，省流量，能“一键收菜”。&amp;#160;&amp;#x21a9;&amp;#xfe0e;</description>
    </item>
    
    <item>
      <title>B站的搬运机制和盗视频行为有区别吗</title>
      <link>https://ntutn.top/posts/b%E7%AB%99%E7%9A%84%E6%90%AC%E8%BF%90%E6%9C%BA%E5%88%B6%E5%92%8C%E7%9B%97%E8%A7%86%E9%A2%91%E8%A1%8C%E4%B8%BA%E6%9C%89%E5%8C%BA%E5%88%AB%E5%90%97/</link>
      <pubDate>Tue, 24 Nov 2020 03:11:37 +0800</pubDate>
      
      <guid>https://ntutn.top/posts/b%E7%AB%99%E7%9A%84%E6%90%AC%E8%BF%90%E6%9C%BA%E5%88%B6%E5%92%8C%E7%9B%97%E8%A7%86%E9%A2%91%E8%A1%8C%E4%B8%BA%E6%9C%89%E5%8C%BA%E5%88%AB%E5%90%97/</guid>
      <description>在知乎看到这样的问题1，写下我的观点，也同步写到这里。
 『搬运』同『转载』，『盗视频』特指『无授权转载视频』并隐含指『借此获得收益』。
  b站用户被指责双标， 最大的锅是b站而不是up主 。
b站没有明显区分转载作品和原创作品，在我看来就是享受了转载内容带来的红利又想规避因此带来的舆论和法律问题。
 如何判断视频是转载的还是原创的？你看这里它只能投一个币这是搬运的。
 收益  『搬运』视频是不能获得收益的。 很大程度这与是否获得授权无关，甚至与界定是否『商业使用』无关。up主没有获得收益，但显而易见b站是有收益的。比如一篇文章，转载到我的个人博客大概可以算非商业使用，因为博客中 没有任何广告，没有打赏或捐赠选项，没有对任何产品的商业宣传。
 当然这一点不是up主的锅，但至少 请收起『搬运是给你免费做宣传』的说辞。
授权问题 『转载』行为是应当获取授权的，退一步讲至少是应当标明出处的。b站自己产生的内容默认会标注『禁止转载』，但大多网站不会有明显标注，所以给转载者留下余地，有人认为未标注默认应该是允许转载。在我看来这一点是不成立的，至少 在github，如果一个项目没有任何LICENSE说明和文件，应该被理解为保留授权 ，即使大多数情况只是作者忘了。
标注出处 转载应标注出处，如何才算『标注出处』呢？很多视频中一句『来自Youtube』就算标注了出处了，标题还是翻译后的，你根据这句话能找到来源？
即使标注了出处，基本上也只能写在视频的简介中。很多人不习惯看视频简介，尤其是b站还会默认折叠比较长的简介。 还是b站的锅
我认为，合适的转载应该明显标出作品来源，并 至少要提供出足以找到来源作品的信息 。书籍杂志没办法，但对于互联网的文章，提供来源链接才算诚意。当然有些平台带超链接会无法过审，那可以再做权衡。
倡议   对于内容创作者，顺手标注是否允许转载，比如我在自己博客标注了『在未另行说明的情况下，本站内容遵守 署名-相同方式共享 4.0 国际 (CC BY-SA 4.0)』 ，这样非商业转载就无须另外询问我的意见了。
  对于转载内容的人，建议在来源未写明是否授权转载的情况下，主动向原作者申请授权。知乎曾经流行过『来自网络，侵删』式的标注，虽然也表达了态度，但实际上并不能规避因此带来的侵权法律风险。能找到作者情况下，申请授权才是正理。
  对于用户，自觉抵制不标注出处甚至不标注『转载』的转载内容。
    B站的搬运机制和盗视频行为有区别吗？ - 知乎&amp;#160;&amp;#x21a9;&amp;#xfe0e;
   </description>
    </item>
    
    <item>
      <title>android项目开发：多线程编程</title>
      <link>https://ntutn.top/posts/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/</link>
      <pubDate>Fri, 21 Aug 2020 03:11:37 +0800</pubDate>
      
      <guid>https://ntutn.top/posts/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/</guid>
      <description>仍然是《第一行代码》的笔记，不过略过了deprated的内容，并探究了下Handler的工作机制。
 上班了，果然没有那么多大块时间写博客了。
 Handler 主线程不能进行耗时处理，子线程不能访问UI，所以我们需要异步消息处理机制。
使用 class MainActivity : AppCompatActivity() { private lateinit var binding: ActivityMainBinding private val handler = object : Handler(Looper.getMainLooper()) { override fun handleMessage(msg: Message) { when(msg.what){ MSG_UPDATE_TEXT -&amp;gt; binding.textView.text = &amp;#34;Nice to meet you. &amp;#34; } } } override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) binding = ActivityMainBinding.inflate(layoutInflater) setContentView(binding.root) initView() } private fun initView() { binding.apply { changeTextButton.setOnClickListener { thread { val msg = Message() msg.what = MSG_UPDATE_TEXT handler.</description>
    </item>
    
    <item>
      <title>EventBus初探</title>
      <link>https://ntutn.top/posts/eventbus%E5%88%9D%E6%8E%A2/</link>
      <pubDate>Fri, 21 Aug 2020 03:11:37 +0800</pubDate>
      
      <guid>https://ntutn.top/posts/eventbus%E5%88%9D%E6%8E%A2/</guid>
      <description>公司项目中大量运用了EventBus1，这两天在做的需求相关的代码也用到了，于是还是要先去研究下这个EventBus是什么。
EventBus，顾名思义，事件总线，是一个安卓上的事件管理平台。用事件驱动的机制来简化事件传递的逻辑。在这层意义上也许可以类比Qt的信号槽机制，或者安卓的广播。当你需要把一个事件传递给多个对象，EventBus就变得非常有用。
该图片来自EventBus的github仓库
EventBus的使用 首先当然是添加依赖
implementation &amp;#39;org.greenrobot:eventbus:3.2.0&amp;#39; 写个demo展示下：
点击按钮后，将两处文本的值修改为文本框中的值。注意：上面的那个红色的文本处于一个fragment中。
为此，我们先准备一个Event：
data class ButtonEvent(val text: String) 点击按钮时，发送这个Event：
button.setOnClickListener { EventBus.getDefault().post(ButtonEvent(editTextTextPersonName.text.toString())) } 然后在需要接收这个请求的地方，比如我们在MainActivity的onCreate()中注册EventBus：
EventBus.getDefault().register(this) 在onDestory()中解除
EventBus.getDefault().unregister(this) 然后就可以接收那个Event了。
@Subscribe fun onButtonEvent(buttonEvent: ButtonEvent){ textView.text=buttonEvent.text } 同样对于Fragment，我们只需要做同样的事情，就可以监听这个Event了。很明显，这对于一个事件有多个处理的场景是很方便的。
订阅者的threadMode 安卓应用启动时，系统会创建一个主线程，负责向UI组件分发事件2，所有对UI的操作应该放到主线程中。EventBus是一种重要的跨线程更新UI的方式。3
@Subscribe注解有一个参数threadMode，有以下取值：
ThreadMode.POSTING 默认值，在同一线程中调用，开销最小。
ThreadMode.MAIN 在主线程中调用。
 如果发送事件的是主线程，则直接调用。
 ThreadMode.MAIN_ORDERED 在主线程中调用，同步调用（排队）。
ThreadMode.BACKGROUND 在后台线程中调用。
ThreadMode.ASYNC 在单独线程中调用，用于耗时操作。
对于EventBus更新UI，我同样写了demo：
package com.example.eventbustimerdemo import android.os.Bundle import androidx.appcompat.app.AppCompatActivity import kotlinx.android.synthetic.main.activity_main.* import org.greenrobot.eventbus.EventBus import org.greenrobot.eventbus.Subscribe import org.greenrobot.eventbus.ThreadMode class MainActivity : AppCompatActivity() { override fun onCreate(savedInstanceState: Bundle?</description>
    </item>
    
    <item>
      <title>掉坑的日常：springboot的json属性名大小写问题</title>
      <link>https://ntutn.top/posts/%E6%8E%89%E5%9D%91%E7%9A%84%E6%97%A5%E5%B8%B8springboot%E7%9A%84json%E5%B1%9E%E6%80%A7%E5%90%8D%E5%A4%A7%E5%B0%8F%E5%86%99%E9%97%AE%E9%A2%98/</link>
      <pubDate>Tue, 24 Mar 2020 03:11:37 +0800</pubDate>
      
      <guid>https://ntutn.top/posts/%E6%8E%89%E5%9D%91%E7%9A%84%E6%97%A5%E5%B8%B8springboot%E7%9A%84json%E5%B1%9E%E6%80%A7%E5%90%8D%E5%A4%A7%E5%B0%8F%E5%86%99%E9%97%AE%E9%A2%98/</guid>
      <description>这两天想给自己小组的项目添加一个自动升级功能。这事听着复杂，但毕竟是个很常见的功能，github上的轮子很多。经过考虑，我决定选择这个组件，然后自己写后端。反正后端就返回一个json的事。然后就掉了坑。
起因 案发现场没什么好说的，就是我发现自己设置的不能实现升级，在客户端调试半天发现用官方的json能升级。然后我就找我的json和官方的json有什么区别，看ContentType也没设置错，仔细比对发现属性大小写竟然不对。我当时还挺惊讶的，毕竟是直接复制的。
springboot可以使用@ResponseBody返回对象自动转换json，而转换成的json属性名首字母会被转换成小写。
解决方案 引入fastjson &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;com.alibaba&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;fastjson&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.2.66&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; 注入bean @Bean public HttpMessageConverters httpMessageConverters() { FastJsonHttpMessageConverter fastJsonHttpMessageConverter = new FastJsonHttpMessageConverter(); // 添加fastJson的配置信息  FastJsonConfig fastJsonConfig = new FastJsonConfig(); fastJsonConfig.setSerializerFeatures(SerializerFeature.PrettyFormat); // 处理中文乱码问题  List&amp;lt;MediaType&amp;gt; fastMediaTypes = new ArrayList&amp;lt;&amp;gt;(); fastMediaTypes.add(MediaType.APPLICATION_JSON); // 在convert中添加配置信息.  fastJsonHttpMessageConverter.setSupportedMediaTypes(fastMediaTypes); fastJsonHttpMessageConverter.setFastJsonConfig(fastJsonConfig); HttpMessageConverter&amp;lt;?&amp;gt; converter = fastJsonHttpMessageConverter; return new HttpMessageConverters(converter); } 在属性上加注解 package edu.upc.mishuserver.vo; import com.alibaba.fastjson.annotation.JSONField; import lombok.AllArgsConstructor; import lombok.Builder; import lombok.Data; import lombok.NoArgsConstructor; /** * UpdateInfo */ @Data @AllArgsConstructor @NoArgsConstructor @Builder public class UpdateInfo { @JSONField(name=&amp;#34;Code&amp;#34;) private Long code; @JSONField(name = &amp;#34;Msg&amp;#34;) private String msg; @JSONField(name = &amp;#34;UpdateStatus&amp;#34;) private Integer updateStatus; @JSONField(name = &amp;#34;VersionCode&amp;#34;) private Long versionCode; @JSONField(name = &amp;#34;VersionName&amp;#34;) private String versionName; @JSONField(name = &amp;#34;ModifyContent&amp;#34;) private String modifyContent; @JSONField(name = &amp;#34;DownloadUrl&amp;#34;) private String downloadUrl; @JSONField(name = &amp;#34;ApkSize&amp;#34;) private Long apkSize; @JSONField(name = &amp;#34;ApkMd5&amp;#34;) private String apkMd5; } </description>
    </item>
    
    <item>
      <title>Typora&#43;git自动同步你的笔记</title>
      <link>https://ntutn.top/posts/typora&#43;git%E8%87%AA%E5%8A%A8%E5%90%8C%E6%AD%A5%E4%BD%A0%E7%9A%84%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Mon, 02 Mar 2020 03:11:37 +0800</pubDate>
      
      <guid>https://ntutn.top/posts/typora&#43;git%E8%87%AA%E5%8A%A8%E5%90%8C%E6%AD%A5%E4%BD%A0%E7%9A%84%E7%AC%94%E8%AE%B0/</guid>
      <description>这两天看了群里某个大佬的笔记，突然觉得自己用VSCode记笔记的方案不香了。VSCode虽然对markdown的支持不错，但毕竟本职工作不是这个，直接拿来做笔记还是不够方便，太笨重了。于是我终于想起之前同学给我安利的markdown编辑器：Typora。
dalao的笔记 首先看看大佬的笔记：
好想去偷他的笔记。不过话说他这笔记软件也不错啊，看起来简约清晰，我也有试一试的想法了。
他用的笔记软件：https://github.com/tsujan/FeatherNotes
然后就被编译安装劝退了。一个是不太想这么折腾，另一个是这个软件没有提供编译好的包，感觉还是不够放心啊，毕竟如果以后开发者不维护了要再折腾一遍会非常麻烦。
Typora，同学安利的markdown编辑工具 与多数markdown编辑工具不同，Typora是所见即所得的markdown编辑工具。为什么程序员偏爱markdown？就是因为markdown可以让我们写作的时候只关注内容本身，而不用太在意排版的问题。而Typora又改变了传统的左右分栏或者点击切换预览的传统markdown编辑模式，用起来就更舒服了。
安装 在Ubuntu下安装还是非常方便的：
# or run: # sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys BA300B7755AFCFAE wget -qO - https://typora.io/linux/public-key.asc | sudo apt-key add - # add Typora&amp;#39;s repository sudo add-apt-repository &amp;#39;deb https://typora.io/linux ./&amp;#39; sudo apt-get update # install typora sudo apt-get install typora 其他系统参考官网。
复制图片 不过有一点要注意：我们写文档常常要插入一些图片，为了后面和git好配合，我们需要将这些图片也放到当前文件夹里。按下Ctrl+逗号打开设置，将图片复制到当前文件夹下。如图。
重要的快捷键 都是重点等于没有重点。我们只要记住能让我们离开鼠标提高效率的就行了。
   快捷键 功能     Ctrl+S 保存   Ctrl+Z 撤销   Ctrl+Y 重做   Ctrl+Shift+L 侧边栏   Ctrl+/ 切换源代码模式   表格中，Ctrl+Enter 添加一行    用git管理笔记 首先什么是git？有些少年区分不了git和github，这是姿势水平还不够啊。听说过GitLab没？听说过码云没？不是修福报的那个马云哦。</description>
    </item>
    
    <item>
      <title>Java自动装箱自动拆箱踩坑</title>
      <link>https://ntutn.top/posts/java%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1%E8%87%AA%E5%8A%A8%E6%8B%86%E7%AE%B1%E8%B8%A9%E5%9D%91/</link>
      <pubDate>Sun, 01 Mar 2020 03:11:37 +0800</pubDate>
      
      <guid>https://ntutn.top/posts/java%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1%E8%87%AA%E5%8A%A8%E6%8B%86%E7%AE%B1%E8%B8%A9%E5%9D%91/</guid>
      <description>int和Integer有什么区别？前者是基础数据类型，后者是封装的Java对象。但在有Autoboxing和Unboxing的情况下我们常常就把两者等同看待，无非后者能放null。
事情要首先从一道力扣题目说起：
删除排序数组中的重复项 II 给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素最多出现两次，返回移除后数组的新长度。
不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。
示例 1: 给定 nums = [1,1,1,2,2,3], 函数应返回新长度 length = 5, 并且原数组的前五个元素被修改为 1, 1, 2, 2, 3 。 你不需要考虑数组中超出新长度后面的元素。 示例 2: 给定 nums = [0,0,1,1,1,1,2,3,3], 函数应返回新长度 length = 7, 并且原数组的前五个元素被修改为 0, 0, 1, 1, 2, 3, 3 。 你不需要考虑数组中超出新长度后面的元素。
Answer 针对这个题目，我写出了这样的代码：
/* * @lc app=leetcode.cn id=80 lang=java * * [80] 删除排序数组中的重复项 II */ // @lc code=start class Solution { public int removeDuplicates(int[] nums) { int l = 0, r = 0; int ans1 = Integer.</description>
    </item>
    
    <item>
      <title>记Lenovo V310 15 IKB的第n次死机</title>
      <link>https://ntutn.top/posts/%E8%AE%B0lenovo_v310_15_ikb%E7%9A%84%E7%AC%ACn%E6%AC%A1%E6%AD%BB%E6%9C%BA/</link>
      <pubDate>Wed, 01 Jan 2020 03:11:37 +0800</pubDate>
      
      <guid>https://ntutn.top/posts/%E8%AE%B0lenovo_v310_15_ikb%E7%9A%84%E7%AC%ACn%E6%AC%A1%E6%AD%BB%E6%9C%BA/</guid>
      <description>今天我的电脑又死机了，首先切一下tty进不去，然后试下SysRq键没反应，熟练地按住电源10秒，松开两秒，再按一下，拿出手机刷会空间。
这电脑刚买的时候给我的印象其实是不错的，虽然外壳线条有点丑粗犷，但整体性能比我预期要好很多。i5的CPU，1T机械硬盘，入门级Radeon独显，毕竟价格摆在那里。
因为没有固态硬盘，这电脑慢的很，但我安慰自己反正我也不怎么打游戏。日常尽量不用UWP应用，开机刷会手机，佛系一点也没什么不好。谁说学软件就一定要用好电脑？Code Blocks不香吗？eclipse有几个电脑带不动？实在偶尔想配置安卓开发环境的时候就连自己安卓手机做测试，至于VS就不用想了，虽然号称世界上最好用的IDE，但比较新的版本没有固态硬盘反应跟不上打字……
本来也就这样了，一分钱一分货的事。但直到某次电脑毫无征兆死机……
死机是正常现象，没什么好怕的。我这样告诉自己。我当时正在浏览网页不要多想，不是那种满屏都是澳门首家线上赌场广告的网页，毫无征兆就死机了。一般来说，所谓死机多是资源占用过高系统失去响应的原因，根据自己的经验，按组合键尝试调出任务管理器尝试结束进程，然后没有成功。貌似死机很彻底，任务管理器根本无法调出，甚至鼠标都不能动。我放下电脑，看了集哆啦A梦，回头看电脑屏幕没有要变化的征兆。没办法，按住电源键强制关机吧。后面很久这个事情都没有再出现，我也就渐渐忘了。
直到又有一天，在我玩《狂野飙车8：极速凌云》正高兴的时候，画面突然不动了。这扫兴的事让我没了继续玩的兴致，而后几天又死机几次，我觉得事情没有那么简单，在网上搜索时，我发现我这不是个例。
之后我加固态硬盘装双系统，死机就跟着我到了ubuntu。一般来说，ubuntu死机多是指gnome卡死，直接Alt+F2输入r就能重启，不这样做也可以切tty进入命令操作，直到某次放歌的时候死机了，歌声都停了，别说tty了，连SysRq键都没能正常工作，这表明连linux内核都死掉了。好吧，现在有足够证据表明死机不是Windows的锅。
想把电脑送去修，但很麻烦的是，这个问题复现很困难，死机是不定期的，似乎跟资源占用无关，跟电脑温度无关。先不考虑电脑店能不能找到原因，就算电脑店说修好了，我也没办法验证。我觉得就这样送去修最大可能就算店家给你重装了下系统，清了下灰，升级了下BIOS，这些我都试过了没有用。
后来一直没有解决这件事，只是我养成了随手Ctrl+S的习惯。
不管怎样，今天偶发性的连续死机两次惹恼我了，联想会进我的黑名单。</description>
    </item>
    
    <item>
      <title>计算机操作系统原理笔记</title>
      <link>https://ntutn.top/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Tue, 10 Dec 2019 03:11:37 +0800</pubDate>
      
      <guid>https://ntutn.top/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/</guid>
      <description>操作系统快考试了，我觉得自己过应该还是没问题的吧，毕竟也有认真听课。虽然对某些部分流程记忆有点发憷。
操作系统做什么 操作系统是用户与计算机硬件之间的接口 用户 指包括最终用户在内的各级用户。
操作系统的发展 微机操作系统 个人机操作系统。
实时操作系统 支持实时计算的系统，实时计算即 系统的正确性不仅取决于计算的逻辑结果，而且还依赖于产生结果的时间。
实时任务的类型
 周期性实时任务 非周期性实时任务 硬实时任务 软实时任务   实时计算机可以不运行实时操作系统，直接运行应用软件
  高可用性 截止时间  开始截止时间 实际截止时间    单道批处理系统  自动性 顺序性 单道性  优点
减少人工等待时间
缺点
 作业独占CPU CPU等待IO使得CPU利用率低  多道批处理系统  多道性 无序性 调度性 复杂性  优点
 提高CPU利用率 提高内存和IO利用率 增加系统吞吐量   吞吐量：单位时间里系统处理的作业量 缺点
  平均等待周期长 缺乏交互能力  分时系统  多路性 独立性 及时性 交互性  优点</description>
    </item>
    
    <item>
      <title>三门问题</title>
      <link>https://ntutn.top/posts/%E4%B8%89%E9%97%A8%E9%97%AE%E9%A2%98/</link>
      <pubDate>Mon, 16 Sep 2019 03:11:37 +0800</pubDate>
      
      <guid>https://ntutn.top/posts/%E4%B8%89%E9%97%A8%E9%97%AE%E9%A2%98/</guid>
      <description>参赛者面前有三扇关闭着的门，其中一扇的后面是一辆汽车，选中后面有车的那扇门就可以赢得该汽车， 而另外两扇门后面则各藏有一只山羊。当参赛者选定了一扇门，但未去开启它的时候，主持人会开启剩 下两扇门中的一扇，露出其中一只山羊。主持人其后会问参赛者要不要更换选择，选另一扇仍然关着的门。
 那么，应不应该更换呢？   分析 假如你选择了A，那你中奖概率应为1/3.
主持人在B、C中选了个没奖的，这与你的选择其实没影响，因为你没选的肯定有个没奖的。
换与不换其实就相当于问你选A还是不选A。
程序模拟 有点绕，咱学软件的，就干脆让电脑跑一跑。
代码 import java.util.Random; class Test{ public static void main(String[] args) { Random ran=new Random(); int c1=0,c2=0; for(int i=0;i&amp;lt;1e6;i++){ boolean boxes[]={false,false,false}; boxes[ran.nextInt(boxes.length)]=true;//某个门后有奖  int sel=ran.nextInt(boxes.length);//随便选择一扇门  int p=0; while(p==sel||boxes[p]){//主持人选择一扇没奖的门（且不与参与者选同一扇）  p=ran.nextInt(boxes.length); } if(boxes[sel]){//不更换中奖  c1++; } if(boxes[0+1+2-sel-p]){//更换中奖  c2++; } } System.out.println(c1/1e6); System.out.println(c2/1e6); } } 运行结果 0.332419 0.667581 看来是更换比较好了。</description>
    </item>
    
    <item>
      <title>大型数组按行遍历与按列遍历的区别</title>
      <link>https://ntutn.top/posts/%E5%A4%A7%E5%9E%8B%E6%95%B0%E7%BB%84%E6%8C%89%E8%A1%8C%E9%81%8D%E5%8E%86%E4%B8%8E%E6%8C%89%E5%88%97%E9%81%8D%E5%8E%86%E7%9A%84%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Mon, 16 Sep 2019 03:11:37 +0800</pubDate>
      
      <guid>https://ntutn.top/posts/%E5%A4%A7%E5%9E%8B%E6%95%B0%E7%BB%84%E6%8C%89%E8%A1%8C%E9%81%8D%E5%8E%86%E4%B8%8E%E6%8C%89%E5%88%97%E9%81%8D%E5%8E%86%E7%9A%84%E5%8C%BA%E5%88%AB/</guid>
      <description>今天这学期开学第一天，上了《计算机操作系统原理》，老师提出个问题
 对于一个很大的数组（如70000×70000），按行遍历速度快还是按列遍历快，为什么？
 乍一看，程序时间复杂度一样，理论上不是应该一样快吗？难道老师在钓鱼？
实践出真知，我们就写个程序跑一跑。
程序  70000×70000我电脑在默认情况下开不下，我这里用20000×20000测试
 按行遍历 /** * M1 */ public class M1 { public static void main(String[] args) { final int N=20000; int[][] a = new int[N][N]; Long start=System.currentTimeMillis(); for(int i=0;i&amp;lt;N;i++){ for (int j = 0; j &amp;lt; N; j++) { a[i][j]=1; } } Long stop=System.currentTimeMillis(); System.out.println(stop-start); } } 按列遍历 /** * M2 */ public class M2 { public static void main(String[] args) { final int N=20000; int[][] a = new int[N][N]; Long start=System.</description>
    </item>
    
    <item>
      <title>闷声作大死：删除电脑内的空文件夹</title>
      <link>https://ntutn.top/posts/%E9%97%B7%E5%A3%B0%E4%BD%9C%E5%A4%A7%E6%AD%BB%E5%88%A0%E9%99%A4%E7%94%B5%E8%84%91%E5%86%85%E7%9A%84%E7%A9%BA%E6%96%87%E4%BB%B6%E5%A4%B9/</link>
      <pubDate>Sun, 16 Jun 2019 03:11:37 +0800</pubDate>
      
      <guid>https://ntutn.top/posts/%E9%97%B7%E5%A3%B0%E4%BD%9C%E5%A4%A7%E6%AD%BB%E5%88%A0%E9%99%A4%E7%94%B5%E8%84%91%E5%86%85%E7%9A%84%E7%A9%BA%E6%96%87%E4%BB%B6%E5%A4%B9/</guid>
      <description>电脑卸载软件时，卸载程序常常不会把程序对应的空文件夹删掉，一般这时候我都是手动去把他删掉。
我觉得有点麻烦，又想到电脑内可能还有其他的空文件夹。于是在网上找了个脚本删除电脑内的空文件夹，然后就遇到了麻烦……
也许本文标题应该是一个空文件夹引发的血案……
删除电脑内的空文件夹 本来我曾经写过一个C#版本的删除电脑空文件夹的工具，原理很简单，就是递归嘛：
但是这程序执行比较慢，而且占用内存不少……
在网上搜索了下，果然不能闭门造车啊，有大佬写过批处理：
for /f &amp;#34;tokens=*&amp;#34; %%a in (&amp;#39;dir /b /ad /s C:\^|sort /r&amp;#39;) do rd &amp;#34;%%a&amp;#34; /q 2&amp;gt;nul 试用了下，效果相当不错。于是稍微修改使它能申请管理员权限，顺便修改下控制台颜色，看上去炫一点：
title 删除空文件夹 color 03 echo 程序需要管理员权限…… set /a _Debug=0 ::========================================== :: 获取管理员权限 set _Args=%* if &amp;#34;%~1&amp;#34; NEQ &amp;#34;&amp;#34; ( set _Args=%_Args:&amp;#34;=% ) fltmc 1&amp;gt;nul 2&amp;gt;nul || ( cd /d &amp;#34;%~dp0&amp;#34; cmd /u /c echo Set UAC = CreateObject^(&amp;#34;Shell.Application&amp;#34;^) : UAC.ShellExecute &amp;#34;cmd.exe&amp;#34;, &amp;#34;/k cd &amp;#34;&amp;#34;%~dp0&amp;#34;&amp;#34; &amp;amp;&amp;amp; &amp;#34;&amp;#34;%~dpnx0&amp;#34;&amp;#34; &amp;#34;&amp;#34;%_Args%&amp;#34;&amp;#34;&amp;#34;, &amp;#34;&amp;#34;, &amp;#34;runas&amp;#34;, 1 &amp;gt; &amp;#34;%temp%\GetAdmin.</description>
    </item>
    
    <item>
      <title>在Windows10上安装血战上海滩</title>
      <link>https://ntutn.top/posts/%E5%9C%A8windows10%E4%B8%8A%E5%AE%89%E8%A3%85%E8%A1%80%E6%88%98%E4%B8%8A%E6%B5%B7%E6%BB%A9/</link>
      <pubDate>Sat, 01 Jun 2019 03:11:37 +0800</pubDate>
      
      <guid>https://ntutn.top/posts/%E5%9C%A8windows10%E4%B8%8A%E5%AE%89%E8%A3%85%E8%A1%80%E6%88%98%E4%B8%8A%E6%B5%B7%E6%BB%A9/</guid>
      <description>《血战上海滩》是由北京欢乐亿派科技有限公司开发的单机FPS游戏，发行于2003年，是一个非常经典的老游戏了。 近来我打算把这个游戏找出来再玩一遍，可是在Windows10上安装还是有些问题……
下载 下载不用多说，自己找资源吧，一共三百多兆的单机游戏。
 现在很多单机游戏下载时网站都会给你带上一个“启动器”来显示广告，恶心的很。找到文件夹中，注意血战上海滩的游戏文件是一个帽子的图标，大小为1.87M，SHA1为FE5A102AA9DE633FB6E388EAAEEA38BC43E8E7E4
 启动 直接双击exe，然后……它免费帮你调了一下分辨率，就没反应了。
貌似兼容性是个比较大的问题……于是在网上找了好久，终于知道，可以用命令行控制游戏窗口运行：
shanghai.exe -windows 修改屏幕分辨率实现全屏 倒是能运行了，只是……画面都在左上角，没法玩啊……
所以再加上自动修改屏幕分辨率就可以全屏了。修改屏幕分辨率可以用setres
下载链接下载并将exe文件放到血战上海滩的游戏文件夹。
于是用下面的命令：
setres h800 v600 shanghai.exe -windows setres h1920 v1080 1920*1080是我电脑的屏幕分辨率，注意换成自己的。
隐藏显示任务栏 然而，这样还是有问题，就是这样“全屏”后任务栏并没有消失，虽然可以设置自动隐藏任务栏但总归还是不爽，于是写了个简单C#程序在启动游戏隐藏任务栏（虽然很简单，但没找到只用命令实现的方法）
using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; using System.Runtime.InteropServices; namespace ShowTaskBar { class Program { private const int SW_HIDE = 0; //隐藏任务栏  private const int SW_RESTORE = 9;//显示任务栏 [DllImport(&amp;#34;user32.dll&amp;#34;)] public static extern int ShowWindow(int hwnd, int nCmdShow); [DllImport(&amp;#34;user32.dll&amp;#34;)] public static extern int FindWindow(string lpClassName, string lpWindowName); static void Main(string[] args) { ShowWindow(FindWindow(&amp;#34;Shell_TrayWnd&amp;#34;, null), SW_HIDE); } } } using System; using System.</description>
    </item>
    
    <item>
      <title>数据结构第三次测试</title>
      <link>https://ntutn.top/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%89%E6%AC%A1%E6%B5%8B%E8%AF%95/</link>
      <pubDate>Sat, 01 Jun 2019 03:11:37 +0800</pubDate>
      
      <guid>https://ntutn.top/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%89%E6%AC%A1%E6%B5%8B%E8%AF%95/</guid>
      <description>数据结构测试，树部分，水题
 一 假设二叉树的数据元素为字符，采用二叉链式存储结构。二叉树ADT实现的大部分代码已经给出，其中采用完全前序序列创建二叉树。请补充写出下列两个操作函数。
 注意： 答案区只写出两个函数，其他代码不允许修改和重写、提交！
  计算以某结点为根的二叉树的高度； 以前序顺序输出各个元素结点为根的子树的高度；  例如：有如右图的二叉树 输入 ABD@@E@@C@F@@ 输出 Height(A)=3 Height(B)=2 Height(D)=1 Height(E)=1 Height(C)=2 Height(F)=1 已给出的代码如下：
#include &amp;lt;iostream&amp;gt;#include &amp;lt;stdlib.h&amp;gt;using namespace std; //数据元素类型 typedef char ElemType; //二叉树结点定义 typedef struct TreeNode {	ElemType data; struct TreeNode *lson, *rson; } TreeNode; //二叉树类 class BinaryTree { private: TreeNode *root; public: BinaryTree() { root = NULL; }; ~BinaryTree() { MakeEmpty(root); } void MakeEmpty(TreeNode *t); void create( ) { root = cp_create(root); }; //完全前序建立二叉树，空指针用@表示 	TreeNode *cp_create(TreeNode *t); //****** 要补充的函数height ******** 	int height(TreeNode *t) ; //求二叉树的高度 	void output() { Pro_height(root); }; //****** 要补充的函数 Pro_height ********** 	void Pro_height(TreeNode *t); // 前序顺序输出各个元素结点为根的子树的高度 }; //二叉树置空 void BinaryTree::MakeEmpty(TreeNode *t) {	if (t !</description>
    </item>
    
    <item>
      <title>稀疏矩阵的压缩存储</title>
      <link>https://ntutn.top/posts/%E7%A8%80%E7%96%8F%E7%9F%A9%E9%98%B5%E7%9A%84%E5%8E%8B%E7%BC%A9%E5%AD%98%E5%82%A8/</link>
      <pubDate>Sat, 01 Jun 2019 03:11:37 +0800</pubDate>
      
      <guid>https://ntutn.top/posts/%E7%A8%80%E7%96%8F%E7%9F%A9%E9%98%B5%E7%9A%84%E5%8E%8B%E7%BC%A9%E5%AD%98%E5%82%A8/</guid>
      <description>特殊矩阵在采用二维数组存储时，尽管矩阵操作的算法都很简单，但是其空间的利用率很低。 系数矩阵就是一种应用很广泛的特殊的矩阵。现要求稀疏矩阵采用“压缩”存储，实现矩阵的常用操作，如输出、转置、求和等。
Question 矩阵采用“压缩”存储，实现矩阵的常用操作，如输出、转置、求和等。
矩阵的输入：有多行，第1行包括三个整数，分别是矩阵的大小m,n及非零元素的个数r。后面r行分别输入各个非零元素的 行、列、值
矩阵的输出：按人们习惯的矩阵格式输出，即输出一个m*n的矩阵，是零元素的输出0，非零元素输出元素值。
例如：输入如下：
100 90 5 //矩阵的行数为100，列数为90，共5个非零元素。 1 10 100 //a(1,10)=100 50 60 200//a(50,60)=200 50 80 100//a(50,80)=100 60 60 200//a(60,60)=200 99 89 10//a(99,89)=10 100 90 4 //矩阵b的行数为100，列数为90，共4个非零元素。 1 1 10 //b(1,1)=10 50 60 -200//b(50,60)=-200 50 80 100 //b(50,80)=100 70 70 10 //b(70,70)=10 Example Input 100 90 5 1 10 100 50 60 200 50 80 100 60 60 200 99 89 10 100 90 4 1 1 10 50 60 -200 50 80 100 70 70 10 Output The transformed matrix is: 10 1 100 60 50 200 60 60 200 80 50 100 89 99 10 The added matrix is: 1 1 10 1 10 100 50 80 200 60 60 200 70 70 10 99 89 10 分析 首先题目描述有错。</description>
    </item>
    
    <item>
      <title>统计递归子问题个数</title>
      <link>https://ntutn.top/posts/%E7%BB%9F%E8%AE%A1%E9%80%92%E5%BD%92%E5%AD%90%E9%97%AE%E9%A2%98%E4%B8%AA%E6%95%B0/</link>
      <pubDate>Fri, 17 May 2019 03:11:37 +0800</pubDate>
      
      <guid>https://ntutn.top/posts/%E7%BB%9F%E8%AE%A1%E9%80%92%E5%BD%92%E5%AD%90%E9%97%AE%E9%A2%98%E4%B8%AA%E6%95%B0/</guid>
      <description>分治策略是算法设计的重要策略之一，该策略的基本思想是把问题进行分解成一些子问题，通过子问题的求解完成对原问题的求解。其关键是分解和合并，好的分解或合并方法才会产生高效的分治算法。
分治策略设计出的算法最常见的就是递归算法。但是如果在分解时，分解出的子问题有很多是重复的，那么这样的分治（递归）算法求解问题的效率就非常低。例如斐波那契数问题，如果采用递归求解，算法效率非常低：O(2^n)。而如果采用递推求解(动态规划自底向上求解)，算法效率非常高：O(n)。
Question 现在请你编写程序，统计计算一个斐波那契数时分解出的各子问题的个数。
斐波那契数的定义如下：
Fib(0)=0 Fib(1)=1 Fib(n)=Fib(n-1)+Fib(n-2) 输入：一个整数n，即计算Fib(n)
输出：n+1行，即各个子问题的值及该子问题的个数。
Example Input 5 Output Fib(0)=0,spn=3 Fib(1)=1,spn=5 Fib(2)=1,spn=3 Fib(3)=2,spn=2 Fib(4)=3,spn=1 Fib(5)=5,spn=1 分析 一大段分治思想的介绍，递归与递推的区别，我以为这题用递归会超时，要用递推求解，于是入坑……
这题要统计子问题个数，递推或者递归加备忘录根本没重复的计算怎么统计……
不死心的我又仔细研究递推子问题个数的规律，发现子问题个数正好是一个反着的斐波那契数列（结尾元素特殊处理），所以可以正向递推求数列，反向递推求子问题个数。
不过特殊情况研究的有点头疼，暂时就不搞了，下面给出的是老老实实递归求解的程序。
Answer #include &amp;lt;iostream&amp;gt;#include &amp;lt;cstring&amp;gt;using namespace std; int*spn; int*data; int fib(int n){ spn[n]++; if(n==0){ data[0]=0; return 0; } if(n==1){ data[1]=1; return 1; } int res=fib(n-1)+fib(n-2); data[n]=res; return res; } int main() { int n; cin&amp;gt;&amp;gt;n; spn=new int[n+1]; data=new int[n+1]; memset(spn,0,(n+1)*sizeof(int)); memset(data,-1,(n+1)*sizeof(int)); data[0]=0; data[1]=1; fib(n); for(int i=0;i&amp;lt;=n;i++){ cout&amp;lt;&amp;lt;&amp;#34;Fib(&amp;#34;&amp;lt;&amp;lt;i&amp;lt;&amp;lt;&amp;#34;)=&amp;#34;&amp;lt;&amp;lt;data[i]&amp;lt;&amp;lt;&amp;#34;,spn=&amp;#34;&amp;lt;&amp;lt;spn[i]&amp;lt;&amp;lt;endl; } return 0; } </description>
    </item>
    
    <item>
      <title>二叉树ADT的实现</title>
      <link>https://ntutn.top/posts/%E4%BA%8C%E5%8F%89%E6%A0%91adt%E7%9A%84%E5%AE%9E%E7%8E%B0/</link>
      <pubDate>Tue, 14 May 2019 03:11:37 +0800</pubDate>
      
      <guid>https://ntutn.top/posts/%E4%BA%8C%E5%8F%89%E6%A0%91adt%E7%9A%84%E5%AE%9E%E7%8E%B0/</guid>
      <description>人工智能知识点整理Question
假设二叉数的数据元素为字符，采用二叉链式存储结构。请编码实现二叉树ADT，其中包括创建二叉树、遍历二叉树（深度、广度）、求二叉树的深度（高度）、计算二叉树的元素个数、计算二叉树的叶子数、二叉树的格式输出等。
根据输入的符号，执行相应的操作。如下：
 C：根据完全前序序列创建二叉树，#表示空结点（空子树）；输入：二叉树的完全前序序列，创建成功输出 Created success! H：求二叉树的高度； 输出： Height=高度 L：计算二叉树的叶子数；输出：Leaves=叶子个数 N：计算二叉树中元素总个数；输出：Nodes=结点个数 1：先序遍历二叉树；输出：Preorder is:序列 . 2：中序遍历二叉树；输出：Inorder is:序列 . 3：后序遍历二叉树；输出：Postorder is:序列 . 4：广度遍历二叉树；输出：BFSorder is:序列 . F：查找值为x的结点个数；输出：The count of x is 个数 . P：以目录缩格文本形式输出所有节点。输出：The tree is:（换行，下面各行是输出的二叉树） X：退出  Example Input C ABC##DE#G##F### H L N 1 2 3 4 F A P X Output Created success! Height=5 Leaves=3 Nodes=7 Preorder is:A B C D E G F . Inorder is:C B E G D F A .</description>
    </item>
    
    <item>
      <title>活动安排问题</title>
      <link>https://ntutn.top/posts/%E6%B4%BB%E5%8A%A8%E5%AE%89%E6%8E%92%E9%97%AE%E9%A2%98/</link>
      <pubDate>Mon, 13 May 2019 03:11:37 +0800</pubDate>
      
      <guid>https://ntutn.top/posts/%E6%B4%BB%E5%8A%A8%E5%AE%89%E6%8E%92%E9%97%AE%E9%A2%98/</guid>
      <description>经典的贪心问题。
Question 假设有n个活动的集合E={a1,a2,...,an}，其每个活动都要求使用同一资源（如某个设备、教室、场地等），而在同一时间内只允许一个活动使用这一资源。
每个活动都有一个要求使用该资源的起止时间si,fi，且si&amp;lt;fi。如果选择了活动ai，则它在半开的时间区间[si,fi)内占有资源。两个活动ai,aj称为是相容的，当且仅当它们的时间区间[si,fi)和[sj,fj)不相交，即si&amp;gt;=fj 或 sj &amp;gt;=fi。现要求在所给定的活动集中选出最大的相容活动子集。
请补充要求的函数代码。
提示：贪心策略
输入，有多行，第1行是活动的个数n，后面n行，每行3个整数，是每个活动的编号、占用资源的开始时间、结束时间。
输出，选出的最大活动子集，即有多行，每行包括活动的编号、开始时间、结束时间。
Example Input 11 1 3 8 2 2 13 3 1 4 4 5 7 5 6 10 6 8 11 7 12 14 8 5 9 9 3 5 10 0 6 11 8 12 Output 3：1-4 4：5-7 6：8-11 7：12-14 分析 经典的贪心问题，贪心策略为选择结束时间最早的活动，因为这样就可以给后面的活动留出更多的时间。
 掉坑：在选择活动时只处理了前24小时的活动，而事实证明我画蛇添足了。
 Answer #include &amp;lt;iostream&amp;gt;#include &amp;lt;stdio.h&amp;gt;#include &amp;lt;stdlib.h&amp;gt;using namespace std; //定义允许的最大活动数 #define Maxn 100 //定义活动的类型 typedef struct act_Node { int Id; //活动ID  int s_Time; //活动开始时间  int f_Time; //活动结束时间 } ACND; //对活动按贪心准则排序 void Sort(int n,ACND arr[]) { for(int i=0;i&amp;lt;n;i++){ int tmp=i; for(int j=i+1;j&amp;lt;n;j++){ if(arr[j].</description>
    </item>
    
    <item>
      <title>线性表ADT的实现</title>
      <link>https://ntutn.top/posts/%E7%BA%BF%E6%80%A7%E8%A1%A8adt%E7%9A%84%E5%AE%9E%E7%8E%B0/</link>
      <pubDate>Mon, 13 May 2019 03:11:37 +0800</pubDate>
      
      <guid>https://ntutn.top/posts/%E7%BA%BF%E6%80%A7%E8%A1%A8adt%E7%9A%84%E5%AE%9E%E7%8E%B0/</guid>
      <description>线性表ADT的实现 数据结构平时测试的题目开放了，这次平时测试睡过了，全宿舍都睡过了。现在回头做做题目，还是有坑点的。
Question 假设线性表ADT的数据元素类型为正整数，采用带头结点的单链式存储结构。线性表ADT实现的大部分代码已经给出，请补充写出类的两个成员函数insert和reverse。 注意：只需提交需要补充的函数代码，其他代码不能自己重写和修改。
insert函数：在元素值从小到大有序的线性表中插入一个元素，仍然保持有序。
reverse函数：实现线性表元素的倒置，即将线性表中数据元素的顺序反转。
线性表元素输入时，以 endTag 作为结束标志。
例如输入：
3 8 7 2 4 9 1 6 5 0 则输出：
9 8 7 6 5 4 3 2 1 预置代码如下： （其中/* */ 部分是要补充的insert和reverse函数）
#include&amp;lt;iostream&amp;gt;#include&amp;lt;stdlib.h&amp;gt;using namespace std; typedef int ElemType; //数据元素类型 class List; //前视定义,否则友元无法定义 //结点类定义 class LinkNode { friend class List; private: LinkNode *link; ElemType data; public: LinkNode (LinkNode *ptr = NULL) {link=ptr;} LinkNode(const ElemType &amp;amp; item, LinkNode *ptr = NULL){ data=item;link=ptr;} ~LinkNode(){}; }; //单链表类定义 class List { private: LinkNode *first; //指向链表头结点的指针  public: List (ElemType x) { first = new LinkNode (x);} // 带头结点  ~List (){ MakeEmpty();} //析构函数  void MakeEmpty ( ); //线性表置空  void insert(ElemType val); //在有序线性表中插入元素val  void reverse(); //线性表的倒置  void output(); //线性表的输出 }; void List:: MakeEmpty ( ) { LinkNode *q; while ( first-&amp;gt;link !</description>
    </item>
    
    <item>
      <title>计算机组成原理笔记</title>
      <link>https://ntutn.top/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Mon, 13 May 2019 03:11:37 +0800</pubDate>
      
      <guid>https://ntutn.top/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/</guid>
      <description>概述 计算机组成原理马上就要期中考试了，我也在积极准备复习，顺着课本也做了一波笔记，把每个部分的知识点都整理了一下。没理解的暂时还空着（比如海明校验码），有些整理起来不方便的也暂时空着，回头去查课本吧。
结课了，顺着课本捋了一遍，做的一些笔记：
计算机组成原理 概述 计算机硬件  采用存储程序工作方式。 由运算器、控制器、存储器、输入设备、输出设备部件组成。 存储器：存储数据/指令 控制器：控制指令的自动执行 运算器：加减乘除、逻辑运算 操作人员通过输入输出设备控制计算机。 计算机内部以二进制表示指令和数据 指令由操作码和地址码组成。 总线：传输信息的介质。  ALU：数据处理部件，执行算数和逻辑运算。
计算机软件 计算机系统层次结构 应用（问题） 最终用户 算法 程序员 编程（语言） 操作系统/虚拟机 指令集体系结构（ISA）架构师 微体系结构 功能部件/RTL 电子工程师 电路 器件   机器级语言   和运行程序的计算机底层结构密切相关。 可读性差，不易于记忆。
  汇编语言 机器语言  高级语言   和底层计算机结构关系不大。 可读性相当较好。 大多数程序员使用高级语言编写程序。
 程序设计语言处理系统  汇编程序：汇编器，汇编语言》机器语言 解释程序：解释器，将源程序中的语句按顺序逐条翻译并立即执行。 编译程序：编译器，高级语言》汇编语言/机器语言。  计算机系统的不同用户 最终用户 使应用程序完成特定任务的用户。
简单的人机交互界面、安装在计算机中的相关应用程序。
系统管理员 利用操作系统等软件提供的功能对系统进行配置管理维护的操作人员。
部分硬件层面、系统管理层面、相关实用程序和人机交互界面。
应用程序员 使用高级语言编制应用软件的程序员。
硬件、操作系统提供的编程接口、人机交互界面、实用程序、相关的语言程序处理系统。
系统程序员 设计和开发系统软件的程序员。
计算机底层相关硬件和系统结构。</description>
    </item>
    
    <item>
      <title>数据结构 栈应用 1 括号匹配</title>
      <link>https://ntutn.top/posts/%E6%8B%AC%E5%8F%B7%E5%8C%B9%E9%85%8D/</link>
      <pubDate>Thu, 25 Apr 2019 03:11:37 +0800</pubDate>
      
      <guid>https://ntutn.top/posts/%E6%8B%AC%E5%8F%B7%E5%8C%B9%E9%85%8D/</guid>
      <description>大概是一道栈的应用的水题吧。
 输入一行符号,以#结束，判断其中的括号是否匹配。 遇到左括号入栈，遇到右括号出栈。如果字符串结束栈不空，输出栈内左括号对应右括号。
Question 用栈实现：输入一行符号,以#结束，判断其中的括号是否匹配。括号包括：
{ } 、 [ ] 、 ( )、 &amp;lt; &amp;gt; 如果匹配，输出 right
如果不匹配，给出错误提示。包括：
第几个符号处理时出现错误；哪几个符号失配等
Example 思路 遇到左括号入栈，遇到右括号出栈。如果字符串结束栈不空，输出栈内左括号对应右括号。
 没有一遍过，因为题目中没说如果出错就不再继续处理。
 相关  栈：顺序表，只允许在一端输入输出。 getline(cin,str);可输入整行，支持空格。 如果用数组实现栈，则其存储空间必须是一次性申请得到的。  Answer  指定初始maxsize=1是我某种程度上的强迫症，反正这题时间限制很宽松。
 #include &amp;lt;iostream&amp;gt;#include&amp;lt;cstring&amp;gt;#include&amp;lt;string&amp;gt;using namespace std; class mystack{ private: char *data; int maxsize; int top; public: mystack(){ maxsize=1; data=new char[maxsize]; top=-1; } bool isEmpty(){ return top==-1; } char getTop(){ if(top&amp;gt;-1){ return data[top]; } return &amp;#39;\0&amp;#39;; } void pop(){ if(top&amp;gt;=0){ top--; } } void expand(){ char*tmp=new char[maxsize*2]; strncpy(tmp,data,maxsize); maxsize*=2; delete[] data; data=tmp; } void push(char x){ if(top+1==maxsize){ expand(); } data[++top]=x; } ~mystack(){ delete[] data; } }; char getPar(char x){ switch(x){ case &amp;#39;{&amp;#39;: return &amp;#39;}&amp;#39;; case &amp;#39;[&amp;#39;: return &amp;#39;]&amp;#39;; case &amp;#39;(&amp;#39;: return &amp;#39;)&amp;#39;; case &amp;#39;&amp;lt;&amp;#39;: return &amp;#39;&amp;gt;&amp;#39;; } return &amp;#39;\0&amp;#39;; } int isKH(char x){ switch(x){ case &amp;#39;{&amp;#39;: case &amp;#39;[&amp;#39;: case &amp;#39;(&amp;#39;: case &amp;#39;&amp;lt;&amp;#39;: return 1; case &amp;#39;}&amp;#39;: case &amp;#39;]&amp;#39;: case &amp;#39;)&amp;#39;: case &amp;#39;&amp;gt;&amp;#39;: return 2; } return 0; } int main() { string tmp; getline(cin,tmp); mystack*stk=new mystack(); bool erred=false; for(int i=0;i&amp;lt;tmp.</description>
    </item>
    
    <item>
      <title>数据结构 栈应用2 表达式求值</title>
      <link>https://ntutn.top/posts/%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC/</link>
      <pubDate>Thu, 25 Apr 2019 03:11:37 +0800</pubDate>
      
      <guid>https://ntutn.top/posts/%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC/</guid>
      <description>表达式求值是程序设计语言编译中的一个最基本问题，它的实现是栈应用的一个典型例子。
 Question 表达式求值是进行数据处理的最基本操作。请编写程序完成一个简单算术表达式的求值。要求如下：
 运算符包括：+、-、*、-、^(乘方)、括号 运算量为数值常量，根据自己的能力可以对运算量做不同的约束，例如1位整数、多位整数、实数等（会有不同的测试用例）；   输入：一行，即表达式，以“=”结束。例如：  5*(8-3)+6/5=  输出：一行，即表达式的值。结果值为整数时输出为整数，如果有小数时保留5位小数。  26.20000 问题与分析 栈 栈是特殊的线性表，其一端固定，只允许在另一端插入或删除。其特性是“先进后出”。
表达式的书写形式  前缀式 + × a b × - c / d e f 中缀式 a × b + (c - d / e) × f 后缀式 a b × c d e / - f × +  前缀式的运算规则 连续出现的两个操作数和在它们之前且紧靠它们的运算符构成一个最小表达式;
运算符出现的顺序与运算顺序相反
 中缀式与后缀式略。其中中缀式是我们最常书写的形式。
 后缀式的运算  是操作数，入栈 是符号，取出两个操作数运算后入栈 表达式处理完毕后栈内唯一元素即运算结果  中缀式转换为后缀式 直接对中缀式求值 类似中缀式转后缀式的过程，把运算量的输出改为“入OPND栈”，把运算符的“输出”改为“计算”：根据运算符，出栈需要的运算量，计算值，结果作为运算量再入栈。其他不需要变化。</description>
    </item>
    
    <item>
      <title>图书管理系统</title>
      <link>https://ntutn.top/posts/%E5%9B%BE%E4%B9%A6%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/</link>
      <pubDate>Sat, 13 Apr 2019 03:11:37 +0800</pubDate>
      
      <guid>https://ntutn.top/posts/%E5%9B%BE%E4%B9%A6%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/</guid>
      <description>翻出了以前写的C++作业，图书管理系统，虽然挺简单的，但留下纪念下吧。
#include &amp;lt;iostream&amp;gt;#include&amp;lt;cstdlib&amp;gt;#include&amp;lt;cstring&amp;gt;#include&amp;lt;fstream&amp;gt;using namespace std; class CUser { private: int code; //表示用户编号；  char name[20]; //表示用户姓名 public: CUser() { ; }; // 默认构造函数  CUser(int id, char na[]) { code=id; strcpy(name,na); }; //构造函数，初始化用户信息  void setcode(int n) { code=n; }; //用来设置用户编号  int getcode() { return code; }; //用来获取用户编号  void setname(char na[]) { strcpy(name,na); }; //用来设置用户姓名  char* getname() { return name; }; //用来获取用户姓名  void show() { cout&amp;lt;&amp;lt;&amp;#34;用户编号：&amp;#34;&amp;lt;&amp;lt;code&amp;lt;&amp;lt;endl; cout&amp;lt;&amp;lt;&amp;#34;姓名：&amp;#34;&amp;lt;&amp;lt;name&amp;lt;&amp;lt;endl; }; //用来显示用户的基本信息 }; class CBook { private: int code; //图书编号  char name[20]; //图书名称  bool Is_Stock; //true为在架，false为借出  bool Is_Existing; //true为存在, false为删除 public: CBook() { ; }; //默认构造函数  CBook(int no,char na[]) { code=no; strcpy(name,na); Is_Stock=true; Is_Existing=true; }; //构造函数，初始化图书信息  void setcode(int n) { code=n; }; //设置图书编号  int getcode() { return code; }; //获取图书编号  void setname(char na[]) { strcpy(name,na); }; //设置图书名称  char* getname() { return name; }; //获取图书名称  bool get_Stock() { return Is_Stock; }; //获取图书是否在库信息  void set_Stock(bool isstock) { Is_Stock=isstock; };// 设置图书是否在库信息  bool get_Existing() { return Is_Existing; };//获取存在标志  void set_Existing(bool isex) { Is_Existing=isex; };//设置存在标志 }; class CReader:public CUser { private: bool Is_Existing; //true存在，false删除  bool Is_Borrowing; //true借过书，false没有借书  CBook brbook; //表示读者所借的图书 public: CReader() { CUser(); }; //构造函数，初始化读者信息  CReader(int id, char na[]) { CUser(id,na); }; //构造函数，初始化读者信息  bool get_Existing() { return Is_Existing; }; //用来获取删除标志  void set_Existing(bool isex) { Is_Existing=isex; }; //用来设置删除标志  bool get_Borrowing() { return Is_Borrowing; }; //用来获取读者借阅情况  void set_Borrowing(bool isbo) { Is_Borrowing=isbo; }; //用来设置读者借阅情况  void setbrbook(CBook bt) { brbook=bt; Is_Borrowing=true; }; //用来记录读者结束信息  CBook getbrbook() { return brbook; }; //用来获取读者结束信息  void show() { CUser::show(); if(Is_Borrowing) { cout&amp;lt;&amp;lt;&amp;#34;当前借书：&amp;#34;&amp;lt;&amp;lt;brbook.</description>
    </item>
    
    <item>
      <title>学生管理系统</title>
      <link>https://ntutn.top/posts/%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/</link>
      <pubDate>Sat, 13 Apr 2019 03:11:37 +0800</pubDate>
      
      <guid>https://ntutn.top/posts/%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/</guid>
      <description>翻出了以前C语言C实验的大作业，当时搞了好多奇技淫巧，最终拿到99分。
 介绍 学生成绩管理系统v6.0是由软件工程1702刘海鑫设计的一款用于学生成绩管理的软件。
文件列表  Stuv6.0.exe	主体程序，用于实现整体功能。 main.dat	程序的数据文件，用于存储学生信息。 goodbye.bmp	程序退出时加载的图片。 desktop.ini	修改程序所在文件夹的图标。 consoletest.exe	编译的au3程序，用于辅助输入中文。  代码：
$re=InputBox(&amp;quot;Input&amp;quot;,&amp;quot;You can input your massage now.(支持中文)&amp;quot;) ConsoleWrite($re)  code.dat	密码存储文件。该文件存储的是xor算法加密的账号密码。 black.bmp	一张纯黑的图片，用于清除控制台加载图片的痕迹。2018年1月20日使用了image /d清除图片，本文件不再使用。 background.bmp	程序启动时加载的图片。 about.rtf	程序的说明文档。 scaned.txt	存储用户输入的临时文件，一般会自动清除。 subjects.dat	存储科目的名称，每行一个，最多允许50个，可用记事本直接打开编辑。 image.exe	外部程序，用于加载图片。  使用说明 双击stuv6.0.exe，程序启动。
待启动图片显示过后，出现密码输入框，回车确认输入。
默认账号：admin
默认密码：admin888
输入密码时如果输入~符号，将弹出一个信息框提示输入。这是为了便于输入中文和特殊符号。
本程序的密码存储是xor运算的结果，仅用于比对密码是否正确。
接下来进入主菜单。菜单使用黄色为底色，红色标定选中项。你可以按上下键选择，或直接按项目对应数字，回车确认。
开发日志   2018年3月10日，加入了控制台窗口大小控制的代码。
  修改了exe文件的图标。
  改用外部程序image.exe加载图片，并修改gotoxy函数的使用，成功使代码兼容了gun gcc系列编译器。
  测试WIN7运行效果，图片加载错位，无法全屏，其他功能不受影响。
  在科目分析功能加入分层成绩展示，至此，程序主体开发完毕。
  加入查找功能，查找方式为遍历，依据为id或姓名。 同理，加入按id排序、按姓名的字典顺序排序。 数据排序功能，选择后弹出二级菜单，进行升序排序或降序排序。 排序的结果不会保存。 排序后将自动展示排序结果。</description>
    </item>
    
    <item>
      <title>连续正整数</title>
      <link>https://ntutn.top/posts/%E8%BF%9E%E7%BB%AD%E6%AD%A3%E6%95%B4%E6%95%B0/</link>
      <pubDate>Sat, 06 Apr 2019 03:11:37 +0800</pubDate>
      
      <guid>https://ntutn.top/posts/%E8%BF%9E%E7%BB%AD%E6%AD%A3%E6%95%B4%E6%95%B0/</guid>
      <description>还是数据结构的网上作业，将一个整数分解为连续正整数之和，找对方向倒是也不算难……
 有些正整数可以表示为 n (n&amp;gt;1) 个连续正整数的和，如：
15=1+2+3+4+5 =4+5+6 =7+8 给定一个正整数 N，判断其是否可以表示为一组连续正整数的和，输出符合条件的解的组数。
Input 输入有一行，包含一个正整数 n (3≤n≤1000000000)。  Output 输出有一行，正整数n的符合条件的解的组数。  Example    Input Output     15 3   99 5   6 1   9 2    单点时限: 2.0 sec 内存限制: 256 MB
#include &amp;lt;iostream&amp;gt;using namespace std; int main() { int n; cin&amp;gt;&amp;gt;n; int counter=0; for(int i=2; i&amp;lt;(100000&amp;lt;n?100000:n); i++) //n/i-i/2+1&amp;gt;=1  { if(n/i-i/2-i%2+1&amp;gt;=1&amp;amp;&amp;amp;(n/i-i/2-i%2+1+n/i-i/2-i%2+1+i-1)*i==n*2) { counter++; } //cout&amp;lt;&amp;lt;&amp;#34;test-&amp;#34;&amp;lt;&amp;lt;i&amp;lt;&amp;lt;endl;  } cout &amp;lt;&amp;lt; counter &amp;lt;&amp;lt; endl; return 0; } 枚举就好了。需要根据分成的整数的个数i讨论，但为了显得更牛X我就写到一起了，上面的n/i-i/2-i%2+1无论在奇偶情况下都是拆分得到的整数的第一个理应是多少。</description>
    </item>
    
    <item>
      <title>使用映像劫持技术屏蔽电脑中的广告进程</title>
      <link>https://ntutn.top/posts/%E4%BD%BF%E7%94%A8%E6%98%A0%E5%83%8F%E5%8A%AB%E6%8C%81%E6%8A%80%E6%9C%AF%E5%B1%8F%E8%94%BD%E7%94%B5%E8%84%91%E4%B8%AD%E7%9A%84%E5%B9%BF%E5%91%8A%E8%BF%9B%E7%A8%8B/</link>
      <pubDate>Thu, 28 Mar 2019 03:11:37 +0800</pubDate>
      
      <guid>https://ntutn.top/posts/%E4%BD%BF%E7%94%A8%E6%98%A0%E5%83%8F%E5%8A%AB%E6%8C%81%E6%8A%80%E6%9C%AF%E5%B1%8F%E8%94%BD%E7%94%B5%E8%84%91%E4%B8%AD%E7%9A%84%E5%B9%BF%E5%91%8A%E8%BF%9B%E7%A8%8B/</guid>
      <description>映像劫持（Image File Execution Options），简单的说法，就是当你打开的是程序A，而运行的确是程序B。映像劫持其实是Windows内设的用来调试程序的功能，但是现在却往往被病毒恶意利用。当用户双击对应的程序后，操作系统就会给外壳程序（例如“explorer.exe”）发布相应的指令，其中包含有执行程序的路径和文件名，然后由外壳程序来执行该程序。事实上在该过程中，Windows还会在注册表的上述路径中查询所有的映像劫持子键，如果存在和该程序名称完全相同的子键，就查询对应子健中包含的“dubugger”键值名，并用其指定的程序路径来代替原始的程序，之后执行的是遭到“劫持”的虚假程序。
 国内很多软件都有重度广告，“资讯”、“新闻”、“弹窗”，不胜其烦。直接找到广告进程删除掉，结果一自动更新，又回来了。
于是，我想到了“映像劫持”：
Windows Registry Editor Version 5.00 [HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\SLBService.exe] &amp;#34;Debugger&amp;#34;=&amp;#34;winlogon&amp;#34; [HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\TsService.exe] &amp;#34;Debugger&amp;#34;=&amp;#34;winlogon&amp;#34; [HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\FoxitDesktopAd.exe] &amp;#34;Debugger&amp;#34;=&amp;#34;winlogon&amp;#34; [HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\FoxitProtect.exe] &amp;#34;Debugger&amp;#34;=&amp;#34;winlogon&amp;#34; [HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\LCServer.exe] &amp;#34;Debugger&amp;#34;=&amp;#34;winlogon&amp;#34; [HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\LRServer.exe] &amp;#34;Debugger&amp;#34;=&amp;#34;winlogon&amp;#34; [HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\2345MiniPage.exe] &amp;#34;Debugger&amp;#34;=&amp;#34;winlogon&amp;#34; [HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\SohuNews.exe] &amp;#34;Debugger&amp;#34;=&amp;#34;winlogon&amp;#34; [HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\PinyinUp.exe] &amp;#34;Debugger&amp;#34;=&amp;#34;winlogon&amp;#34; [HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\SGDownload.</description>
    </item>
    
    <item>
      <title>数据结构与算法 C&#43;&#43;编程能力评估</title>
      <link>https://ntutn.top/posts/c&#43;&#43;%E7%BC%96%E7%A8%8B%E8%83%BD%E5%8A%9B%E8%AF%84%E4%BC%B0/</link>
      <pubDate>Thu, 28 Mar 2019 03:11:37 +0800</pubDate>
      
      <guid>https://ntutn.top/posts/c&#43;&#43;%E7%BC%96%E7%A8%8B%E8%83%BD%E5%8A%9B%E8%AF%84%E4%BC%B0/</guid>
      <description>题目1 向类SeqList中插入数据，请根据main函数中的调用，完成Insert和output函数。
 Input   5 1 2 3 4 5 2 9  Output  1 2 3 4 5 1 2 9 3 4 5  Answer  #include&amp;lt;iostream&amp;gt;#include&amp;lt;stdlib.h&amp;gt;using namespace std; class SeqList { private: int * data; int last; // index of the last element public: SeqList ( int sz ); ~SeqList ( ) { delete [ ] data; } void input (); void output() ; void Insert ( const int &amp;amp;x, int i); } ; SeqList::SeqList ( int sz ) { if ( sz &amp;gt; 0 ) { data = new int[sz]; last = -1; } } void SeqList:: input() { cin &amp;gt;&amp;gt;last; for (int i=0; i&amp;lt;last; i++) cin&amp;gt;&amp;gt;data [i]; last--; } void SeqList::output() { bool fi=false; for(int i=0; i&amp;lt;=last; i++) { if(!</description>
    </item>
    
    <item>
      <title>直</title>
      <link>https://ntutn.top/posts/%E7%9B%B4/</link>
      <pubDate>Wed, 27 Mar 2019 03:11:37 +0800</pubDate>
      
      <guid>https://ntutn.top/posts/%E7%9B%B4/</guid>
      <description>直  发现了自己初中写的作文，我当年这么中二的吗……
 树是直的，直得挺拔入云；山是直的，直得直插霄汉；竹是直的直得虚心髙洁。是啊，巍峨的直无处不在。
尺 人们仰慕大自然的直，于是制造了尺。尺，为直而生。再纷乱的外界环境，它总恪尽职守，一丝不苟。即使是它的制造者，它也将毫不留情地指出他的过失。
人本如此。看到它，我想起了屈子，想起了岳将军，想起包拯，想起了正直的中国人。
弓 尺是直的，但在不可抗力下它还是弯曲了。有时弯也是一种无奈，正直的树也抵不住弯曲的斧。那就弯吧。不！你没看到，弦是直的。弦如何直？那是弓在抗拒那股不可抗力！是啊，弓是弯的，但它的心是直的。它仍是一心向直的。
人应如此。狂风袭来，竹顺势而弯，但风速减小了。虽然只有一点。看到它，我想到了周树人，想到了郭沫若，想到了在黑暗中抗争的中国人。
箭 弓是弯的，但它不甘继续弯下去。于是它化作一支羽箭，反射着金色阳光，即使这直是有代价的。它是一根选择燃烧的火柴。它将烧尽，但它选择了燃烧。
看到它，我想到了荆轲，想到了谭嗣同，想到了敢于与黑暗抗争的中国人。
中华民族是一个直的民族，中国人本色如此。中国人是直的，即使在不可抗力下弯了，心还是直的。而且，他们会抗争，不管那是不是不可抗力。在忍无可忍时，他们会用自己的生命，划出一道直线。中国，拉着这样的弓，射出这样的箭，复兴也是必然的。
这就是那个直的传说。</description>
    </item>
    
    <item>
      <title>堆栈ADT实现及应用</title>
      <link>https://ntutn.top/posts/%E5%A0%86%E6%A0%88adt%E5%AE%9E%E7%8E%B0%E5%8F%8A%E5%BA%94%E7%94%A8/</link>
      <pubDate>Tue, 26 Mar 2019 03:11:37 +0800</pubDate>
      
      <guid>https://ntutn.top/posts/%E5%A0%86%E6%A0%88adt%E5%AE%9E%E7%8E%B0%E5%8F%8A%E5%BA%94%E7%94%A8/</guid>
      <description>假设栈ADT的数据元素为整数，栈ADT的实现采用顺序存储结构。现要用栈来辅助完成任意非负十进制整数到Base(Base不大于35)进制的转换。部分代码已经给出，请补充完善栈溢出处理函数和主函数。 注意：只提交需要补充的函数，其他代码不允许自己重写和修改。
 栈溢出处理函数overflowProcess：当栈满时，将栈的空间在原来基础上扩大1倍。
主函数： 输入一个非负十进制整数n及要转换的进制Base，输出其转换后的进制形式，以及长度。输出格式如下：
($...$)10=(#...#)Base Length=转换进制后数的位数 其中$...$是输入的十进制数n，#...#是转换得到的Base进制数，如果转换后位码多于1位，则用大写字母A,B,&amp;hellip;等表示，10-A, 11-B,&amp;hellip;&amp;hellip;
例如，输入：
1024 2 输出：
(1024)10=(10000000000)2 Length=11 再如，输入：
25 30 输出：
(25)10=(P)30 Length=1 预置代码如下：
#include &amp;lt;iostream&amp;gt;using namespace std; #include &amp;lt;stdio.h&amp;gt;#include &amp;lt;stdlib.h&amp;gt;typedef int ElemType; class SeqStack { //顺序栈类定义  private: ElemType *elements; //数组存放栈元素  int top; //栈顶指示器  int maxSize; //栈最大容量  void overflowProcess(); //栈的溢出处理  public: SeqStack(int sz); //构造函数  ~SeqStack() { delete []elements; }; //析构函数  void Push(ElemType x); //进栈  int Pop(ElemType &amp;amp;x); //出栈  int IsEmpty() const { return top == -1; } int IsFull() const { return top == maxSize-1; } int GetSize() const {return top+1;} }; SeqStack::SeqStack(int sz) { elements=new ElemType[sz]; //申请连续空间  if(elements==NULL) {cout&amp;lt;&amp;lt;&amp;#34;空间申请错误！&amp;#34;&amp;lt;&amp;lt;endl;exit(1);} else { top=-1; //栈顶指示器指向栈底  maxSize=sz; //栈的最大空间  }; }; /* ********************************************************** 补充overflowProcess() 函数 ********************************************************** */ void SeqStack::Push(ElemType x) { //若栈满,则溢出处理，将元素x插入该栈栈顶  if (IsFull() == 1) overflowProcess(); //栈满  elements[++top] = x; //栈顶指针先加1, 再元素进栈 }; int SeqStack::Pop(ElemType &amp;amp; x) {//若栈不空，函数退出栈顶元素并将栈顶元素的值赋给x,  //返回true，否则返回false  if (IsEmpty() == 1) return 0; x = elements[top--]; //先取元素，栈顶指针退1  return 1; //退栈成功 }; /* ************************************************************** 补充mian()函数 ************************************************************** */ 分析和错误 OverflowProcess，用于栈溢出处理，一般申请原长度二倍的存储空间。</description>
    </item>
    
    <item>
      <title>重装机兵</title>
      <link>https://ntutn.top/posts/%E9%87%8D%E8%A3%85%E6%9C%BA%E5%85%B5/</link>
      <pubDate>Mon, 25 Mar 2019 03:11:37 +0800</pubDate>
      
      <guid>https://ntutn.top/posts/%E9%87%8D%E8%A3%85%E6%9C%BA%E5%85%B5/</guid>
      <description>拉多：梦的起点 主角，一个满脑子都是不切实际的想法的负气出走的小毛孩，开始了他伟大的征途。这里就按照后面作品的称号吧。
首先回家，箱子里面有5G，聊胜于无吧。去买几个参丸，准备，走。
找到战车 出镇，去东南方向的山洞，需要逃跑的怪物类型：
 仿生蜗牛 生物炮 加农炮  基本是一路逃跑到了山洞最深处，喝个参丸，与挡路的狗对话。
硬抗战狗一发攻击，然后狼会出现，并帮你打败战狗。
山洞的战车太破，狼看不上，只拿走了副炮（徒手拆副炮啊）。于是这就是咱的第一辆战车了。
将山洞里稍微搜刮一下，也许去找开始打不过的怪物报个仇。相当舒服。
拉多有个规矩，就是战车不允许开进镇子，虽然没啥影响，但总是很不爽，毕竟好不容易找到战车总是想找人显摆一下啊。貌似这破规矩一直延续到第四部，香泽丽舍也有类似规矩。
 BUG：给战车吃个参丸，然后人的HP就变成一个极大的值……
 水怪 作为赏金猎人，当然只有猎杀赏金首获得赏金才是最有趣的。可惜第一代这些元素不是很多，如果是第四代，任务系统是很重要的。
水怪不是很强，基本拿到战车后就可以直接开BOSS了。
首先去加满弹药和装甲，然后先向西走，再向北走，路上会看到一个山洞。进入，顺着箭头走，然后……就掉坑了。第一次玩的玩家基本都被坑过。在掉下来的这层到处走走，遇到水怪的概率很高。基本只用主炮输出就能打过。
顺着坡爬上去，在另一个方向小心去拿那个箱子，是副炮。由于打水怪消耗不少装甲片，现在基本可以直接装备。副炮是无限弹药的，对于清小怪很有帮助。
回镇补充一下，准备去下一个镇子。
关卡，只要开着战车去，就会让你通过。
 打赢后记得去情报处领赏金。
 麦基 第一次玩我就没进入麦基镇，直接错过去了。在你向东走，路过一个小屋的标志，那就是麦基镇了。
宝石镜 进入麦基，首先看到一片白薯地，耕会儿地吧，不要每天都打打杀杀的【滑稽】。在耕地过程中会找到一枚戒指，拿到屋里可以换得宝石镜，虽然现在暂时没用，但是是最强人类装备的四个零件之一。
传送装置（时空隧道） 坐传送装置到拉多镇，与门口一直堵门的人对话他就会让开，以后拉多也就可以使用传真了。我个人认为这个设计是为了避免BUG，毕竟这个游戏传真使用有一定概率穿送到生命科学研究所，而在拉多这样肯定是不合理的，于是大概程序员灵机一动……
 在梦想起飞版本中的确有这个BUG，可以借此避免探测器球体和气息屏蔽仪被回收
 生命科学研究所 既然前面提到了，就在这里说一说吧。在传真出错时会传送到生命科学研究所，里面一个人都没有，设备都是故障。到自动售货机面前调查一下，可以找到一个再生丸，可以让死人复活，而且使用后这里会再出现一个。实际用处不大，因为完全可以去直接找明奇博士复活。
波布 从麦基继续向东，可以到达波布。
给学校捐款与BUG 在波布给学校捐款一定数量后会在镇子中央给主角立个雕像，然而当你捐款数额超过了自己实际拥有的钱数，钱没扣，但雕像立起来了……
伙伴以及复制战车BUG 在波布南边有一个房子，开着战车进去，然后走进屋里。这时屋里跑出来一个熊孩子，开上你的战车就到处乱逛。这熊孩子就是我们诱拐的目标，未来的机械师克里夫。走上前与他对话就可以让他加入了。
 他开车开的挺快，可以去树那里堵他 克里夫上自己的战车，于是就有人想，如果自己先一步上车，会怎样？
 于是就有人进行了实验。结果表明：
 如果你先上车，克里夫会停在你面前，对话也得不到什么结果 如果克里夫先上车，参照前文 如果同时上车，结果……  两人都上车了，战车变成了两辆！当然这只是一个BUG，如果此时下车，复制的战车也会消失。这时，两辆车用的是同一套数据，这就造成一些判定也就可以被绕过。比如买一发特殊炮弹（铁弹）理应只能发射一枚炮弹的，但却发射两枚，于是就溢出，然后弹仓多了256枚特殊炮弹（没有名字的，价格还特别贵），然后卖掉，基本就不愁钱了。
水鬼 找到伙伴后，去波布进行一波修整，基本就可以开第二个BOSS了。需要进行的准备有：
 对武器进行一次升级 买一个传真  说实话即使到现在我都感觉这游戏有些翻译很诡异，“传真”是一个传送装置（在第二部翻译叫“犬系统”），“金甲”被打烂会变成“金靴”……
 去给伙伴租一辆战车 补充弹药和装甲片  第二个BOSS水鬼在波布东边的桥上出没，在上面多转转就能遇到。
没什么要注意的，记得先打蛙人，后打水鬼。你可能在波布见到过有卖特种炮弹“榴弹”，估计本来按照设计应该是用来打蛙人的，但是实际发现好像根本用不到，直接主炮硬刚就行。
打水鬼时，水鬼在HP比较低时有概率潜入水中恢复HP。这里要看运气了，一般是没问题，但要是你脸黑，也存在炮弹打完还没死的情况。</description>
    </item>
    
    <item>
      <title>我的理想——我的一篇日记</title>
      <link>https://ntutn.top/posts/%E6%88%91%E7%9A%84%E7%90%86%E6%83%B3%E6%88%91%E7%9A%84%E4%B8%80%E7%AF%87%E6%97%A5%E8%AE%B0/</link>
      <pubDate>Sun, 24 Mar 2019 03:11:37 +0800</pubDate>
      
      <guid>https://ntutn.top/posts/%E6%88%91%E7%9A%84%E7%90%86%E6%83%B3%E6%88%91%E7%9A%84%E4%B8%80%E7%AF%87%E6%97%A5%E8%AE%B0/</guid>
      <description>我的理想——我的一篇日记 一不小心翻到了以前初中写的一篇日记，为了装X还是用英文写的，羞耻度爆表……
Wednesday, December 26, 2012 Sunday
Today we learned how to talk about future intentions. Iwant to be a programmer when I grow up. So how am I going to do it? I’m goingto study computer science and English when I have free time. It’s veryimportant. I learned Visual Basic. It was made by Microsoft. I can make someprogram now. On my last summer vacation, I made some programs, like notepad.</description>
    </item>
    
    <item>
      <title>零梦</title>
      <link>https://ntutn.top/posts/%E9%9B%B6%E6%A2%A6/</link>
      <pubDate>Sun, 24 Mar 2019 03:11:37 +0800</pubDate>
      
      <guid>https://ntutn.top/posts/%E9%9B%B6%E6%A2%A6/</guid>
      <description>做了一个有点意思的梦，细思极恐，所以特地记录一下。
D1 我是一名初中生，一个学习非常好的中学生，我们国家有一项政策，就是学习非常好的初三学生不必在初中浪费时间，可以提前去上高中，只要到时候回来象征性参加中考就行了，而我这就是准备回家参加中考。我给家里打电话说让放心，然后打开手机地图搜索路线。
雾很大，公交一辆一辆开过，我发现可以坐火车，坐火车是最快的。只要坐524，就能直接到达。我从入口走进，路过卖各种东西的，猪肉、水果以及其他。只有一条路，只有一个车厢，我走进，里面有一个人，正在抽烟。我问对方是不是524，对方说不知道，自己还有一站下车，这时火车开动了，而我也猛然发现车上写着522。
D2 我被告知自己刚刚差不多是在做梦。想想也是，不符合逻辑的地方很多，首先我们初中生可以去高中体验这种诡异政策什么时候有的？车站又怎么会卖这些乱七八糟的？
但说起来吓人，刚刚我不但一点意识不到自己在做梦，而且真的相信自己是一个初中生，真的有这奇葩的政策。
某公司说，这是一个实验项目，主要是用于研究梦与记忆之间的关系，梦中出现的大概很多都是你心中相当害怕的事物，比如你一直在找各种交通工具就大概反映你现实是一个路痴，诸如此类。说的不错，我的确是个路痴，那按照这个说法，这个车站很值得怀疑啊，因为我不是第一次梦见这个一看就很奇怪的车站了，在以前的梦里曾经有在这个车站发生凶杀案，也就是说我曾经在某个车站类似的地方有过糟糕的经历了？总感觉自己缺了一段记忆。
D3 我从迷蒙中清醒，脑子还是有点混乱，这里正在打仗，不对，按照规模来看，应该是两伙人在打群架，但狠辣的手法和波及到的人数占总人数的比例来看，这又是战争无疑，而且在我的观察中，我们好像并不是正义的一方。一个和尚追着我说我是他徒弟，我说自己是学生之类都会被他说是胡思乱想。不准我读书，只让我跟他学习功法。等我实在忍无可忍，就说你这两下子我也会，看他把木棍当做飞镖投向目标，我就拿起一根金针，精准地扔向他的一根白发并且成功命中。
我就是有这样的能力，和尚就是应该有头发，这是理所当然的。
D0 我睁开眼睛，拿起手机看了看时间，大概才六点。我不是一个初中生，我没有在配合神秘组织做实验，我不是奇怪的和尚的徒弟，我是一名大学生，最近在写一个个人博客的程序，最近买的蓝牙键盘刚刚到货。我昨晚睡得很晚，但现在一点都不困。我还在想前面这个嵌套的梦，我觉得正好可以用蓝牙键盘连接手机把这个梦写出来，发到博客里面。只是我又鬼使神差地说了一句：
 溺死在零梦里吧。 我不以为然，认为这是自己吓自己，感觉自己不该这么中二才对，于是起床准备洗漱了……
 </description>
    </item>
    
    <item>
      <title>人工智能知识点整理</title>
      <link>https://ntutn.top/posts/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/</link>
      <pubDate>Thu, 03 Jan 2019 03:11:37 +0800</pubDate>
      
      <guid>https://ntutn.top/posts/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/</guid>
      <description>人工智能考试前整理的，很详细，虽然实际考试还是有好些想不起来，但总归起了一些作用的。
 第1章绪论 人工智能的起源 现代人工智能的起源是1956年的达特茅斯会议。
参加者：麦卡锡、明斯基、香农、罗切斯特、纽厄尔、西蒙、萨缪尔、伯恩斯坦、摩尔、所罗门诺夫。
会议的主要成就就是让人工智能成了一个独立的研究学科。
定下来人工智能的英文名称是“Artificial Intelligence”
知识的定义、概念、基本单位 定义 柏拉图在《泰阿泰德篇》中给出知识的定义，即“被证实的、真的和被相信的陈述”，简称知识的JTB（Justified True Belief）条件。
然而，这个延续了两千多年的定义在1963年，被哲学家盖梯尔否定了。
概念 知识的基本单位就是概念。
概念的定义  概念的符号：即概念的名称，说明这个概念叫什么。 概念的内涵：即命题来表示，命题就是能判断真假的陈述句。 概念的外延：即经典集合来表示，用来说明与概念对应的事件对象是哪些。  概念的三个功能 指物功能：既指向客观世界的对象，表示客观世界的对象的可观测性，对象的客观的信仰，是指对相对于人或者仪器的知觉感知特性，依赖于人的主观感受。
指心功能：即指向人心智世界里的对象，代表心智世界里的对象表示。
指名功能：指向认知世界或者符号世界表示对象的符号名称，这些符号名称组成各种语言。
人工智能的三个流派  专注于实现AI指名功能的人工智能流派，称为符号主义。 专注于实现AI指心功能的人工智能流派，称为连接主义。 专注于实现AI指物功能的人工智能流派，称为行为主义。     概念的功能 人工智能的流派 观点 思想实验 挑战     指名功能 符号主义 指名对了，指物自然正确 图灵测试、中文屋实验 完全实现指名功能也不见得有智能。概念的组合爆炸问题；概念的组合悖论问题；经典概念在现实中很难获得。知识很难获取   指物功能 连接主义 发现大脑的结构及处理信息的机制，揭示人工智能的本质机理，进而在机器上实现响应模拟 缸中之脑实验 指心没有问题，指物也存在问题。   指心功能 行为主义 只要实现指物功能，就认为具有智能了 完美伪装者和斯巴达人 外在表现与内心没有联系，无法测试    第2章概念表示 概念定义及三个组成部分 知识由概念组成，概念是构成人类知识世界的基本单元。</description>
    </item>
    
    <item>
      <title>我发现了齐鲁软件大赛系统的漏洞</title>
      <link>https://ntutn.top/posts/%E6%88%91%E5%8F%91%E7%8E%B0%E4%BA%86%E9%BD%90%E9%B2%81%E8%BD%AF%E4%BB%B6%E5%A4%A7%E8%B5%9B%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%BC%8F%E6%B4%9E/</link>
      <pubDate>Thu, 03 Jan 2019 03:11:37 +0800</pubDate>
      
      <guid>https://ntutn.top/posts/%E6%88%91%E5%8F%91%E7%8E%B0%E4%BA%86%E9%BD%90%E9%B2%81%E8%BD%AF%E4%BB%B6%E5%A4%A7%E8%B5%9B%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%BC%8F%E6%B4%9E/</guid>
      <description>事情起因是这样的：
本来我计划今天处理齐软提交作品的事情，然而知乎真是好看……
等我想起了这回事，提交信息后，先弹出修改成功提示，然后告诉我没有登录。
what?没有登录但修改成功了？
吓得我感觉登进去，可不就是我刚刚填写的资料嘛。
为了排除在线编辑器本地保存重新加载的可能，我祭出curl。
然后再次登进去
嗯，没得洗了。直接修改数据的接口竟然不做登录验证。万一我写个循环这不就几乎删库了。
不过我是谁？我是正直的好青年，我当然选择把bug上交国家，不对，是告诉厂家，不对怎么说来着……算了，就是这个意思。
目前这个bug已经修复了，可惜也不能凭借发现这么严重漏洞直接拿个奖……</description>
    </item>
    
    <item>
      <title>日期相关的计算</title>
      <link>https://ntutn.top/posts/%E6%97%A5%E6%9C%9F%E7%9B%B8%E5%85%B3%E7%9A%84%E8%AE%A1%E7%AE%97/</link>
      <pubDate>Sun, 16 Sep 2018 03:11:37 +0800</pubDate>
      
      <guid>https://ntutn.top/posts/%E6%97%A5%E6%9C%9F%E7%9B%B8%E5%85%B3%E7%9A%84%E8%AE%A1%E7%AE%97/</guid>
      <description>今天（Sun, 16 Sep 2018 06:34:57 +0000）帮同学写一个日期相关的c++题，竟然耗费了很多时间，不得不感叹自己真是老了。 首先定义类用年月日(yy,mm,dd)存储日期 日期±天数，直接加减到“天”上，然后“多退少补”。 两日期之间相差天数。我是先计算两日前距元年元月元日的天数，然后直接相减。但我这么算，老是差几天，调试了好久，甚至我都一度打算放弃，直接调用上面做的日期加天数一天一天往上累加（可以预料到这会用多长时间）。 最后才检查出，竟然是判断闰年出错了，我把取余弄成了整除，闰年哭晕在厕所。 老了，真的老了。
 #include &amp;lt;iostream&amp;gt;using namespace std; class TMyDate { private: int yy,mm,dd; bool isrn(int year)//判断闰年  { if((year%4==0&amp;amp;&amp;amp;year%100!=0)||(year%400==0)) { return true; } return false; } int getDaysofmonth(int y,int m)//某年某月有多少天  { switch(m) { case 1: case 3: case 5: case 7: case 8: case 10: case 12: return 31; case 2: if(isrn(y)){ return 29; } return 28; default: return 30; } } int getTotaldays(int y,int m,int d){//某年月日距元年元月元日天数  int sum=0; sum+=d; m--; while(m--){ sum+=getDaysofmonth(y,m); } y--; while(y--){ sum+=isrn(y)?</description>
    </item>
    
    <item>
      <title>梦——2018年8月19日</title>
      <link>https://ntutn.top/posts/%E6%A2%A62018%E5%B9%B48%E6%9C%8819%E6%97%A5/</link>
      <pubDate>Sun, 19 Aug 2018 03:11:37 +0800</pubDate>
      
      <guid>https://ntutn.top/posts/%E6%A2%A62018%E5%B9%B48%E6%9C%8819%E6%97%A5/</guid>
      <description>有点意思的梦。 据说人每天都做梦，很多人说自己不做梦是因为在醒后的一分钟内就忘记了梦的内容，也忘记了自己忘记过什么。这也解释了，人记住的梦大多是噩梦的现象，因为做好梦刺激不够，这一分钟不能形成足够清冽的印象。
 So，我是盗梦空间看多了吗？为啥做个梦就非得这么惊心动魄？
 2018年8月19日
做了个梦，梦里有个非常牛逼的人，他通过一些细节发现了世界逻辑上不能自洽的问题，于是他认为自己身陷梦境，决定破解这个梦境回到真实世界。
他成功了。
我失眠了……</description>
    </item>
    
  </channel>
</rss>
