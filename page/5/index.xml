<?xml-stylesheet href="/rss.xsl" type="text/xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>归零幻想</title>
    <link>https://ntutn.top/</link>
    <description>Recent content on 归零幻想</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <copyright>CC BY-SA 4.0</copyright>
    <lastBuildDate>Wed, 14 Sep 2022 02:55:44 +0800</lastBuildDate>
    
        <atom:link href="https://ntutn.top/index.xml" rel="self" type="application/rss+xml" />
    
    
    
        <item>
        <title>三门问题</title>
        <link>https://ntutn.top/posts/%E4%B8%89%E9%97%A8%E9%97%AE%E9%A2%98/</link>
        <pubDate>Mon, 16 Sep 2019 03:11:37 +0800</pubDate>
        
        <guid>https://ntutn.top/posts/%E4%B8%89%E9%97%A8%E9%97%AE%E9%A2%98/</guid>
        <description>归零幻想 https://ntutn.top/posts/%E4%B8%89%E9%97%A8%E9%97%AE%E9%A2%98/ -&lt;!-- raw HTML omitted --&gt;
&lt;blockquote&gt;
&lt;p&gt;参赛者面前有三扇关闭着的门，其中一扇的后面是一辆汽车，选中后面有车的那扇门就可以赢得该汽车，
而另外两扇门后面则各藏有一只山羊。当参赛者选定了一扇门，但未去开启它的时候，主持人会开启剩
下两扇门中的一扇，露出其中一只山羊。主持人其后会问参赛者要不要更换选择，选另一扇仍然关着的门。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;那么，应不应该更换呢？
&lt;img src=&#34;https://i.loli.net/2020/08/20/eWcOG6t1FpUD5mC.png&#34; alt=&#34;1560925478346.png&#34;&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;h2 id=&#34;分析&#34;&gt;分析&lt;/h2&gt;
&lt;p&gt;假如你选择了A，那你中奖概率应为1/3.&lt;/p&gt;
&lt;p&gt;主持人在B、C中选了个没奖的，这与你的选择其实没影响，因为你没选的肯定有个没奖的。&lt;/p&gt;
&lt;p&gt;换与不换其实就相当于问你选A还是不选A。&lt;/p&gt;
&lt;h2 id=&#34;程序模拟&#34;&gt;程序模拟&lt;/h2&gt;
&lt;p&gt;有点绕，咱学软件的，就干脆让电脑跑一跑。&lt;/p&gt;
&lt;h3 id=&#34;代码&#34;&gt;代码&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color:#008b45;text-decoration:underline&#34;&gt;java.util.Random&lt;/span&gt;;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;Test&lt;/span&gt;{
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;main&lt;/span&gt;(String[] args) {
        Random ran=&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; Random();
        &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; c1=0,c2=0;
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt;(&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; i=0;i&amp;lt;1e6;i++){
            &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;boolean&lt;/span&gt; boxes[]={&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;false&lt;/span&gt;,&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;false&lt;/span&gt;,&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;false&lt;/span&gt;};
            boxes[ran.&lt;span style=&#34;color:#658b00&#34;&gt;nextInt&lt;/span&gt;(boxes.&lt;span style=&#34;color:#658b00&#34;&gt;length&lt;/span&gt;)]=&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;true&lt;/span&gt;;&lt;span style=&#34;color:#228b22&#34;&gt;//某个门后有奖
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; sel=ran.&lt;span style=&#34;color:#658b00&#34;&gt;nextInt&lt;/span&gt;(boxes.&lt;span style=&#34;color:#658b00&#34;&gt;length&lt;/span&gt;);&lt;span style=&#34;color:#228b22&#34;&gt;//随便选择一扇门
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; p=0;
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;while&lt;/span&gt;(p==sel||boxes[p]){&lt;span style=&#34;color:#228b22&#34;&gt;//主持人选择一扇没奖的门（且不与参与者选同一扇）
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;                p=ran.&lt;span style=&#34;color:#658b00&#34;&gt;nextInt&lt;/span&gt;(boxes.&lt;span style=&#34;color:#658b00&#34;&gt;length&lt;/span&gt;);
            }
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt;(boxes[sel]){&lt;span style=&#34;color:#228b22&#34;&gt;//不更换中奖
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;                c1++;
            }
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt;(boxes[0+1+2-sel-p]){&lt;span style=&#34;color:#228b22&#34;&gt;//更换中奖
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;                c2++;
            }
        }
        System.&lt;span style=&#34;color:#658b00&#34;&gt;out&lt;/span&gt;.&lt;span style=&#34;color:#658b00&#34;&gt;println&lt;/span&gt;(c1/1e6);
        System.&lt;span style=&#34;color:#658b00&#34;&gt;out&lt;/span&gt;.&lt;span style=&#34;color:#658b00&#34;&gt;println&lt;/span&gt;(c2/1e6);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;运行结果&#34;&gt;运行结果&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;0.332419
0.667581
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;看来是更换比较好了。&lt;/p&gt;
- https://ntutn.top/posts/%E4%B8%89%E9%97%A8%E9%97%AE%E9%A2%98/ - CC BY-SA 4.0</description>
        </item>
    
    
    
        <item>
        <title>大型数组按行遍历与按列遍历的区别</title>
        <link>https://ntutn.top/posts/%E5%A4%A7%E5%9E%8B%E6%95%B0%E7%BB%84%E6%8C%89%E8%A1%8C%E9%81%8D%E5%8E%86%E4%B8%8E%E6%8C%89%E5%88%97%E9%81%8D%E5%8E%86%E7%9A%84%E5%8C%BA%E5%88%AB/</link>
        <pubDate>Mon, 16 Sep 2019 03:11:37 +0800</pubDate>
        
        <guid>https://ntutn.top/posts/%E5%A4%A7%E5%9E%8B%E6%95%B0%E7%BB%84%E6%8C%89%E8%A1%8C%E9%81%8D%E5%8E%86%E4%B8%8E%E6%8C%89%E5%88%97%E9%81%8D%E5%8E%86%E7%9A%84%E5%8C%BA%E5%88%AB/</guid>
        <description>归零幻想 https://ntutn.top/posts/%E5%A4%A7%E5%9E%8B%E6%95%B0%E7%BB%84%E6%8C%89%E8%A1%8C%E9%81%8D%E5%8E%86%E4%B8%8E%E6%8C%89%E5%88%97%E9%81%8D%E5%8E%86%E7%9A%84%E5%8C%BA%E5%88%AB/ -&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;今天这学期开学第一天，上了《计算机操作系统原理》，老师提出个问题&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;对于一个很大的数组（如&lt;code&gt;70000×70000&lt;/code&gt;），按行遍历速度快还是按列遍历快，为什么？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;乍一看，程序时间复杂度一样，理论上不是应该一样快吗？难道老师在钓鱼？&lt;/p&gt;
&lt;p&gt;实践出真知，我们就写个程序跑一跑。&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;h2 id=&#34;程序&#34;&gt;程序&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;70000×70000我电脑在默认情况下开不下，我这里用20000×20000测试&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;按行遍历&#34;&gt;按行遍历&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#228b22&#34;&gt;/**
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt; * M1
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt; */&lt;/span&gt;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;M1&lt;/span&gt; {
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;main&lt;/span&gt;(String[] args) {
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;final&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; N=20000;
        &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt;[][] a = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt;[N][N];
        Long start=System.&lt;span style=&#34;color:#658b00&#34;&gt;currentTimeMillis&lt;/span&gt;();
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt;(&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; i=0;i&amp;lt;N;i++){
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; j = 0; j &amp;lt; N; j++) {
                a[i][j]=1;
            }
        }
        Long stop=System.&lt;span style=&#34;color:#658b00&#34;&gt;currentTimeMillis&lt;/span&gt;();
        System.&lt;span style=&#34;color:#658b00&#34;&gt;out&lt;/span&gt;.&lt;span style=&#34;color:#658b00&#34;&gt;println&lt;/span&gt;(stop-start);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;按列遍历&#34;&gt;按列遍历&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#228b22&#34;&gt;/**
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt; * M2
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt; */&lt;/span&gt;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;M2&lt;/span&gt; {
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;main&lt;/span&gt;(String[] args) {
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;final&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; N=20000;
        &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt;[][] a = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt;[N][N];
        Long start=System.&lt;span style=&#34;color:#658b00&#34;&gt;currentTimeMillis&lt;/span&gt;();
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt;(&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; i=0;i&amp;lt;N;i++){
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; j = 0; j &amp;lt; N; j++) {
                a[j][i]=1;
            }
        }
        Long stop=System.&lt;span style=&#34;color:#658b00&#34;&gt;currentTimeMillis&lt;/span&gt;();
        System.&lt;span style=&#34;color:#658b00&#34;&gt;out&lt;/span&gt;.&lt;span style=&#34;color:#658b00&#34;&gt;println&lt;/span&gt;(stop-start);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;运行结果&#34;&gt;运行结果&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2020/08/20/h7FJbzeVcMOpi3Z.png&#34; alt=&#34;1.png&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;分析&#34;&gt;分析&lt;/h2&gt;
&lt;p&gt;好吧，看上去的确是不一样。看这结果是不是感觉有点玄学，为啥差这么多？&lt;/p&gt;
&lt;p&gt;回想计算机组成原理学过的知识，&lt;a href=&#34;https://ntutn.top/show/19.html&#34;&gt;计算机组成原理笔记&lt;/a&gt;，存储器的层次化结构，高速缓存……&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;没错，就是这货！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2020/08/20/IwMb8ixF2g1k3mT.jpg&#34; alt=&#34;2.jpeg&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;存储器的层次化结构&lt;/p&gt;
&lt;blockquote&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;典型存取时间&lt;/th&gt;
&lt;th&gt;存储器&lt;/th&gt;
&lt;th&gt;典型容量&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1ns&lt;/td&gt;
&lt;td&gt;寄存器&lt;/td&gt;
&lt;td&gt;&amp;lt;1KB&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2ns&lt;/td&gt;
&lt;td&gt;高速缓存（cache）&lt;/td&gt;
&lt;td&gt;4MB&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;10ns&lt;/td&gt;
&lt;td&gt;主存储器（RAM和ROM）&lt;/td&gt;
&lt;td&gt;500MB~4GB&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;10ms&lt;/td&gt;
&lt;td&gt;辅助存储器（硬盘）&lt;/td&gt;
&lt;td&gt;40~500G&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;10s&lt;/td&gt;
&lt;td&gt;海量后备存储器（磁带库、光盘等）&lt;/td&gt;
&lt;td&gt;10~100TB&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;在很多主流编程语言中，数组在内存中存放的方式是“一行行”存放的，按行遍历，访问的内存地址分别为&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;x+1,x+2,x+3,……,x+n,x+n+1……
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;而按列遍历访问的顺序是&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;x+1,x+n+1,x+2n+1,……,x+n(n-1)+1,x+2,x+n+2,……
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;cache的命中率基本为0，结合几种存储器的速度，不难分析出原因了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;所以，针对这个问题，在回答时要说明前提，即数组在内存中的实际的编址方式是怎样的。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在我机器java这例子，就是按行遍历快了。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;2019年09月16日，我把实验过程给老师看了，老师补充这个速度除了与高速缓存的命中有关，还与编译器的内存管理有关。&lt;/p&gt;
- https://ntutn.top/posts/%E5%A4%A7%E5%9E%8B%E6%95%B0%E7%BB%84%E6%8C%89%E8%A1%8C%E9%81%8D%E5%8E%86%E4%B8%8E%E6%8C%89%E5%88%97%E9%81%8D%E5%8E%86%E7%9A%84%E5%8C%BA%E5%88%AB/ - CC BY-SA 4.0</description>
        </item>
    
    
    
        <item>
        <title>闷声作大死：删除电脑内的空文件夹</title>
        <link>https://ntutn.top/posts/%E9%97%B7%E5%A3%B0%E4%BD%9C%E5%A4%A7%E6%AD%BB%E5%88%A0%E9%99%A4%E7%94%B5%E8%84%91%E5%86%85%E7%9A%84%E7%A9%BA%E6%96%87%E4%BB%B6%E5%A4%B9/</link>
        <pubDate>Sun, 16 Jun 2019 03:11:37 +0800</pubDate>
        
        <guid>https://ntutn.top/posts/%E9%97%B7%E5%A3%B0%E4%BD%9C%E5%A4%A7%E6%AD%BB%E5%88%A0%E9%99%A4%E7%94%B5%E8%84%91%E5%86%85%E7%9A%84%E7%A9%BA%E6%96%87%E4%BB%B6%E5%A4%B9/</guid>
        <description>归零幻想 https://ntutn.top/posts/%E9%97%B7%E5%A3%B0%E4%BD%9C%E5%A4%A7%E6%AD%BB%E5%88%A0%E9%99%A4%E7%94%B5%E8%84%91%E5%86%85%E7%9A%84%E7%A9%BA%E6%96%87%E4%BB%B6%E5%A4%B9/ -&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;电脑卸载软件时，卸载程序常常不会把程序对应的空文件夹删掉，一般这时候我都是手动去把他删掉。&lt;/p&gt;
&lt;p&gt;我觉得有点麻烦，又想到电脑内可能还有其他的空文件夹。于是在网上找了个脚本删除电脑内的空文件夹，然后就遇到了麻烦……&lt;/p&gt;
&lt;p&gt;也许本文标题应该是&lt;strong&gt;一个空文件夹引发的血案&lt;/strong&gt;……&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;h2 id=&#34;删除电脑内的空文件夹&#34;&gt;删除电脑内的空文件夹&lt;/h2&gt;
&lt;p&gt;本来我曾经写过一个C#版本的删除电脑空文件夹的工具，原理很简单，就是递归嘛：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2020/08/20/az9OYcHf3nmdLID.png&#34; alt=&#34;1.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;但是这程序执行比较慢，而且占用内存不少……&lt;/p&gt;
&lt;p&gt;在网上搜索了下，果然不能闭门造车啊，有大佬写过批处理：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cmd&#34; data-lang=&#34;cmd&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;/f&lt;/span&gt; &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;tokens=*&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#cd5555&#34;&gt;%%&lt;/span&gt;a &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;in&lt;/span&gt; (&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;dir /b /ad /s C:\^|sort /r&amp;#39;&lt;/span&gt;) &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;do&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;rd&lt;/span&gt; &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;%%&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;a&amp;#34;&lt;/span&gt; /q &lt;span style=&#34;color:#b452cd&#34;&gt;2&lt;/span&gt;&amp;gt;nul
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;试用了下，效果相当不错。于是稍微修改使它能申请管理员权限，顺便修改下控制台颜色，看上去炫一点：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cmd&#34; data-lang=&#34;cmd&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;title&lt;/span&gt; 删除空文件夹
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;color&lt;/span&gt; 03
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;echo&lt;/span&gt; 程序需要管理员权限……
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;set&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;/a&lt;/span&gt; &lt;span style=&#34;color:#00688b&#34;&gt;_Debug&lt;/span&gt;=&lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;
:&lt;span style=&#34;color:#228b22&#34;&gt;:==========================================&lt;/span&gt;
:&lt;span style=&#34;color:#228b22&#34;&gt;: 获取管理员权限&lt;/span&gt;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;set&lt;/span&gt; &lt;span style=&#34;color:#00688b&#34;&gt;_Args&lt;/span&gt;=&lt;span style=&#34;color:#00688b&#34;&gt;%*&lt;/span&gt;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#00688b&#34;&gt;%~1&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#8b008b&#34;&gt;NEQ&lt;/span&gt; &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt; (
  &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;set&lt;/span&gt; &lt;span style=&#34;color:#00688b&#34;&gt;_Args&lt;/span&gt;=&lt;span style=&#34;color:#00688b&#34;&gt;%_Args:&amp;#34;=%&lt;/span&gt;
)
fltmc &lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;&amp;gt;nul &lt;span style=&#34;color:#b452cd&#34;&gt;2&lt;/span&gt;&amp;gt;nul || (
  &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;cd&lt;/span&gt; /d &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#00688b&#34;&gt;%~dp0&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;&lt;/span&gt;
  cmd /u /c echo Set UAC = CreateObject&lt;span style=&#34;color:#cd5555&#34;&gt;^(&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;Shell.Application&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;^)&lt;/span&gt; : UAC.ShellExecute &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;cmd.exe&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;/k cd &amp;#34;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#00688b&#34;&gt;%~dp0&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;&amp;#34; &amp;amp;&amp;amp; &amp;#34;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#00688b&#34;&gt;%~dpnx0&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;&amp;#34; &amp;#34;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#00688b&#34;&gt;%_Args%&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;&amp;#34;&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;runas&amp;#34;&lt;/span&gt;, 1 &amp;gt; &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#00688b&#34;&gt;%temp%&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;\GetAdmin.vbs&amp;#34;&lt;/span&gt;
  &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#00688b&#34;&gt;%temp%&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;\GetAdmin.vbs&amp;#34;&lt;/span&gt;
  &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;del&lt;/span&gt; /f /q &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#00688b&#34;&gt;%temp%&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;\GetAdmin.vbs&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;&amp;gt;nul &lt;span style=&#34;color:#b452cd&#34;&gt;2&lt;/span&gt;&amp;gt;nul
  &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;exit&lt;/span&gt;
)
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;/f&lt;/span&gt; &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;tokens=*&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#cd5555&#34;&gt;%%&lt;/span&gt;a &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;in&lt;/span&gt; (&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;dir /b /ad /s C:\^|sort /r&amp;#39;&lt;/span&gt;) &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;do&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;rd&lt;/span&gt; &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;%%&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;a&amp;#34;&lt;/span&gt; /q &lt;span style=&#34;color:#b452cd&#34;&gt;2&lt;/span&gt;&amp;gt;nul
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;而后我就把这个脚本放桌面上了，没事拿出来跑一跑，按下&lt;code&gt;Ctrl+Enter&lt;/code&gt;全屏，其实就是感觉看着控制台上一堆信息滚动很牛逼而已……&lt;del&gt;Dir溢出警告&lt;/del&gt;&lt;/p&gt;
&lt;h2 id=&#34;使用mediacreationtool修复windows&#34;&gt;使用MediaCreationTool修复Windows&lt;/h2&gt;
&lt;p&gt;这天我照例删了一遍空文件夹，然后打开应用商店更新游戏，然后发现打不开了……&lt;/p&gt;
&lt;p&gt;在网上找了好半天，才知道电脑内的空文件夹也是不能乱删的，比如&lt;code&gt;C:\Windows&lt;/code&gt;下的&lt;code&gt;AUInstallAgent&lt;/code&gt;和&lt;code&gt;AppReadiness&lt;/code&gt;也常常是空的，但删了应用商店就不能工作……&lt;/p&gt;
&lt;p&gt;试着重建这两个文件夹，无效，重启，无效。可是我真的不想重装或者重买啊……&lt;/p&gt;
&lt;p&gt;于是找到应用商店的设置，试着点“重置”，然后应用商店就消失了……&lt;/p&gt;
&lt;p&gt;好吧，情况更糟糕了，在网上找了好久，于是用MediaCreationTool试了试……&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2020/08/20/dbID9KehsiyHZxl.jpg&#34; alt=&#34;2.png&#34;&gt;
然而提示我电脑系统盘空间不足，于是下载DiskGenius调整系统盘空间容量……&lt;/p&gt;
&lt;h2 id=&#34;diskgenius调整系统盘空间容量&#34;&gt;DiskGenius调整系统盘空间容量&lt;/h2&gt;
&lt;p&gt;由于系统盘被占用，无法直接调整，于是进入PE：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2020/08/20/jWR9vg2FSDqyteV.png&#34; alt=&#34;3.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;点击“重新启动运行WinPE版DiskGenius软件”，第一次启动要准备PE环境，会比较慢。&lt;/p&gt;
&lt;p&gt;接下来在要调整的分区上点右键，调整分区大小：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2020/08/20/RPVCqOFuKQdXm4k.png&#34; alt=&#34;4.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;将挤出来的空间合并到C盘。这个过程非常慢，但一定要有耐心，保证电脑不会中间断电等。毕竟是对分区表的直接操作，一定要小心。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;请勿模仿：想当年本人用&lt;code&gt;Ghost&lt;/code&gt;还原系统的时候进度条走了1/4，突然感觉刚刚的选择有点问题，想重选一遍，于是按了电源键，然后就没有然后了……
数据无价，谨慎操作&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;重新安装windows10应用商店&#34;&gt;重新安装Windows10应用商店&lt;/h2&gt;
&lt;p&gt;理论上来说使用MediaCreationTool修复完Windows应用商店也应该回来了，但我的仍然没有出现只得自己重装一下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;用管理员身份打开&lt;code&gt;powershell&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;输入&lt;code&gt;Get-AppxPackage *WindowsStore* | Remove-AppxPackage&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;输入&lt;/li&gt;
&lt;/ol&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Get-AppXPackage *WindowsStore* -AllUsers | Foreach {Add-AppxPackage -DisableDevelopmentMode -Register &amp;quot;$($_.InstallLocation)\AppXManifest.xml&amp;quot;}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;刚装完可能是英文的，更新后语言就自动匹配了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2020/08/20/Ybuwv4RO5ITsEoH.png&#34; alt=&#34;5.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;美滋滋。&lt;/p&gt;
- https://ntutn.top/posts/%E9%97%B7%E5%A3%B0%E4%BD%9C%E5%A4%A7%E6%AD%BB%E5%88%A0%E9%99%A4%E7%94%B5%E8%84%91%E5%86%85%E7%9A%84%E7%A9%BA%E6%96%87%E4%BB%B6%E5%A4%B9/ - CC BY-SA 4.0</description>
        </item>
    
    
    
        <item>
        <title>在Windows10上安装血战上海滩</title>
        <link>https://ntutn.top/posts/%E5%9C%A8windows10%E4%B8%8A%E5%AE%89%E8%A3%85%E8%A1%80%E6%88%98%E4%B8%8A%E6%B5%B7%E6%BB%A9/</link>
        <pubDate>Sat, 01 Jun 2019 03:11:37 +0800</pubDate>
        
        <guid>https://ntutn.top/posts/%E5%9C%A8windows10%E4%B8%8A%E5%AE%89%E8%A3%85%E8%A1%80%E6%88%98%E4%B8%8A%E6%B5%B7%E6%BB%A9/</guid>
        <description>归零幻想 https://ntutn.top/posts/%E5%9C%A8windows10%E4%B8%8A%E5%AE%89%E8%A3%85%E8%A1%80%E6%88%98%E4%B8%8A%E6%B5%B7%E6%BB%A9/ -&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;《血战上海滩》是由北京欢乐亿派科技有限公司开发的单机FPS游戏，发行于2003年，是一个非常经典的老游戏了。
近来我打算把这个游戏找出来再玩一遍，可是在Windows10上安装还是有些问题……&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://images.ntutn.top/2022/04/cae87d561f3a723b0187e837e3e63ab0.gif&#34; alt=&#34;血战上海滩&#34;&gt;&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;h2 id=&#34;下载&#34;&gt;下载&lt;/h2&gt;
&lt;p&gt;下载不用多说，自己找资源吧，一共三百多兆的单机游戏。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;现在很多单机游戏下载时网站都会给你带上一个“启动器”来显示广告，恶心的很。找到文件夹中，注意血战上海滩的游戏文件是一个帽子的图标，大小为&lt;code&gt;1.87M&lt;/code&gt;，SHA1为&lt;code&gt;FE5A102AA9DE633FB6E388EAAEEA38BC43E8E7E4&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;启动&#34;&gt;启动&lt;/h2&gt;
&lt;p&gt;直接双击exe，然后……它免费帮你调了一下分辨率，就没反应了。&lt;/p&gt;
&lt;p&gt;貌似兼容性是个比较大的问题……于是在网上找了好久，终于知道，可以用命令行控制游戏窗口运行：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cmd&#34; data-lang=&#34;cmd&#34;&gt;shanghai.exe -windows
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;修改屏幕分辨率实现全屏&#34;&gt;修改屏幕分辨率实现全屏&lt;/h2&gt;
&lt;p&gt;倒是能运行了，只是……画面都在左上角，没法玩啊……&lt;/p&gt;
&lt;p&gt;所以再加上自动修改屏幕分辨率就可以全屏了。修改屏幕分辨率可以用&lt;code&gt;setres&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.majorgeeks.com/files/details/setres.html&#34;&gt;下载链接&lt;/a&gt;下载并将exe文件放到血战上海滩的游戏文件夹。&lt;/p&gt;
&lt;p&gt;于是用下面的命令：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cmd&#34; data-lang=&#34;cmd&#34;&gt;setres h800 v600
shanghai.exe -windows
setres h1920 v1080
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;1920*1080&lt;/code&gt;是我电脑的屏幕分辨率，注意换成自己的。&lt;/p&gt;
&lt;h2 id=&#34;隐藏显示任务栏&#34;&gt;隐藏显示任务栏&lt;/h2&gt;
&lt;p&gt;然而，这样还是有问题，就是这样“全屏”后任务栏并没有消失，虽然可以设置自动隐藏任务栏但总归还是不爽，于是写了个简单C#程序在启动游戏隐藏任务栏（虽然很简单，但没找到只用命令实现的方法）&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-C#&#34; data-lang=&#34;C#&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;using&lt;/span&gt; &lt;span style=&#34;color:#008b45;text-decoration:underline&#34;&gt;System&lt;/span&gt;;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;using&lt;/span&gt; &lt;span style=&#34;color:#008b45;text-decoration:underline&#34;&gt;System.Collections.Generic&lt;/span&gt;;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;using&lt;/span&gt; &lt;span style=&#34;color:#008b45;text-decoration:underline&#34;&gt;System.Linq&lt;/span&gt;;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;using&lt;/span&gt; &lt;span style=&#34;color:#008b45;text-decoration:underline&#34;&gt;System.Text&lt;/span&gt;;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;using&lt;/span&gt; &lt;span style=&#34;color:#008b45;text-decoration:underline&#34;&gt;System.Threading.Tasks&lt;/span&gt;;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;using&lt;/span&gt; &lt;span style=&#34;color:#008b45;text-decoration:underline&#34;&gt;System.Runtime.InteropServices&lt;/span&gt;;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;namespace&lt;/span&gt; &lt;span style=&#34;color:#008b45;text-decoration:underline&#34;&gt;ShowTaskBar&lt;/span&gt;
{
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;Program&lt;/span&gt;
    {
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; SW_HIDE = &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;;  &lt;span style=&#34;color:#228b22&#34;&gt;//隐藏任务栏
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; SW_RESTORE = &lt;span style=&#34;color:#b452cd&#34;&gt;9&lt;/span&gt;;&lt;span style=&#34;color:#228b22&#34;&gt;//显示任务栏
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#658b00&#34;&gt;        [DllImport(&amp;#34;user32.dll&amp;#34;)]&lt;/span&gt;
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;extern&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; ShowWindow(&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; hwnd, &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; nCmdShow);
&lt;span style=&#34;color:#658b00&#34;&gt;        [DllImport(&amp;#34;user32.dll&amp;#34;)]&lt;/span&gt;
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;extern&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; FindWindow(&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;string&lt;/span&gt; lpClassName, &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;string&lt;/span&gt; lpWindowName);
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;void&lt;/span&gt; Main(&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;string&lt;/span&gt;[] args)
        {
            ShowWindow(FindWindow(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;Shell_TrayWnd&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;null&lt;/span&gt;), SW_HIDE);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-C#&#34; data-lang=&#34;C#&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;using&lt;/span&gt; &lt;span style=&#34;color:#008b45;text-decoration:underline&#34;&gt;System&lt;/span&gt;;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;using&lt;/span&gt; &lt;span style=&#34;color:#008b45;text-decoration:underline&#34;&gt;System.Collections.Generic&lt;/span&gt;;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;using&lt;/span&gt; &lt;span style=&#34;color:#008b45;text-decoration:underline&#34;&gt;System.Linq&lt;/span&gt;;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;using&lt;/span&gt; &lt;span style=&#34;color:#008b45;text-decoration:underline&#34;&gt;System.Text&lt;/span&gt;;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;using&lt;/span&gt; &lt;span style=&#34;color:#008b45;text-decoration:underline&#34;&gt;System.Threading.Tasks&lt;/span&gt;;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;using&lt;/span&gt; &lt;span style=&#34;color:#008b45;text-decoration:underline&#34;&gt;System.Runtime.InteropServices&lt;/span&gt;;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;namespace&lt;/span&gt; &lt;span style=&#34;color:#008b45;text-decoration:underline&#34;&gt;ShowTaskBar&lt;/span&gt;
{
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;Program&lt;/span&gt;
    {
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; SW_HIDE = &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;;  &lt;span style=&#34;color:#228b22&#34;&gt;//隐藏任务栏
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; SW_RESTORE = &lt;span style=&#34;color:#b452cd&#34;&gt;9&lt;/span&gt;;&lt;span style=&#34;color:#228b22&#34;&gt;//显示任务栏
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#658b00&#34;&gt;        [DllImport(&amp;#34;user32.dll&amp;#34;)]&lt;/span&gt;
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;extern&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; ShowWindow(&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; hwnd, &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; nCmdShow);
&lt;span style=&#34;color:#658b00&#34;&gt;        [DllImport(&amp;#34;user32.dll&amp;#34;)]&lt;/span&gt;
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;extern&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; FindWindow(&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;string&lt;/span&gt; lpClassName, &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;string&lt;/span&gt; lpWindowName);
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;void&lt;/span&gt; Main(&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;string&lt;/span&gt;[] args)
        {
            ShowWindow(FindWindow(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;Shell_TrayWnd&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;null&lt;/span&gt;), SW_RESTORE);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;编译并将生成文件也放到游戏文件夹。这样我们就可以用一个&lt;code&gt;start.cmd&lt;/code&gt;打开游戏：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cmd&#34; data-lang=&#34;cmd&#34;&gt;setres h800 v600
hidetaskbar
shanghai.exe -windows
showtaskbar
setres h1920 v1080
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;体验相当完美。&lt;/p&gt;
- https://ntutn.top/posts/%E5%9C%A8windows10%E4%B8%8A%E5%AE%89%E8%A3%85%E8%A1%80%E6%88%98%E4%B8%8A%E6%B5%B7%E6%BB%A9/ - CC BY-SA 4.0</description>
        </item>
    
    
    
        <item>
        <title>数据结构第三次测试</title>
        <link>https://ntutn.top/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%89%E6%AC%A1%E6%B5%8B%E8%AF%95/</link>
        <pubDate>Sat, 01 Jun 2019 03:11:37 +0800</pubDate>
        
        <guid>https://ntutn.top/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%89%E6%AC%A1%E6%B5%8B%E8%AF%95/</guid>
        <description>归零幻想 https://ntutn.top/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%89%E6%AC%A1%E6%B5%8B%E8%AF%95/ -&lt;!-- raw HTML omitted --&gt;
&lt;blockquote&gt;
&lt;p&gt;数据结构测试，树部分，水题&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;一&#34;&gt;一&lt;/h2&gt;
&lt;p&gt;假设二叉树的数据元素为字符，采用二叉链式存储结构。二叉树ADT实现的大部分代码已经给出，其中采用完全前序序列创建二叉树。请补充写出下列两个操作函数。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注意： 答案区只写出两个函数，其他代码不允许修改和重写、提交！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;计算以某结点为根的二叉树的高度；&lt;/li&gt;
&lt;li&gt;以前序顺序输出各个元素结点为根的子树的高度；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;例如：有如右图的二叉树   &lt;img src=&#34;https://i.loli.net/2020/08/20/axyNCbMzRcpDtY7.jpg&#34; alt=&#34;1559400741461.jpg&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;输入&#34;&gt;输入&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;ABD@@E@@C@F@@
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;输出&#34;&gt;输出&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Height(A)=3
Height(B)=2
Height(D)=1
Height(E)=1
Height(C)=2
Height(F)=1
&lt;/code&gt;&lt;/pre&gt;&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;已给出的代码如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#1e889b&#34;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#1e889b&#34;&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;using&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;namespace&lt;/span&gt; std;
&lt;span style=&#34;color:#228b22&#34;&gt;//数据元素类型
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;char&lt;/span&gt; ElemType;
&lt;span style=&#34;color:#228b22&#34;&gt;//二叉树结点定义
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;TreeNode&lt;/span&gt;
{	ElemType data;
	&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;TreeNode&lt;/span&gt; *lson, *rson;
} TreeNode;
&lt;span style=&#34;color:#228b22&#34;&gt;//二叉树类
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;BinaryTree&lt;/span&gt;
{  &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;private&lt;/span&gt;:
	TreeNode *root;
   &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt;:
	BinaryTree() { root = &lt;span style=&#34;color:#658b00&#34;&gt;NULL&lt;/span&gt;; };
	~BinaryTree() { MakeEmpty(root); }
	&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;MakeEmpty&lt;/span&gt;(TreeNode *t);
	&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;create&lt;/span&gt;( ) { root = cp_create(root); };  &lt;span style=&#34;color:#228b22&#34;&gt;//完全前序建立二叉树，空指针用@表示
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;	TreeNode *&lt;span style=&#34;color:#008b45&#34;&gt;cp_create&lt;/span&gt;(TreeNode *t);
	
	&lt;span style=&#34;color:#228b22&#34;&gt;//******  要补充的函数height ********
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;height&lt;/span&gt;(TreeNode *t) ;    &lt;span style=&#34;color:#228b22&#34;&gt;//求二叉树的高度
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;output&lt;/span&gt;() { Pro_height(root); };
	&lt;span style=&#34;color:#228b22&#34;&gt;//******  要补充的函数 Pro_height **********
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;Pro_height&lt;/span&gt;(TreeNode *t);  &lt;span style=&#34;color:#228b22&#34;&gt;// 前序顺序输出各个元素结点为根的子树的高度      
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;};
&lt;span style=&#34;color:#228b22&#34;&gt;//二叉树置空
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;void&lt;/span&gt; BinaryTree::MakeEmpty(TreeNode *t)
{	&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (t != &lt;span style=&#34;color:#658b00&#34;&gt;NULL&lt;/span&gt;)
	{	MakeEmpty(t-&amp;gt;lson);
		MakeEmpty(t-&amp;gt;rson);
		&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;delete&lt;/span&gt; t;
	}
}
&lt;span style=&#34;color:#228b22&#34;&gt;//完全前序序列创建二叉树，空指针用@表示
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;TreeNode *BinaryTree::cp_create(TreeNode *t)
{	ElemType v;
	cin &amp;gt;&amp;gt; v;
	&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (v != &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;@&amp;#39;&lt;/span&gt;)
	{	t = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; TreeNode;
		t-&amp;gt;data = v;
		t-&amp;gt;lson = cp_create(t-&amp;gt;lson);
		t-&amp;gt;rson = cp_create(t-&amp;gt;rson);
	}
	&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;else&lt;/span&gt; t = &lt;span style=&#34;color:#658b00&#34;&gt;NULL&lt;/span&gt;;
	&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; t;
}
&lt;span style=&#34;color:#228b22&#34;&gt;//********************  需要补充写出的两个函数  ****************************
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;//*******************************************************************************
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;//主函数
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;main&lt;/span&gt;()
{	BinaryTree t;
	t.create();
	t.output();	
	&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;answer&#34;&gt;Answer&lt;/h3&gt;
&lt;p&gt;求树高度，递归。貌似没有必要判断lson和rson是否为空，不过凑合着吧……&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; BinaryTree::height(TreeNode* t)
{
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt;(t==&lt;span style=&#34;color:#658b00&#34;&gt;NULL&lt;/span&gt;){
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;;
    }
    &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; l=&lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;,r=&lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;;
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt;(t-&amp;gt;lson!=&lt;span style=&#34;color:#658b00&#34;&gt;NULL&lt;/span&gt;){
        l=height(t-&amp;gt;lson);
    }
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt;(t-&amp;gt;rson!=&lt;span style=&#34;color:#658b00&#34;&gt;NULL&lt;/span&gt;){
        r=height(t-&amp;gt;rson);
    }
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;max&lt;/span&gt;(l,r)+&lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;;
}
&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;void&lt;/span&gt; BinaryTree::Pro_height(TreeNode* t)
{
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt;(t==&lt;span style=&#34;color:#658b00&#34;&gt;NULL&lt;/span&gt;){
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt;;
    }
    cout&amp;lt;&amp;lt;&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;Height(&amp;#34;&lt;/span&gt;&amp;lt;&amp;lt;t-&amp;gt;data&amp;lt;&amp;lt;&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;)=&amp;#34;&lt;/span&gt;&amp;lt;&amp;lt;height(t)&amp;lt;&amp;lt;endl;
    Pro_height(t-&amp;gt;lson);
    Pro_height(t-&amp;gt;rson);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;二&#34;&gt;二&lt;/h2&gt;
&lt;p&gt;假设二叉树的数据元素为字符，采用二叉链式存储结构。二叉树ADT实现的大部分代码已经给出，其中二叉树采用完全前序序列创建。请补充一个二叉树的输出函数，要求按目录缩进的形式输出一棵二叉树，同时要输出目录的层次。层次占2位、元素占1位，间隔4个位置（即共占7个位置）。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注意：答案区只写指定补充的函数代码，其他给定的代码不允许重写、修改和提交！
例如：有如右图的二叉树   &lt;img src=&#34;https://ntutn.top/file/down/1559400741461.jpg&#34; alt=&#34;二叉树&#34; title=&#34;二叉树&#34;&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;输入-1&#34;&gt;输入&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;ABD@@E@@C@F@@
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;输出-1&#34;&gt;输出：&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt; 1A
          2B
                   3D
                   3E
         2C
                   3F
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;给出的代码如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#1e889b&#34;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#1e889b&#34;&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;#include&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;using&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;namespace&lt;/span&gt; std;
&lt;span style=&#34;color:#228b22&#34;&gt;//数据元素类型
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;char&lt;/span&gt; ElemType;
&lt;span style=&#34;color:#228b22&#34;&gt;//二叉树结点定义
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;TreeNode&lt;/span&gt;
{	ElemType data;
	&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;TreeNode&lt;/span&gt; *lson, *rson;
} TreeNode;
&lt;span style=&#34;color:#228b22&#34;&gt;//二叉树类
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;BinaryTree&lt;/span&gt;
{ &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;private&lt;/span&gt;:
	TreeNode *root;
  &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt;:
	BinaryTree() { root = &lt;span style=&#34;color:#658b00&#34;&gt;NULL&lt;/span&gt;; };
	~BinaryTree() { MakeEmpty(root); }
	&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;MakeEmpty&lt;/span&gt;(TreeNode *t);
	&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;create&lt;/span&gt;( ) { root = cp_create(root); };  &lt;span style=&#34;color:#228b22&#34;&gt;//完全前序建立二叉树，空指针用@表示
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;	TreeNode *&lt;span style=&#34;color:#008b45&#34;&gt;cp_create&lt;/span&gt;(TreeNode *t);
	&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;output&lt;/span&gt;( ) { Index_print(root,&lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;); };
	&lt;span style=&#34;color:#228b22&#34;&gt;//*********** 下面是需要自己完成的函数 ******************   
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;Index_print&lt;/span&gt;(TreeNode *t,&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; l);  &lt;span style=&#34;color:#228b22&#34;&gt;//缩进目录形式输出二叉树      
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;};
&lt;span style=&#34;color:#228b22&#34;&gt;//二叉树置空
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;void&lt;/span&gt; BinaryTree::MakeEmpty(TreeNode *t)
{	&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (t != &lt;span style=&#34;color:#658b00&#34;&gt;NULL&lt;/span&gt;)
	{	MakeEmpty(t-&amp;gt;lson);
		MakeEmpty(t-&amp;gt;rson);
		&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;delete&lt;/span&gt; t;
	}
}
&lt;span style=&#34;color:#228b22&#34;&gt;//完全前序序列创建二叉树，空指针用@表示
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;TreeNode *BinaryTree::cp_create(TreeNode *t)
{	ElemType v;
	cin &amp;gt;&amp;gt; v;
	&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (v != &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;@&amp;#39;&lt;/span&gt;)
	{	t = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; TreeNode;
		t-&amp;gt;data = v;
		t-&amp;gt;lson = cp_create(t-&amp;gt;lson);
		t-&amp;gt;rson = cp_create(t-&amp;gt;rson);
	}
	&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;else&lt;/span&gt; t = &lt;span style=&#34;color:#658b00&#34;&gt;NULL&lt;/span&gt;;
	&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; t;
}
&lt;span style=&#34;color:#228b22&#34;&gt;//*****下面是要补充的函数Index_print  *************
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;//*************************************************
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;//主函数
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;main&lt;/span&gt;()
{	BinaryTree t;
	t.create();      &lt;span style=&#34;color:#228b22&#34;&gt;//创建二叉树
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;	t.output();       &lt;span style=&#34;color:#228b22&#34;&gt;//按规定格式输出二叉树
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;	cout&amp;lt;&amp;lt; endl;
	&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;answer-1&#34;&gt;Answer&lt;/h3&gt;
&lt;p&gt;完全前序遍历，递归，注意输出格式。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;void&lt;/span&gt; BinaryTree::Index_print(TreeNode* t, &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; l)
{
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt;(t==&lt;span style=&#34;color:#658b00&#34;&gt;NULL&lt;/span&gt;){
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt;;
    }
    cout&amp;lt;&amp;lt;&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39; &amp;#39;&lt;/span&gt;;
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt;(&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; i=&lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;;i&amp;lt;l-&lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;;i++){
        cout&amp;lt;&amp;lt;&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;       &amp;#34;&lt;/span&gt;;
    }
    cout&amp;lt;&amp;lt;l&amp;lt;&amp;lt;t-&amp;gt;data&amp;lt;&amp;lt;endl;
    Index_print(t-&amp;gt;lson,l+&lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;);
    Index_print(t-&amp;gt;rson,l+&lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;- https://ntutn.top/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%89%E6%AC%A1%E6%B5%8B%E8%AF%95/ - CC BY-SA 4.0</description>
        </item>
    
    
    
        <item>
        <title>稀疏矩阵的压缩存储</title>
        <link>https://ntutn.top/posts/%E7%A8%80%E7%96%8F%E7%9F%A9%E9%98%B5%E7%9A%84%E5%8E%8B%E7%BC%A9%E5%AD%98%E5%82%A8/</link>
        <pubDate>Sat, 01 Jun 2019 03:11:37 +0800</pubDate>
        
        <guid>https://ntutn.top/posts/%E7%A8%80%E7%96%8F%E7%9F%A9%E9%98%B5%E7%9A%84%E5%8E%8B%E7%BC%A9%E5%AD%98%E5%82%A8/</guid>
        <description>归零幻想 https://ntutn.top/posts/%E7%A8%80%E7%96%8F%E7%9F%A9%E9%98%B5%E7%9A%84%E5%8E%8B%E7%BC%A9%E5%AD%98%E5%82%A8/ -&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;特殊矩阵在采用二维数组存储时，尽管矩阵操作的算法都很简单，但是其空间的利用率很低。 系数矩阵就是一种应用很广泛的特殊的矩阵。现要求稀疏矩阵采用“压缩”存储，实现矩阵的常用操作，如输出、转置、求和等。&lt;/p&gt;
&lt;h2 id=&#34;question&#34;&gt;Question&lt;/h2&gt;
&lt;p&gt;矩阵采用“压缩”存储，实现矩阵的常用操作，如输出、转置、求和等。&lt;/p&gt;
&lt;p&gt;矩阵的输入：有多行，第1行包括三个整数，分别是矩阵的大小m,n及非零元素的个数r。后面r行分别输入各个非零元素的 行、列、值&lt;/p&gt;
&lt;p&gt;矩阵的输出：按人们习惯的矩阵格式输出，即输出一个&lt;code&gt;m*n&lt;/code&gt;的矩阵，是零元素的输出0，非零元素输出元素值。&lt;/p&gt;
&lt;p&gt;例如：输入如下：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;100 90 5 //矩阵的行数为100，列数为90，共5个非零元素。
1 10 100 //a(1,10)=100
50 60 200//a(50,60)=200
50 80 100//a(50,80)=100
60 60 200//a(60,60)=200
99 89 10//a(99,89)=10
100 90 4 //矩阵b的行数为100，列数为90，共4个非零元素。
1 1 10 //b(1,1)=10
50 60 -200//b(50,60)=-200
50 80 100 //b(50,80)=100
70 70 10 //b(70,70)=10
&lt;/code&gt;&lt;/pre&gt;&lt;!-- raw HTML omitted --&gt;
&lt;h2 id=&#34;example&#34;&gt;Example&lt;/h2&gt;
&lt;h3 id=&#34;input&#34;&gt;Input&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;100 90 5
1 10 100
50 60 200
50 80 100
60 60 200
99 89 10
100 90 4
1 1 10
50 60 -200
50 80 100
70 70 10
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;output&#34;&gt;Output&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;The transformed matrix  is:
10 1 100
60 50 200
60 60 200
80 50 100
89 99 10
The added matrix is:
1 1 10
1 10 100
50 80 200
60 60 200
70 70 10
99 89 10
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;分析&#34;&gt;分析&lt;/h2&gt;
&lt;p&gt;首先题目描述有错。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;按人们习惯的矩阵格式输出
应该是仍然按照题目中格式输出。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;所谓矩阵的压缩存储，实际上是在矩阵中元素较少时，只存非零元素的方法。在矩阵比较特殊（如三角阵）或矩阵元素比较稀疏的情况下能大大节省存储空间。但同时，压缩存储也会导致访问效率下降。&lt;/p&gt;
&lt;p&gt;所以这里我们定义了结构体来存储矩阵中的某个元素：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;struct&lt;/span&gt;{
    &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; row;
    &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; column;
    &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; data;
}point;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;此题中第一部分，矩阵转置，通过观察即可知道，行变列列变行，只需交换元素&lt;code&gt;row&lt;/code&gt;和&lt;code&gt;column&lt;/code&gt;即可。&lt;/p&gt;
&lt;p&gt;但交换后有个问题，即按照题目给出的标准输出，显然先输出行号小的元素，行号相等先输出列号小的元素。这就涉及了结构体数组的二级排序，也不难：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;int cmp(const void *p1,const void *p2){
    if(((point*)p1)-&amp;gt;row==((point*)p2)-&amp;gt;row){
        return ((point*)p1)-&amp;gt;column-((point*)p2)-&amp;gt;column;
    }
    return ((point*)p1)-&amp;gt;row-((point*)p2)-&amp;gt;row;
}
qsort(res,pA,sizeof(point),cmp);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;至于第二问，两矩阵相加，类似归并的思想，每次找到小的拿过来，两者相等就相加。不过这里注意，两者相加有可能结果为0，要消去这组数据。&lt;/p&gt;
&lt;h2 id=&#34;anwser&#34;&gt;Anwser&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#1e889b&#34;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#1e889b&#34;&gt;&amp;lt;cstdlib&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;using&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;namespace&lt;/span&gt; std;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;struct&lt;/span&gt;{
    &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; row;
    &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; column;
    &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; data;
}point;
&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;cmp&lt;/span&gt;(&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;void&lt;/span&gt; *p1,&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;void&lt;/span&gt; *p2){
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt;(((point*)p1)-&amp;gt;row==((point*)p2)-&amp;gt;row){
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; ((point*)p1)-&amp;gt;column-((point*)p2)-&amp;gt;column;
    }
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; ((point*)p1)-&amp;gt;row-((point*)p2)-&amp;gt;row;
}
&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;printMatrix&lt;/span&gt;(point*p,&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; n){
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt;(&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; i=&lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;;i&amp;lt;n;i++){
        cout&amp;lt;&amp;lt;p[i].row&amp;lt;&amp;lt;&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39; &amp;#39;&lt;/span&gt;&amp;lt;&amp;lt;p[i].column&amp;lt;&amp;lt;&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39; &amp;#39;&lt;/span&gt;&amp;lt;&amp;lt;p[i].data&amp;lt;&amp;lt;endl;
    }
}
&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;cmpPos&lt;/span&gt;(point*p1,point*p2){&lt;span style=&#34;color:#228b22&#34;&gt;//其实这个函数多余，直接用前面那个cmp函数也能达到比较的目的，不过我不习惯
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt;(p1-&amp;gt;row!=p2-&amp;gt;row){
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; p1-&amp;gt;row-p2-&amp;gt;row;
    }
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt;(p1-&amp;gt;column!=p2-&amp;gt;column){
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; p1-&amp;gt;column-p2-&amp;gt;column;
    }
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;;
}
&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;main&lt;/span&gt;()
{
    &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; mA,nA,pA;&lt;span style=&#34;color:#228b22&#34;&gt;//第一个矩阵的行数、列数、非空元素数目
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; mB,nB,pB;
    point*dataA;
    point*dataB;
    point*res;&lt;span style=&#34;color:#228b22&#34;&gt;//存储结果
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    cin&amp;gt;&amp;gt;mA&amp;gt;&amp;gt;nA&amp;gt;&amp;gt;pA;
    dataA=&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; point[pA];
    res=&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; point[pA];
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt;(&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; i=&lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;;i&amp;lt;pA;i++){
        cin&amp;gt;&amp;gt;dataA[i].row&amp;gt;&amp;gt;dataA[i].column&amp;gt;&amp;gt;dataA[i].data;
        res[i].row=dataA[i].column;&lt;span style=&#34;color:#228b22&#34;&gt;//转置
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        res[i].column=dataA[i].row;
        res[i].data=dataA[i].data;
    }
    cin&amp;gt;&amp;gt;mB&amp;gt;&amp;gt;nB&amp;gt;&amp;gt;pB;
    dataB=&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; point[pB];
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt;(&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; i=&lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;;i&amp;lt;pB;i++){
        cin&amp;gt;&amp;gt;dataB[i].row&amp;gt;&amp;gt;dataB[i].column&amp;gt;&amp;gt;dataB[i].data;
    }
    qsort(res,pA,&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;sizeof&lt;/span&gt;(point),cmp);
    cout&amp;lt;&amp;lt;&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;The transformed matrix  is:&amp;#34;&lt;/span&gt;&amp;lt;&amp;lt;endl;
    printMatrix(res,pA);
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;delete&lt;/span&gt;[] res;
    res=&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; point[pA+pB];&lt;span style=&#34;color:#228b22&#34;&gt;//结果元素数目总小于等于二者之和
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    point*p1=dataA;
    point*p2=dataB;
    point*p3=res;
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;while&lt;/span&gt;(p1&amp;lt;dataA+pA&amp;amp;&amp;amp;p2&amp;lt;dataB+pB){
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt;(cmpPos(p1,p2)&amp;lt;&lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;){
            *p3=*p1;
            p1++;
        }&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt;(cmpPos(p1,p2)==&lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;){
            *p3=*p1;
            p3-&amp;gt;data=p1-&amp;gt;data+p2-&amp;gt;data;
            p1++;
            p2++;
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt;(p3-&amp;gt;data==&lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;){
                p3--;
            }
        }&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;else&lt;/span&gt;{
            *p3=*p2;
            p2++;
        }
        p3++;
    }
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;while&lt;/span&gt;(p1&amp;lt;dataA+pA){
        *p3=*p1;
        p3++;
        p1++;
    }
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;while&lt;/span&gt;(p2&amp;lt;dataB+pB){
        *p3=*p2;
        p3++;
        p2++;
    }
    cout&amp;lt;&amp;lt;&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;The added matrix is:&amp;#34;&lt;/span&gt;&amp;lt;&amp;lt;endl;
    printMatrix(res,p3-res);
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;delete&lt;/span&gt;[] res;
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;delete&lt;/span&gt;[] dataA;
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;delete&lt;/span&gt;[] dataB;
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;- https://ntutn.top/posts/%E7%A8%80%E7%96%8F%E7%9F%A9%E9%98%B5%E7%9A%84%E5%8E%8B%E7%BC%A9%E5%AD%98%E5%82%A8/ - CC BY-SA 4.0</description>
        </item>
    
    
    
        <item>
        <title>统计递归子问题个数</title>
        <link>https://ntutn.top/posts/%E7%BB%9F%E8%AE%A1%E9%80%92%E5%BD%92%E5%AD%90%E9%97%AE%E9%A2%98%E4%B8%AA%E6%95%B0/</link>
        <pubDate>Fri, 17 May 2019 03:11:37 +0800</pubDate>
        
        <guid>https://ntutn.top/posts/%E7%BB%9F%E8%AE%A1%E9%80%92%E5%BD%92%E5%AD%90%E9%97%AE%E9%A2%98%E4%B8%AA%E6%95%B0/</guid>
        <description>归零幻想 https://ntutn.top/posts/%E7%BB%9F%E8%AE%A1%E9%80%92%E5%BD%92%E5%AD%90%E9%97%AE%E9%A2%98%E4%B8%AA%E6%95%B0/ -&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;分治策略是算法设计的重要策略之一，该策略的基本思想是把问题进行分解成一些子问题，通过子问题的求解完成对原问题的求解。其关键是分解和合并，好的分解或合并方法才会产生高效的分治算法。&lt;/p&gt;
&lt;p&gt;分治策略设计出的算法最常见的就是递归算法。但是如果在分解时，分解出的子问题有很多是重复的，那么这样的分治（递归）算法求解问题的效率就非常低。例如斐波那契数问题，如果采用递归求解，算法效率非常低：O(2^n)。而如果采用递推求解(动态规划自底向上求解)，算法效率非常高：O(n)。&lt;/p&gt;
&lt;h2 id=&#34;question&#34;&gt;Question&lt;/h2&gt;
&lt;p&gt;现在请你编写程序，统计计算一个斐波那契数时分解出的各子问题的个数。&lt;/p&gt;
&lt;p&gt;斐波那契数的定义如下：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Fib(0)=0
Fib(1)=1
Fib(n)=Fib(n-1)+Fib(n-2)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输入：一个整数n，即计算&lt;code&gt;Fib(n)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;输出：n+1行，即各个子问题的值及该子问题的个数。&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;h2 id=&#34;example&#34;&gt;Example&lt;/h2&gt;
&lt;h3 id=&#34;input&#34;&gt;Input&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;5
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;output&#34;&gt;Output&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Fib(0)=0,spn=3
Fib(1)=1,spn=5
Fib(2)=1,spn=3
Fib(3)=2,spn=2
Fib(4)=3,spn=1
Fib(5)=5,spn=1
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;分析&#34;&gt;分析&lt;/h2&gt;
&lt;p&gt;一大段分治思想的介绍，递归与递推的区别，我以为这题用递归会超时，要用递推求解，于是入坑……&lt;/p&gt;
&lt;p&gt;这题要统计子问题个数，递推或者递归加备忘录根本没重复的计算怎么统计……&lt;/p&gt;
&lt;p&gt;不死心的我又仔细研究递推子问题个数的规律，发现子问题个数正好是一个反着的斐波那契数列（结尾元素特殊处理），所以可以正向递推求数列，反向递推求子问题个数。&lt;/p&gt;
&lt;p&gt;不过特殊情况研究的有点头疼，暂时就不搞了，下面给出的是老老实实递归求解的程序。&lt;/p&gt;
&lt;h2 id=&#34;answer&#34;&gt;Answer&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#1e889b&#34;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#1e889b&#34;&gt;&amp;lt;cstring&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;using&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;namespace&lt;/span&gt; std;
&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt;*spn;
&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt;*data;
&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;fib&lt;/span&gt;(&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; n){
    spn[n]++;
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt;(n==&lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;){
        data[&lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;]=&lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;;
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;;
    }
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt;(n==&lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;){
        data[&lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;]=&lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;;
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;;
    }
    &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; res=fib(n-&lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;)+fib(n-&lt;span style=&#34;color:#b452cd&#34;&gt;2&lt;/span&gt;);
    data[n]=res;
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; res;
}
&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;main&lt;/span&gt;()
{
    &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; n;
    cin&amp;gt;&amp;gt;n;
    spn=&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt;[n+&lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;];
    data=&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt;[n+&lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;];
    memset(spn,&lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;,(n+&lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;)*&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;sizeof&lt;/span&gt;(&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt;));
    memset(data,-&lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;,(n+&lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;)*&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;sizeof&lt;/span&gt;(&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt;));
    data[&lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;]=&lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;;
    data[&lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;]=&lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;;
    fib(n);
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt;(&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; i=&lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;;i&amp;lt;=n;i++){
        cout&amp;lt;&amp;lt;&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;Fib(&amp;#34;&lt;/span&gt;&amp;lt;&amp;lt;i&amp;lt;&amp;lt;&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;)=&amp;#34;&lt;/span&gt;&amp;lt;&amp;lt;data[i]&amp;lt;&amp;lt;&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;,spn=&amp;#34;&lt;/span&gt;&amp;lt;&amp;lt;spn[i]&amp;lt;&amp;lt;endl;
    }
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;- https://ntutn.top/posts/%E7%BB%9F%E8%AE%A1%E9%80%92%E5%BD%92%E5%AD%90%E9%97%AE%E9%A2%98%E4%B8%AA%E6%95%B0/ - CC BY-SA 4.0</description>
        </item>
    
    
    
        <item>
        <title>二叉树ADT的实现</title>
        <link>https://ntutn.top/posts/%E4%BA%8C%E5%8F%89%E6%A0%91adt%E7%9A%84%E5%AE%9E%E7%8E%B0/</link>
        <pubDate>Tue, 14 May 2019 03:11:37 +0800</pubDate>
        
        <guid>https://ntutn.top/posts/%E4%BA%8C%E5%8F%89%E6%A0%91adt%E7%9A%84%E5%AE%9E%E7%8E%B0/</guid>
        <description>归零幻想 https://ntutn.top/posts/%E4%BA%8C%E5%8F%89%E6%A0%91adt%E7%9A%84%E5%AE%9E%E7%8E%B0/ -&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;人工智能知识点整理Question&lt;/p&gt;
&lt;p&gt;假设二叉数的数据元素为字符，采用二叉链式存储结构。请编码实现二叉树ADT，其中包括创建二叉树、遍历二叉树（深度、广度）、求二叉树的深度（高度）、计算二叉树的元素个数、计算二叉树的叶子数、二叉树的格式输出等。&lt;/p&gt;
&lt;p&gt;根据输入的符号，执行相应的操作。如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;C：根据完全前序序列创建二叉树，#表示空结点（空子树）；输入：二叉树的完全前序序列，创建成功输出 &lt;code&gt;Created success!&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;H：求二叉树的高度；   输出： &lt;code&gt;Height=高度&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;L：计算二叉树的叶子数；输出：&lt;code&gt;Leaves=叶子个数&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;N：计算二叉树中元素总个数；输出：&lt;code&gt;Nodes=结点个数&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;1：先序遍历二叉树；输出：&lt;code&gt;Preorder is:序列 .&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;2：中序遍历二叉树；输出：&lt;code&gt;Inorder is:序列 .&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;3：后序遍历二叉树；输出：&lt;code&gt;Postorder is:序列 .&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;4：广度遍历二叉树；输出：&lt;code&gt;BFSorder is:序列 .&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;F：查找值为x的结点个数；输出：&lt;code&gt;The count of x is 个数 .&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;P：以目录缩格文本形式输出所有节点。输出：&lt;code&gt;The tree is:&lt;/code&gt;（换行，下面各行是输出的二叉树）&lt;/li&gt;
&lt;li&gt;X：退出&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;h2 id=&#34;example&#34;&gt;Example&lt;/h2&gt;
&lt;h3 id=&#34;input&#34;&gt;Input&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;C
ABC##DE#G##F###
H
L
N
1
2
3
4
F
A
P
X
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;output&#34;&gt;Output&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Created success!
Height=5
Leaves=3
Nodes=7
Preorder is:A B C D E G F .
Inorder is:C B E G D F A .
Postorder is:C G E F D B A .
BFSorder is:A B C D E F G .
The count of A is 1
The tree is:
A
  B
    C
    D
      E
        G
      F
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;分析&#34;&gt;分析&lt;/h2&gt;
&lt;p&gt;二叉树不多说，数据结构的基本内容。这题主要就是麻烦，要求的操作比较多，一看肯定不卡时间，递归走起。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;递归一时爽，一直递归一直爽。
在思路清晰的情况下，递归大大降低了编码的复杂程度，于是创建递归，求叶子数递归，求高度递归，总个数递归，查找递归，目录形式输出递归，深度遍历递归，广度……咳咳，好吧，这个不用递归，要用个队列。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;不让用&lt;code&gt;STL&lt;/code&gt;，队列也只好手写。&lt;/p&gt;
&lt;p&gt;我一开始写程序&lt;code&gt;Leaves=&lt;/code&gt;写成了&lt;code&gt;Leaf=&lt;/code&gt;，这鬼畜的错误半天没检查出来。顺便推荐个文本差异对比工具吧，这样找起来也容易：&lt;a href=&#34;http://www.jq22.com/textDifference&#34; title=&#34;在线文本差异对比&#34;&gt;在线文本差异对比&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;算上空行都300行了，真是够麻烦的。&lt;/p&gt;
&lt;h2 id=&#34;answer&#34;&gt;Answer&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#1e889b&#34;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;using&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;namespace&lt;/span&gt; std;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;template&lt;/span&gt;&amp;lt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;T&lt;/span&gt;&amp;gt;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;QueueNode&lt;/span&gt;{
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt;:
    T data;
    QueueNode*link=&lt;span style=&#34;color:#658b00&#34;&gt;NULL&lt;/span&gt;;
    QueueNode(){
        ;
    }
    QueueNode(T data){
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;-&amp;gt;data=data;
    }
};
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;template&lt;/span&gt;&amp;lt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;T&lt;/span&gt;&amp;gt;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;Queue&lt;/span&gt;{
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;private&lt;/span&gt;:
    QueueNode&amp;lt;T&amp;gt;*tail=&lt;span style=&#34;color:#658b00&#34;&gt;NULL&lt;/span&gt;;
    QueueNode&amp;lt;T&amp;gt;*head=&lt;span style=&#34;color:#658b00&#34;&gt;NULL&lt;/span&gt;;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt;:
    &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;bool&lt;/span&gt; isEmpty(){
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; head==&lt;span style=&#34;color:#658b00&#34;&gt;NULL&lt;/span&gt;;
    }
    ~Queue(){
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;while&lt;/span&gt;(head!=&lt;span style=&#34;color:#658b00&#34;&gt;NULL&lt;/span&gt;){
            QueueNode&amp;lt;T&amp;gt;*p=head-&amp;gt;link;
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;delete&lt;/span&gt; head;
            head=p;
        }
    }
    &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;enQueue&lt;/span&gt;(T data){
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt;(tail==&lt;span style=&#34;color:#658b00&#34;&gt;NULL&lt;/span&gt;){
            head=tail=&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; QueueNode&amp;lt;T&amp;gt;(data);
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt;;
        }
        tail-&amp;gt;link=&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; QueueNode&amp;lt;T&amp;gt;(data);
        tail=tail-&amp;gt;link;
    }
    T &lt;span style=&#34;color:#008b45&#34;&gt;deQueue&lt;/span&gt;(){
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt;(isEmpty()){
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#658b00&#34;&gt;NULL&lt;/span&gt;;
        }
        T res=head-&amp;gt;data;
        QueueNode&amp;lt;T&amp;gt;*tmp=head;
        head=head-&amp;gt;link;
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;delete&lt;/span&gt; tmp;
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt;(head==&lt;span style=&#34;color:#658b00&#34;&gt;NULL&lt;/span&gt;){
            tail=&lt;span style=&#34;color:#658b00&#34;&gt;NULL&lt;/span&gt;;
        }
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; res;
    }
};
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;Tree&lt;/span&gt;;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;Node&lt;/span&gt;{
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;friend&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;Tree&lt;/span&gt;;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;private&lt;/span&gt;:
    &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;char&lt;/span&gt; data=&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;\0&amp;#39;&lt;/span&gt;;
    Node*lChild=&lt;span style=&#34;color:#658b00&#34;&gt;NULL&lt;/span&gt;;
    Node*rChild=&lt;span style=&#34;color:#658b00&#34;&gt;NULL&lt;/span&gt;;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt;:
    Node(){
        ;
    }
    Node(&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;char&lt;/span&gt; data){
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;-&amp;gt;data=data;
    }
};
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;Tree&lt;/span&gt;{
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;private&lt;/span&gt;:
    Node*root=&lt;span style=&#34;color:#658b00&#34;&gt;NULL&lt;/span&gt;;
    &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;createTree&lt;/span&gt;(Node*&amp;amp;p,string&amp;amp;str,&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt;&amp;amp;id){
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt;(id&amp;gt;=str.size()){
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt;;
        }
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt;(str.at(id)==&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;#&amp;#39;&lt;/span&gt;){
            id++;
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt;;
        }
        p=&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; Node();
        p-&amp;gt;data=str.at(id);
        id++;
        createTree(p-&amp;gt;lChild,str,id);
        createTree(p-&amp;gt;rChild,str,id);
    }
    size_t &lt;span style=&#34;color:#008b45&#34;&gt;getHeight&lt;/span&gt;(Node*p){
        size_t lHeight;
        size_t rHeight;
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt;(p-&amp;gt;lChild==&lt;span style=&#34;color:#658b00&#34;&gt;NULL&lt;/span&gt;){
            lHeight=&lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;;
        }&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;else&lt;/span&gt;{
            lHeight=getHeight(p-&amp;gt;lChild);
        }
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt;(p-&amp;gt;rChild==&lt;span style=&#34;color:#658b00&#34;&gt;NULL&lt;/span&gt;){
            rHeight=&lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;;
        }&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;else&lt;/span&gt;{
            rHeight=getHeight(p-&amp;gt;rChild);
        }
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; max(lHeight,rHeight)+&lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;;
    }
    size_t &lt;span style=&#34;color:#008b45&#34;&gt;getLeaves&lt;/span&gt;(Node*p){
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt;(p==&lt;span style=&#34;color:#658b00&#34;&gt;NULL&lt;/span&gt;){
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;;
        }
        size_t res=&lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;;
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt;(p-&amp;gt;lChild==&lt;span style=&#34;color:#658b00&#34;&gt;NULL&lt;/span&gt;&amp;amp;&amp;amp;p-&amp;gt;rChild==&lt;span style=&#34;color:#658b00&#34;&gt;NULL&lt;/span&gt;){
            res++;
        }
        res+=getLeaves(p-&amp;gt;lChild);
        res+=getLeaves(p-&amp;gt;rChild);
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; res;
    }
    size_t &lt;span style=&#34;color:#008b45&#34;&gt;getNodes&lt;/span&gt;(Node*p){
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt;(p==&lt;span style=&#34;color:#658b00&#34;&gt;NULL&lt;/span&gt;){
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;;
        }
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; getNodes(p-&amp;gt;lChild)+getNodes(p-&amp;gt;rChild)+&lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;;
    }
    &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;visit1&lt;/span&gt;(Node*p){
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt;(p==&lt;span style=&#34;color:#658b00&#34;&gt;NULL&lt;/span&gt;){
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt;;
        }
        cout&amp;lt;&amp;lt;p-&amp;gt;data&amp;lt;&amp;lt;&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39; &amp;#39;&lt;/span&gt;;
        visit1(p-&amp;gt;lChild);
        visit1(p-&amp;gt;rChild);
    }
    &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;visit2&lt;/span&gt;(Node*p){
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt;(p==&lt;span style=&#34;color:#658b00&#34;&gt;NULL&lt;/span&gt;){
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt;;
        }
        visit2(p-&amp;gt;lChild);
        cout&amp;lt;&amp;lt;p-&amp;gt;data&amp;lt;&amp;lt;&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39; &amp;#39;&lt;/span&gt;;
        visit2(p-&amp;gt;rChild);
    }
    &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;visit3&lt;/span&gt;(Node*p){
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt;(p==&lt;span style=&#34;color:#658b00&#34;&gt;NULL&lt;/span&gt;){
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt;;
        }
        visit3(p-&amp;gt;lChild);
        visit3(p-&amp;gt;rChild);
        cout&amp;lt;&amp;lt;p-&amp;gt;data&amp;lt;&amp;lt;&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39; &amp;#39;&lt;/span&gt;;
    }
    &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;delNode&lt;/span&gt;(Node*p){
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt;(p==&lt;span style=&#34;color:#658b00&#34;&gt;NULL&lt;/span&gt;){
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt;;
        }
        delNode(p-&amp;gt;lChild);
        delNode(p-&amp;gt;rChild);
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;delete&lt;/span&gt; p;
    }
    &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;search&lt;/span&gt;(&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;char&lt;/span&gt; c,Node*p){
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt;(p==&lt;span style=&#34;color:#658b00&#34;&gt;NULL&lt;/span&gt;){
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;;
        }
        &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; res=p-&amp;gt;data==c?&lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;:&lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;;
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; search(c,p-&amp;gt;lChild)+search(c,p-&amp;gt;rChild)+res;
    }
    &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;indexTree&lt;/span&gt;(Node*p,&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; depth){
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt;(p==&lt;span style=&#34;color:#658b00&#34;&gt;NULL&lt;/span&gt;){
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt;;
        }
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt;(&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; i=&lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;;i&amp;lt;depth;i++){
            cout&amp;lt;&amp;lt;&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39; &amp;#39;&lt;/span&gt;&amp;lt;&amp;lt;&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39; &amp;#39;&lt;/span&gt;;
        }
        cout&amp;lt;&amp;lt;p-&amp;gt;data&amp;lt;&amp;lt;endl;
        indexTree(p-&amp;gt;lChild,depth+&lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;);
        indexTree(p-&amp;gt;rChild,depth+&lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;);
    }
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt;:
    Tree(string str){
        &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; id=&lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;;
        createTree(root,str,id);
    }
    size_t &lt;span style=&#34;color:#008b45&#34;&gt;getHeight&lt;/span&gt;(){
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; getHeight(root);
    }
    size_t &lt;span style=&#34;color:#008b45&#34;&gt;getLeaves&lt;/span&gt;(){
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; getLeaves(root);
    }
    size_t &lt;span style=&#34;color:#008b45&#34;&gt;getNodes&lt;/span&gt;(){
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; getNodes(root);
    }
    &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;visit1&lt;/span&gt;(){
        cout&amp;lt;&amp;lt;&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;Preorder is:&amp;#34;&lt;/span&gt;;
        visit1(root);
        cout&amp;lt;&amp;lt;&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;.&amp;#39;&lt;/span&gt;&amp;lt;&amp;lt;endl;
    }
    &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;visit2&lt;/span&gt;(){
        cout&amp;lt;&amp;lt;&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;Inorder is:&amp;#34;&lt;/span&gt;;
        visit2(root);
        cout&amp;lt;&amp;lt;&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;.&amp;#39;&lt;/span&gt;&amp;lt;&amp;lt;endl;
    }
    &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;visit3&lt;/span&gt;(){
        cout&amp;lt;&amp;lt;&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;Postorder is:&amp;#34;&lt;/span&gt;;
        visit3(root);
        cout&amp;lt;&amp;lt;&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;.&amp;#39;&lt;/span&gt;&amp;lt;&amp;lt;endl;
    }
    &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;visitBFS&lt;/span&gt;(){
        Queue&amp;lt;Node*&amp;gt;*q=&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; Queue&amp;lt;Node*&amp;gt;();
        q-&amp;gt;enQueue(root);
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;while&lt;/span&gt;(!q-&amp;gt;isEmpty()){
            Node*tmp=q-&amp;gt;deQueue();
            cout&amp;lt;&amp;lt;tmp-&amp;gt;data&amp;lt;&amp;lt;&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39; &amp;#39;&lt;/span&gt;;
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt;(tmp-&amp;gt;lChild!=&lt;span style=&#34;color:#658b00&#34;&gt;NULL&lt;/span&gt;){
                q-&amp;gt;enQueue(tmp-&amp;gt;lChild);
            }
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt;(tmp-&amp;gt;rChild!=&lt;span style=&#34;color:#658b00&#34;&gt;NULL&lt;/span&gt;){
                q-&amp;gt;enQueue(tmp-&amp;gt;rChild);
            }
        }
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;delete&lt;/span&gt; q;
    }
    &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;search&lt;/span&gt;(&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;char&lt;/span&gt; c){
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; search(c,root);
    }
    &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;indexTree&lt;/span&gt;(){
        indexTree(root,&lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;);
    }
    ~Tree(){
        delNode(root);
    }
};
&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;main&lt;/span&gt;()
{
    &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;char&lt;/span&gt; Op;
    Tree*tree;
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;while&lt;/span&gt;(cin&amp;gt;&amp;gt;Op){
        string str;
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;switch&lt;/span&gt;(Op){
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;case&lt;/span&gt; &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;C&amp;#39;&lt;/span&gt;:
            cin&amp;gt;&amp;gt;str;
            tree=&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; Tree(str);
            cout&amp;lt;&amp;lt;&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;Created success!&amp;#34;&lt;/span&gt;&amp;lt;&amp;lt;endl;
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;break&lt;/span&gt;;
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;case&lt;/span&gt; &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;H&amp;#39;&lt;/span&gt;:
            cout&amp;lt;&amp;lt;&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;Height=&amp;#34;&lt;/span&gt;&amp;lt;&amp;lt;tree-&amp;gt;getHeight()&amp;lt;&amp;lt;endl;
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;break&lt;/span&gt;;
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;case&lt;/span&gt; &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;L&amp;#39;&lt;/span&gt;:
            cout&amp;lt;&amp;lt;&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;Leaves=&amp;#34;&lt;/span&gt;&amp;lt;&amp;lt;tree-&amp;gt;getLeaves()&amp;lt;&amp;lt;endl;
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;break&lt;/span&gt;;
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;case&lt;/span&gt; &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;N&amp;#39;&lt;/span&gt;:
            cout&amp;lt;&amp;lt;&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;Nodes=&amp;#34;&lt;/span&gt;&amp;lt;&amp;lt;tree-&amp;gt;getNodes()&amp;lt;&amp;lt;endl;
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;break&lt;/span&gt;;
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;case&lt;/span&gt; &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;1&amp;#39;&lt;/span&gt;:
            tree-&amp;gt;visit1();
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;break&lt;/span&gt;;
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;case&lt;/span&gt; &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;2&amp;#39;&lt;/span&gt;:
            tree-&amp;gt;visit2();
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;break&lt;/span&gt;;
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;case&lt;/span&gt; &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;3&amp;#39;&lt;/span&gt;:
            tree-&amp;gt;visit3();
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;break&lt;/span&gt;;
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;case&lt;/span&gt; &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;4&amp;#39;&lt;/span&gt;:
            cout&amp;lt;&amp;lt;&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;BFSorder is:&amp;#34;&lt;/span&gt;;
            tree-&amp;gt;visitBFS();
            cout&amp;lt;&amp;lt;&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;.&amp;#39;&lt;/span&gt;&amp;lt;&amp;lt;endl;
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;break&lt;/span&gt;;
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;case&lt;/span&gt; &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;F&amp;#39;&lt;/span&gt;:
            &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;char&lt;/span&gt; x;
            cin&amp;gt;&amp;gt;x;
            cout&amp;lt;&amp;lt;&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;The count of &amp;#34;&lt;/span&gt;&amp;lt;&amp;lt;x&amp;lt;&amp;lt;&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34; is &amp;#34;&lt;/span&gt;&amp;lt;&amp;lt;tree-&amp;gt;search(x)&amp;lt;&amp;lt;endl;
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;break&lt;/span&gt;;
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;case&lt;/span&gt; &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;P&amp;#39;&lt;/span&gt;:
            cout&amp;lt;&amp;lt;&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;The tree is:&amp;#34;&lt;/span&gt;&amp;lt;&amp;lt;endl;
            tree-&amp;gt;indexTree();
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;break&lt;/span&gt;;
        }
    }
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;delete&lt;/span&gt; tree;
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;- https://ntutn.top/posts/%E4%BA%8C%E5%8F%89%E6%A0%91adt%E7%9A%84%E5%AE%9E%E7%8E%B0/ - CC BY-SA 4.0</description>
        </item>
    
    
    
        <item>
        <title>活动安排问题</title>
        <link>https://ntutn.top/posts/%E6%B4%BB%E5%8A%A8%E5%AE%89%E6%8E%92%E9%97%AE%E9%A2%98/</link>
        <pubDate>Mon, 13 May 2019 03:11:37 +0800</pubDate>
        
        <guid>https://ntutn.top/posts/%E6%B4%BB%E5%8A%A8%E5%AE%89%E6%8E%92%E9%97%AE%E9%A2%98/</guid>
        <description>归零幻想 https://ntutn.top/posts/%E6%B4%BB%E5%8A%A8%E5%AE%89%E6%8E%92%E9%97%AE%E9%A2%98/ -&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;经典的贪心问题。&lt;/p&gt;
&lt;h2 id=&#34;question&#34;&gt;Question&lt;/h2&gt;
&lt;p&gt;假设有n个活动的集合&lt;code&gt;E={a1,a2,...,an}&lt;/code&gt;，其每个活动都要求使用同一资源（如某个设备、教室、场地等），而在同一时间内只允许一个活动使用这一资源。&lt;/p&gt;
&lt;p&gt;每个活动都有一个要求使用该资源的起止时间&lt;code&gt;si&lt;/code&gt;,&lt;code&gt;fi&lt;/code&gt;，且&lt;code&gt;si&amp;lt;fi&lt;/code&gt;。如果选择了活动ai，则它在半开的时间区间&lt;code&gt;[si,fi)&lt;/code&gt;内占有资源。两个活动&lt;code&gt;ai&lt;/code&gt;,&lt;code&gt;aj&lt;/code&gt;称为是相容的，当且仅当它们的时间区间&lt;code&gt;[si,fi)&lt;/code&gt;和&lt;code&gt;[sj,fj)&lt;/code&gt;不相交，即&lt;code&gt;si&amp;gt;=fj&lt;/code&gt; 或 &lt;code&gt;sj &amp;gt;=fi&lt;/code&gt;。现要求在所给定的活动集中选出最大的相容活动子集。&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;请补充要求的函数代码。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;提示：贪心策略&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;输入，有多行，第1行是活动的个数n，后面n行，每行3个整数，是每个活动的编号、占用资源的开始时间、结束时间。&lt;/p&gt;
&lt;p&gt;输出，选出的最大活动子集，即有多行，每行包括活动的编号、开始时间、结束时间。&lt;/p&gt;
&lt;h2 id=&#34;example&#34;&gt;Example&lt;/h2&gt;
&lt;h3 id=&#34;input&#34;&gt;Input&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;11
1 3 8
2 2 13
3 1 4
4 5 7
5 6 10
6 8 11
7 12 14
8 5 9
9 3 5
10 0 6
11 8 12
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;output&#34;&gt;Output&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;3：1-4
4：5-7
6：8-11
7：12-14
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;分析&#34;&gt;分析&lt;/h2&gt;
&lt;p&gt;经典的贪心问题，贪心策略为选择结束时间最早的活动，因为这样就可以给后面的活动留出更多的时间。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;掉坑：在选择活动时只处理了前24小时的活动，而事实证明我画蛇添足了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;answer&#34;&gt;Answer&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#1e889b&#34;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#1e889b&#34;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#1e889b&#34;&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;using&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;namespace&lt;/span&gt; std;
&lt;span style=&#34;color:#228b22&#34;&gt;//定义允许的最大活动数
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;#define Maxn  100
&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;//定义活动的类型
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;typedef&lt;/span&gt;  &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;act_Node&lt;/span&gt;
{  &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; Id;       &lt;span style=&#34;color:#228b22&#34;&gt;//活动ID
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;   &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; s_Time;   &lt;span style=&#34;color:#228b22&#34;&gt;//活动开始时间
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;   &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; f_Time;   &lt;span style=&#34;color:#228b22&#34;&gt;//活动结束时间
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;} ACND;
&lt;span style=&#34;color:#228b22&#34;&gt;//对活动按贪心准则排序
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;Sort&lt;/span&gt;(&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; n,ACND arr[])
{
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt;(&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; i=&lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;;i&amp;lt;n;i++){
        &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; tmp=i;
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt;(&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; j=i+&lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;;j&amp;lt;n;j++){
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt;(arr[j].f_Time&amp;lt;arr[tmp].f_Time){
                tmp=j;
            }
        }
        ACND tmpSwap=arr[i];
        arr[i]=arr[tmp];
        arr[tmp]=tmpSwap;
    }
}
&lt;span style=&#34;color:#228b22&#34;&gt;//进行贪心选择，得到最大相容的活动集合输出
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;Select&lt;/span&gt;(&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; n,ACND arr[])
{
    &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; nTime=&lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;;
    ACND*p=arr;
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;while&lt;/span&gt;(p-arr&amp;lt;n){
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt;(p-&amp;gt;s_Time&amp;gt;=nTime){
            cout&amp;lt;&amp;lt;p-&amp;gt;Id&amp;lt;&amp;lt;&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;:&amp;#34;&lt;/span&gt;&amp;lt;&amp;lt;p-&amp;gt;s_Time&amp;lt;&amp;lt;&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;-&amp;#34;&lt;/span&gt;&amp;lt;&amp;lt;p-&amp;gt;f_Time&amp;lt;&amp;lt;endl;
            nTime=p-&amp;gt;f_Time;
        }
        p++;
    }
}
&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;main&lt;/span&gt;()
{  ACND arr[Maxn];
   &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; an,i;
   cin&amp;gt;&amp;gt;an;           &lt;span style=&#34;color:#228b22&#34;&gt;//读入活动个数
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;   &lt;span style=&#34;color:#228b22&#34;&gt;//读入各个活动的编号和占用资源的起止时间
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;   &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt;(i=&lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;;i&amp;lt;an;i++)
     cin&amp;gt;&amp;gt;arr[i].Id&amp;gt;&amp;gt;arr[i].s_Time&amp;gt;&amp;gt;arr[i].f_Time;
   &lt;span style=&#34;color:#228b22&#34;&gt;//对活动按贪心准则进行排序
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;   Sort(an,arr);
   &lt;span style=&#34;color:#228b22&#34;&gt;//进行贪心选择，获得最优解并输出
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;   Select(an,arr);
  &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;- https://ntutn.top/posts/%E6%B4%BB%E5%8A%A8%E5%AE%89%E6%8E%92%E9%97%AE%E9%A2%98/ - CC BY-SA 4.0</description>
        </item>
    
    
    
        <item>
        <title>线性表ADT的实现</title>
        <link>https://ntutn.top/posts/%E7%BA%BF%E6%80%A7%E8%A1%A8adt%E7%9A%84%E5%AE%9E%E7%8E%B0/</link>
        <pubDate>Mon, 13 May 2019 03:11:37 +0800</pubDate>
        
        <guid>https://ntutn.top/posts/%E7%BA%BF%E6%80%A7%E8%A1%A8adt%E7%9A%84%E5%AE%9E%E7%8E%B0/</guid>
        <description>归零幻想 https://ntutn.top/posts/%E7%BA%BF%E6%80%A7%E8%A1%A8adt%E7%9A%84%E5%AE%9E%E7%8E%B0/ -&lt;!-- raw HTML omitted --&gt;
&lt;h1 id=&#34;线性表adt的实现&#34;&gt;线性表ADT的实现&lt;/h1&gt;
&lt;p&gt;数据结构平时测试的题目开放了，这次平时测试睡过了，全宿舍都睡过了。现在回头做做题目，还是有坑点的。&lt;/p&gt;
&lt;h2 id=&#34;question&#34;&gt;Question&lt;/h2&gt;
&lt;p&gt;假设线性表ADT的数据元素类型为正整数，采用带头结点的单链式存储结构。线性表ADT实现的大部分代码已经给出，请补充写出类的两个成员函数&lt;code&gt;insert&lt;/code&gt;和&lt;code&gt;reverse&lt;/code&gt;。  注意：&lt;strong&gt;只需提交需要补充的函数代码，其他代码不能自己重写和修改。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;insert&lt;/code&gt;函数：在元素值从小到大有序的线性表中插入一个元素，仍然保持有序。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;reverse&lt;/code&gt;函数：实现线性表元素的倒置，即将线性表中数据元素的顺序反转。&lt;/p&gt;
&lt;p&gt;线性表元素输入时，以 &lt;code&gt;endTag&lt;/code&gt; 作为结束标志。&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;例如输入：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;3 8 7 2 4 9 1 6 5 0
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;则输出：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;9 8 7 6 5 4 3 2 1
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;预置代码如下： （其中/*   */ 部分是要补充的&lt;code&gt;insert&lt;/code&gt;和&lt;code&gt;reverse&lt;/code&gt;函数）&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;#include&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;#include&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;using&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;namespace&lt;/span&gt; std;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; ElemType;  &lt;span style=&#34;color:#228b22&#34;&gt;//数据元素类型
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;List&lt;/span&gt;; &lt;span style=&#34;color:#228b22&#34;&gt;//前视定义,否则友元无法定义
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;//结点类定义
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;LinkNode&lt;/span&gt;
{  &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;friend&lt;/span&gt;  &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;List&lt;/span&gt;; 
   &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;private&lt;/span&gt;: 
     LinkNode *link; 
     ElemType data;  
   &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt;: 
     LinkNode (LinkNode *ptr = &lt;span style=&#34;color:#658b00&#34;&gt;NULL&lt;/span&gt;)    {link=ptr;}
     LinkNode(&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; ElemType &amp;amp; item, LinkNode *ptr = &lt;span style=&#34;color:#658b00&#34;&gt;NULL&lt;/span&gt;){  data=item;link=ptr;} 
     ~LinkNode(){}; 
}; 
&lt;span style=&#34;color:#228b22&#34;&gt;//单链表类定义 
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;List&lt;/span&gt;   
{  &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;private&lt;/span&gt;:    
     LinkNode *first; &lt;span style=&#34;color:#228b22&#34;&gt;//指向链表头结点的指针          
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;   &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt;:
     List (ElemType x) { first = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; LinkNode (x);}   &lt;span style=&#34;color:#228b22&#34;&gt;// 带头结点
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;     ~List (){ MakeEmpty();}         &lt;span style=&#34;color:#228b22&#34;&gt;//析构函数
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;     &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;MakeEmpty&lt;/span&gt; ( );      &lt;span style=&#34;color:#228b22&#34;&gt;//线性表置空    
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;     &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;insert&lt;/span&gt;(ElemType val);   &lt;span style=&#34;color:#228b22&#34;&gt;//在有序线性表中插入元素val
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;     &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;reverse&lt;/span&gt;();   &lt;span style=&#34;color:#228b22&#34;&gt;//线性表的倒置
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;     &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;output&lt;/span&gt;();    &lt;span style=&#34;color:#228b22&#34;&gt;//线性表的输出               
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;}; 
&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;void&lt;/span&gt; List:: MakeEmpty ( )
 { LinkNode *q;
   &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;while&lt;/span&gt; (  first-&amp;gt;link != &lt;span style=&#34;color:#658b00&#34;&gt;NULL&lt;/span&gt; ) 
	{ q = first-&amp;gt;link;  &lt;span style=&#34;color:#228b22&#34;&gt;//指向别摘下结点 
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;      first-&amp;gt;link = q-&amp;gt;link;&lt;span style=&#34;color:#228b22&#34;&gt;//从链中摘下结点
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;      &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;delete&lt;/span&gt; q;        &lt;span style=&#34;color:#228b22&#34;&gt;//释放摘下的结点 
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    }
};	
&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;void&lt;/span&gt; List ::output ( )
{  LinkNode  *p=first-&amp;gt;link; 
   &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;while&lt;/span&gt;(p!=&lt;span style=&#34;color:#658b00&#34;&gt;NULL&lt;/span&gt;)
   { &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt;(p==first-&amp;gt;link) cout&amp;lt;&amp;lt;p-&amp;gt;data;
     &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;else&lt;/span&gt;  cout&amp;lt;&amp;lt;&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34; &amp;#34;&lt;/span&gt;&amp;lt;&amp;lt;p-&amp;gt;data;
     p=p-&amp;gt;link;
   }
   cout&amp;lt;&amp;lt;endl;
}
&lt;span style=&#34;color:#228b22&#34;&gt;/*
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;**************************************************
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;请写出 insert 成员函数
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;**************************************************
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;**************************************************
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;请写出 reverse 成员函数
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;**************************************************
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;*/&lt;/span&gt;
&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt;  &lt;span style=&#34;color:#008b45&#34;&gt;main&lt;/span&gt;()
{   List list(&lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;);
    ElemType endTag=&lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;;
    ElemType val;
    &lt;span style=&#34;color:#228b22&#34;&gt;//下面通过不断读入元素，插入到有序单链表中，建立从小到大的有序单链表
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    cin&amp;gt;&amp;gt;val;
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;while&lt;/span&gt;(val!=endTag) 
     {  list.insert(val);     &lt;span style=&#34;color:#228b22&#34;&gt;//在有序表中插入一个元素
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        cin&amp;gt;&amp;gt;val;  
      }
    list.reverse ();   &lt;span style=&#34;color:#228b22&#34;&gt;//线性表倒置
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    cout&amp;lt;&amp;lt;&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;The result is:&amp;#34;&lt;/span&gt;&amp;lt;&amp;lt;endl;
    list.output ();
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;分析&#34;&gt;分析&lt;/h2&gt;
&lt;p&gt;基础题，注意边界的判断和特例的处理。&lt;/p&gt;
&lt;h2 id=&#34;answer&#34;&gt;Answer&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#228b22&#34;&gt;/*
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;**************************************************
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;请写出 insert 成员函数
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;**************************************************
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;*/&lt;/span&gt;
&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;void&lt;/span&gt; List::insert(ElemType val){
    LinkNode*pNew=&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; LinkNode(val);
    LinkNode*pPointer=first;
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;while&lt;/span&gt;(pPointer-&amp;gt;link!=&lt;span style=&#34;color:#658b00&#34;&gt;NULL&lt;/span&gt;){
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt;(val&amp;lt;pPointer-&amp;gt;link-&amp;gt;data){
            pNew-&amp;gt;link=pPointer-&amp;gt;link;
            pPointer-&amp;gt;link=pNew;
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt;;
        }
        pPointer=pPointer-&amp;gt;link;
    }
    pPointer-&amp;gt;link=pNew;
}
&lt;span style=&#34;color:#228b22&#34;&gt;/*
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;**************************************************
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;请写出 reverse 成员函数
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;**************************************************
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;*/&lt;/span&gt;
&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;void&lt;/span&gt; List::reverse(){
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt;(first-&amp;gt;link==&lt;span style=&#34;color:#658b00&#34;&gt;NULL&lt;/span&gt;||first-&amp;gt;link-&amp;gt;link==&lt;span style=&#34;color:#658b00&#34;&gt;NULL&lt;/span&gt;){
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt;;
    }
    LinkNode*pParent=first-&amp;gt;link;
    LinkNode*pChild=first-&amp;gt;link-&amp;gt;link;
    first-&amp;gt;link-&amp;gt;link=&lt;span style=&#34;color:#658b00&#34;&gt;NULL&lt;/span&gt;;
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;while&lt;/span&gt;(pChild!=&lt;span style=&#34;color:#658b00&#34;&gt;NULL&lt;/span&gt;){
        LinkNode*pTemp=pChild-&amp;gt;link;
        pChild-&amp;gt;link=pParent;
        pParent=pChild;
        pChild=pTemp;
    }
    first-&amp;gt;link=pParent;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;- https://ntutn.top/posts/%E7%BA%BF%E6%80%A7%E8%A1%A8adt%E7%9A%84%E5%AE%9E%E7%8E%B0/ - CC BY-SA 4.0</description>
        </item>
    
    
  </channel>
</rss> 