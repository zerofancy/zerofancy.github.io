<?xml-stylesheet href="/rss.xsl" type="text/xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>归零幻想</title>
    <link>https://ntutn.top/</link>
    <description>Recent content on 归零幻想</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <copyright>CC BY-SA 4.0</copyright>
    <lastBuildDate>Sun, 24 Oct 2021 03:11:37 +0800</lastBuildDate>
    
        <atom:link href="https://ntutn.top/index.xml" rel="self" type="application/rss+xml" />
    
    
    
        <item>
        <title>闷声作大死：删除电脑内的空文件夹</title>
        <link>https://ntutn.top/posts/%E9%97%B7%E5%A3%B0%E4%BD%9C%E5%A4%A7%E6%AD%BB%E5%88%A0%E9%99%A4%E7%94%B5%E8%84%91%E5%86%85%E7%9A%84%E7%A9%BA%E6%96%87%E4%BB%B6%E5%A4%B9/</link>
        <pubDate>Sun, 16 Jun 2019 03:11:37 +0800</pubDate>
        
        <guid>https://ntutn.top/posts/%E9%97%B7%E5%A3%B0%E4%BD%9C%E5%A4%A7%E6%AD%BB%E5%88%A0%E9%99%A4%E7%94%B5%E8%84%91%E5%86%85%E7%9A%84%E7%A9%BA%E6%96%87%E4%BB%B6%E5%A4%B9/</guid>
        <description>归零幻想 https://ntutn.top/posts/%E9%97%B7%E5%A3%B0%E4%BD%9C%E5%A4%A7%E6%AD%BB%E5%88%A0%E9%99%A4%E7%94%B5%E8%84%91%E5%86%85%E7%9A%84%E7%A9%BA%E6%96%87%E4%BB%B6%E5%A4%B9/ -&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;电脑卸载软件时，卸载程序常常不会把程序对应的空文件夹删掉，一般这时候我都是手动去把他删掉。&lt;/p&gt;
&lt;p&gt;我觉得有点麻烦，又想到电脑内可能还有其他的空文件夹。于是在网上找了个脚本删除电脑内的空文件夹，然后就遇到了麻烦……&lt;/p&gt;
&lt;p&gt;也许本文标题应该是&lt;strong&gt;一个空文件夹引发的血案&lt;/strong&gt;……&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;h2 id=&#34;删除电脑内的空文件夹&#34;&gt;删除电脑内的空文件夹&lt;/h2&gt;
&lt;p&gt;本来我曾经写过一个C#版本的删除电脑空文件夹的工具，原理很简单，就是递归嘛：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2020/08/20/az9OYcHf3nmdLID.png&#34; alt=&#34;1.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;但是这程序执行比较慢，而且占用内存不少……&lt;/p&gt;
&lt;p&gt;在网上搜索了下，果然不能闭门造车啊，有大佬写过批处理：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cmd&#34; data-lang=&#34;cmd&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;/f&lt;/span&gt; &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;tokens=*&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#cd5555&#34;&gt;%%&lt;/span&gt;a &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;in&lt;/span&gt; (&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;dir /b /ad /s C:\^|sort /r&amp;#39;&lt;/span&gt;) &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;do&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;rd&lt;/span&gt; &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;%%&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;a&amp;#34;&lt;/span&gt; /q &lt;span style=&#34;color:#b452cd&#34;&gt;2&lt;/span&gt;&amp;gt;nul
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;试用了下，效果相当不错。于是稍微修改使它能申请管理员权限，顺便修改下控制台颜色，看上去炫一点：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cmd&#34; data-lang=&#34;cmd&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;title&lt;/span&gt; 删除空文件夹
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;color&lt;/span&gt; 03
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;echo&lt;/span&gt; 程序需要管理员权限……
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;set&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;/a&lt;/span&gt; &lt;span style=&#34;color:#00688b&#34;&gt;_Debug&lt;/span&gt;=&lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;
:&lt;span style=&#34;color:#228b22&#34;&gt;:==========================================&lt;/span&gt;
:&lt;span style=&#34;color:#228b22&#34;&gt;: 获取管理员权限&lt;/span&gt;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;set&lt;/span&gt; &lt;span style=&#34;color:#00688b&#34;&gt;_Args&lt;/span&gt;=&lt;span style=&#34;color:#00688b&#34;&gt;%*&lt;/span&gt;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#00688b&#34;&gt;%~1&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#8b008b&#34;&gt;NEQ&lt;/span&gt; &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt; (
  &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;set&lt;/span&gt; &lt;span style=&#34;color:#00688b&#34;&gt;_Args&lt;/span&gt;=&lt;span style=&#34;color:#00688b&#34;&gt;%_Args:&amp;#34;=%&lt;/span&gt;
)
fltmc &lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;&amp;gt;nul &lt;span style=&#34;color:#b452cd&#34;&gt;2&lt;/span&gt;&amp;gt;nul || (
  &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;cd&lt;/span&gt; /d &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#00688b&#34;&gt;%~dp0&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;&lt;/span&gt;
  cmd /u /c echo Set UAC = CreateObject&lt;span style=&#34;color:#cd5555&#34;&gt;^(&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;Shell.Application&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;^)&lt;/span&gt; : UAC.ShellExecute &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;cmd.exe&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;/k cd &amp;#34;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#00688b&#34;&gt;%~dp0&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;&amp;#34; &amp;amp;&amp;amp; &amp;#34;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#00688b&#34;&gt;%~dpnx0&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;&amp;#34; &amp;#34;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#00688b&#34;&gt;%_Args%&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;&amp;#34;&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;runas&amp;#34;&lt;/span&gt;, 1 &amp;gt; &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#00688b&#34;&gt;%temp%&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;\GetAdmin.vbs&amp;#34;&lt;/span&gt;
  &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#00688b&#34;&gt;%temp%&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;\GetAdmin.vbs&amp;#34;&lt;/span&gt;
  &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;del&lt;/span&gt; /f /q &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#00688b&#34;&gt;%temp%&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;\GetAdmin.vbs&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;&amp;gt;nul &lt;span style=&#34;color:#b452cd&#34;&gt;2&lt;/span&gt;&amp;gt;nul
  &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;exit&lt;/span&gt;
)
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;/f&lt;/span&gt; &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;tokens=*&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#cd5555&#34;&gt;%%&lt;/span&gt;a &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;in&lt;/span&gt; (&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;dir /b /ad /s C:\^|sort /r&amp;#39;&lt;/span&gt;) &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;do&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;rd&lt;/span&gt; &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;%%&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;a&amp;#34;&lt;/span&gt; /q &lt;span style=&#34;color:#b452cd&#34;&gt;2&lt;/span&gt;&amp;gt;nul
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;而后我就把这个脚本放桌面上了，没事拿出来跑一跑，按下&lt;code&gt;Ctrl+Enter&lt;/code&gt;全屏，其实就是感觉看着控制台上一堆信息滚动很牛逼而已……&lt;del&gt;Dir溢出警告&lt;/del&gt;&lt;/p&gt;
&lt;h2 id=&#34;使用mediacreationtool修复windows&#34;&gt;使用MediaCreationTool修复Windows&lt;/h2&gt;
&lt;p&gt;这天我照例删了一遍空文件夹，然后打开应用商店更新游戏，然后发现打不开了……&lt;/p&gt;
&lt;p&gt;在网上找了好半天，才知道电脑内的空文件夹也是不能乱删的，比如&lt;code&gt;C:\Windows&lt;/code&gt;下的&lt;code&gt;AUInstallAgent&lt;/code&gt;和&lt;code&gt;AppReadiness&lt;/code&gt;也常常是空的，但删了应用商店就不能工作……&lt;/p&gt;
&lt;p&gt;试着重建这两个文件夹，无效，重启，无效。可是我真的不想重装或者重买啊……&lt;/p&gt;
&lt;p&gt;于是找到应用商店的设置，试着点“重置”，然后应用商店就消失了……&lt;/p&gt;
&lt;p&gt;好吧，情况更糟糕了，在网上找了好久，于是用MediaCreationTool试了试……&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2020/08/20/dbID9KehsiyHZxl.jpg&#34; alt=&#34;2.png&#34;&gt;
然而提示我电脑系统盘空间不足，于是下载DiskGenius调整系统盘空间容量……&lt;/p&gt;
&lt;h2 id=&#34;diskgenius调整系统盘空间容量&#34;&gt;DiskGenius调整系统盘空间容量&lt;/h2&gt;
&lt;p&gt;由于系统盘被占用，无法直接调整，于是进入PE：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2020/08/20/jWR9vg2FSDqyteV.png&#34; alt=&#34;3.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;点击“重新启动运行WinPE版DiskGenius软件”，第一次启动要准备PE环境，会比较慢。&lt;/p&gt;
&lt;p&gt;接下来在要调整的分区上点右键，调整分区大小：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2020/08/20/RPVCqOFuKQdXm4k.png&#34; alt=&#34;4.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;将挤出来的空间合并到C盘。这个过程非常慢，但一定要有耐心，保证电脑不会中间断电等。毕竟是对分区表的直接操作，一定要小心。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;请勿模仿：想当年本人用&lt;code&gt;Ghost&lt;/code&gt;还原系统的时候进度条走了1/4，突然感觉刚刚的选择有点问题，想重选一遍，于是按了电源键，然后就没有然后了……
数据无价，谨慎操作&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;重新安装windows10应用商店&#34;&gt;重新安装Windows10应用商店&lt;/h2&gt;
&lt;p&gt;理论上来说使用MediaCreationTool修复完Windows应用商店也应该回来了，但我的仍然没有出现只得自己重装一下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;用管理员身份打开&lt;code&gt;powershell&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;输入&lt;code&gt;Get-AppxPackage *WindowsStore* | Remove-AppxPackage&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;输入&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;Get-AppXPackage *WindowsStore* -AllUsers | Foreach {Add-AppxPackage -DisableDevelopmentMode -Register &amp;quot;$($_.InstallLocation)\AppXManifest.xml&amp;quot;}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;刚装完可能是英文的，更新后语言就自动匹配了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2020/08/20/Ybuwv4RO5ITsEoH.png&#34; alt=&#34;5.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;美滋滋。&lt;/p&gt;
- https://ntutn.top/posts/%E9%97%B7%E5%A3%B0%E4%BD%9C%E5%A4%A7%E6%AD%BB%E5%88%A0%E9%99%A4%E7%94%B5%E8%84%91%E5%86%85%E7%9A%84%E7%A9%BA%E6%96%87%E4%BB%B6%E5%A4%B9/ - CC BY-SA 4.0</description>
        </item>
    
    
    
        <item>
        <title>在Windows10上安装血战上海滩</title>
        <link>https://ntutn.top/posts/%E5%9C%A8windows10%E4%B8%8A%E5%AE%89%E8%A3%85%E8%A1%80%E6%88%98%E4%B8%8A%E6%B5%B7%E6%BB%A9/</link>
        <pubDate>Sat, 01 Jun 2019 03:11:37 +0800</pubDate>
        
        <guid>https://ntutn.top/posts/%E5%9C%A8windows10%E4%B8%8A%E5%AE%89%E8%A3%85%E8%A1%80%E6%88%98%E4%B8%8A%E6%B5%B7%E6%BB%A9/</guid>
        <description>归零幻想 https://ntutn.top/posts/%E5%9C%A8windows10%E4%B8%8A%E5%AE%89%E8%A3%85%E8%A1%80%E6%88%98%E4%B8%8A%E6%B5%B7%E6%BB%A9/ -&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;《血战上海滩》是由北京欢乐亿派科技有限公司开发的单机FPS游戏，发行于2003年，是一个非常经典的老游戏了。
近来我打算把这个游戏找出来再玩一遍，可是在Windows10上安装还是有些问题……&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://images.ntutn.top/2022/04/cae87d561f3a723b0187e837e3e63ab0.gif&#34; alt=&#34;血战上海滩&#34;&gt;&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;h2 id=&#34;下载&#34;&gt;下载&lt;/h2&gt;
&lt;p&gt;下载不用多说，自己找资源吧，一共三百多兆的单机游戏。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;现在很多单机游戏下载时网站都会给你带上一个“启动器”来显示广告，恶心的很。找到文件夹中，注意血战上海滩的游戏文件是一个帽子的图标，大小为&lt;code&gt;1.87M&lt;/code&gt;，SHA1为&lt;code&gt;FE5A102AA9DE633FB6E388EAAEEA38BC43E8E7E4&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;启动&#34;&gt;启动&lt;/h2&gt;
&lt;p&gt;直接双击exe，然后……它免费帮你调了一下分辨率，就没反应了。&lt;/p&gt;
&lt;p&gt;貌似兼容性是个比较大的问题……于是在网上找了好久，终于知道，可以用命令行控制游戏窗口运行：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cmd&#34; data-lang=&#34;cmd&#34;&gt;shanghai.exe -windows
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;修改屏幕分辨率实现全屏&#34;&gt;修改屏幕分辨率实现全屏&lt;/h2&gt;
&lt;p&gt;倒是能运行了，只是……画面都在左上角，没法玩啊……&lt;/p&gt;
&lt;p&gt;所以再加上自动修改屏幕分辨率就可以全屏了。修改屏幕分辨率可以用&lt;code&gt;setres&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.majorgeeks.com/files/details/setres.html&#34;&gt;下载链接&lt;/a&gt;下载并将exe文件放到血战上海滩的游戏文件夹。&lt;/p&gt;
&lt;p&gt;于是用下面的命令：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cmd&#34; data-lang=&#34;cmd&#34;&gt;setres h800 v600
shanghai.exe -windows
setres h1920 v1080
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;1920*1080&lt;/code&gt;是我电脑的屏幕分辨率，注意换成自己的。&lt;/p&gt;
&lt;h2 id=&#34;隐藏显示任务栏&#34;&gt;隐藏显示任务栏&lt;/h2&gt;
&lt;p&gt;然而，这样还是有问题，就是这样“全屏”后任务栏并没有消失，虽然可以设置自动隐藏任务栏但总归还是不爽，于是写了个简单C#程序在启动游戏隐藏任务栏（虽然很简单，但没找到只用命令实现的方法）&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-C#&#34; data-lang=&#34;C#&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;using&lt;/span&gt; &lt;span style=&#34;color:#008b45;text-decoration:underline&#34;&gt;System&lt;/span&gt;;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;using&lt;/span&gt; &lt;span style=&#34;color:#008b45;text-decoration:underline&#34;&gt;System.Collections.Generic&lt;/span&gt;;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;using&lt;/span&gt; &lt;span style=&#34;color:#008b45;text-decoration:underline&#34;&gt;System.Linq&lt;/span&gt;;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;using&lt;/span&gt; &lt;span style=&#34;color:#008b45;text-decoration:underline&#34;&gt;System.Text&lt;/span&gt;;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;using&lt;/span&gt; &lt;span style=&#34;color:#008b45;text-decoration:underline&#34;&gt;System.Threading.Tasks&lt;/span&gt;;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;using&lt;/span&gt; &lt;span style=&#34;color:#008b45;text-decoration:underline&#34;&gt;System.Runtime.InteropServices&lt;/span&gt;;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;namespace&lt;/span&gt; &lt;span style=&#34;color:#008b45;text-decoration:underline&#34;&gt;ShowTaskBar&lt;/span&gt;
{
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;Program&lt;/span&gt;
    {
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; SW_HIDE = &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;;  &lt;span style=&#34;color:#228b22&#34;&gt;//隐藏任务栏
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; SW_RESTORE = &lt;span style=&#34;color:#b452cd&#34;&gt;9&lt;/span&gt;;&lt;span style=&#34;color:#228b22&#34;&gt;//显示任务栏
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#658b00&#34;&gt;        [DllImport(&amp;#34;user32.dll&amp;#34;)]&lt;/span&gt;
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;extern&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; ShowWindow(&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; hwnd, &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; nCmdShow);
&lt;span style=&#34;color:#658b00&#34;&gt;        [DllImport(&amp;#34;user32.dll&amp;#34;)]&lt;/span&gt;
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;extern&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; FindWindow(&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;string&lt;/span&gt; lpClassName, &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;string&lt;/span&gt; lpWindowName);
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;void&lt;/span&gt; Main(&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;string&lt;/span&gt;[] args)
        {
            ShowWindow(FindWindow(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;Shell_TrayWnd&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;null&lt;/span&gt;), SW_HIDE);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-C#&#34; data-lang=&#34;C#&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;using&lt;/span&gt; &lt;span style=&#34;color:#008b45;text-decoration:underline&#34;&gt;System&lt;/span&gt;;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;using&lt;/span&gt; &lt;span style=&#34;color:#008b45;text-decoration:underline&#34;&gt;System.Collections.Generic&lt;/span&gt;;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;using&lt;/span&gt; &lt;span style=&#34;color:#008b45;text-decoration:underline&#34;&gt;System.Linq&lt;/span&gt;;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;using&lt;/span&gt; &lt;span style=&#34;color:#008b45;text-decoration:underline&#34;&gt;System.Text&lt;/span&gt;;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;using&lt;/span&gt; &lt;span style=&#34;color:#008b45;text-decoration:underline&#34;&gt;System.Threading.Tasks&lt;/span&gt;;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;using&lt;/span&gt; &lt;span style=&#34;color:#008b45;text-decoration:underline&#34;&gt;System.Runtime.InteropServices&lt;/span&gt;;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;namespace&lt;/span&gt; &lt;span style=&#34;color:#008b45;text-decoration:underline&#34;&gt;ShowTaskBar&lt;/span&gt;
{
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;Program&lt;/span&gt;
    {
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; SW_HIDE = &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;;  &lt;span style=&#34;color:#228b22&#34;&gt;//隐藏任务栏
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; SW_RESTORE = &lt;span style=&#34;color:#b452cd&#34;&gt;9&lt;/span&gt;;&lt;span style=&#34;color:#228b22&#34;&gt;//显示任务栏
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#658b00&#34;&gt;        [DllImport(&amp;#34;user32.dll&amp;#34;)]&lt;/span&gt;
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;extern&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; ShowWindow(&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; hwnd, &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; nCmdShow);
&lt;span style=&#34;color:#658b00&#34;&gt;        [DllImport(&amp;#34;user32.dll&amp;#34;)]&lt;/span&gt;
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;extern&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; FindWindow(&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;string&lt;/span&gt; lpClassName, &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;string&lt;/span&gt; lpWindowName);
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;void&lt;/span&gt; Main(&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;string&lt;/span&gt;[] args)
        {
            ShowWindow(FindWindow(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;Shell_TrayWnd&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;null&lt;/span&gt;), SW_RESTORE);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;编译并将生成文件也放到游戏文件夹。这样我们就可以用一个&lt;code&gt;start.cmd&lt;/code&gt;打开游戏：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cmd&#34; data-lang=&#34;cmd&#34;&gt;setres h800 v600
hidetaskbar
shanghai.exe -windows
showtaskbar
setres h1920 v1080
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;体验相当完美。&lt;/p&gt;
- https://ntutn.top/posts/%E5%9C%A8windows10%E4%B8%8A%E5%AE%89%E8%A3%85%E8%A1%80%E6%88%98%E4%B8%8A%E6%B5%B7%E6%BB%A9/ - CC BY-SA 4.0</description>
        </item>
    
    
    
        <item>
        <title>数据结构第三次测试</title>
        <link>https://ntutn.top/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%89%E6%AC%A1%E6%B5%8B%E8%AF%95/</link>
        <pubDate>Sat, 01 Jun 2019 03:11:37 +0800</pubDate>
        
        <guid>https://ntutn.top/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%89%E6%AC%A1%E6%B5%8B%E8%AF%95/</guid>
        <description>归零幻想 https://ntutn.top/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%89%E6%AC%A1%E6%B5%8B%E8%AF%95/ -&lt;!-- raw HTML omitted --&gt;
&lt;blockquote&gt;
&lt;p&gt;数据结构测试，树部分，水题&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;一&#34;&gt;一&lt;/h2&gt;
&lt;p&gt;假设二叉树的数据元素为字符，采用二叉链式存储结构。二叉树ADT实现的大部分代码已经给出，其中采用完全前序序列创建二叉树。请补充写出下列两个操作函数。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注意： 答案区只写出两个函数，其他代码不允许修改和重写、提交！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;计算以某结点为根的二叉树的高度；&lt;/li&gt;
&lt;li&gt;以前序顺序输出各个元素结点为根的子树的高度；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;例如：有如右图的二叉树   &lt;img src=&#34;https://i.loli.net/2020/08/20/axyNCbMzRcpDtY7.jpg&#34; alt=&#34;1559400741461.jpg&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;输入&#34;&gt;输入&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;ABD@@E@@C@F@@
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;输出&#34;&gt;输出&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;Height(A)=3
Height(B)=2
Height(D)=1
Height(E)=1
Height(C)=2
Height(F)=1
&lt;/code&gt;&lt;/pre&gt;&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;已给出的代码如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#1e889b&#34;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#1e889b&#34;&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;using&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;namespace&lt;/span&gt; std;
&lt;span style=&#34;color:#228b22&#34;&gt;//数据元素类型
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;char&lt;/span&gt; ElemType;
&lt;span style=&#34;color:#228b22&#34;&gt;//二叉树结点定义
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;TreeNode&lt;/span&gt;
{	ElemType data;
	&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;TreeNode&lt;/span&gt; *lson, *rson;
} TreeNode;
&lt;span style=&#34;color:#228b22&#34;&gt;//二叉树类
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;BinaryTree&lt;/span&gt;
{  &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;private&lt;/span&gt;:
	TreeNode *root;
   &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt;:
	BinaryTree() { root = &lt;span style=&#34;color:#658b00&#34;&gt;NULL&lt;/span&gt;; };
	~BinaryTree() { MakeEmpty(root); }
	&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;MakeEmpty&lt;/span&gt;(TreeNode *t);
	&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;create&lt;/span&gt;( ) { root = cp_create(root); };  &lt;span style=&#34;color:#228b22&#34;&gt;//完全前序建立二叉树，空指针用@表示
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;	TreeNode *&lt;span style=&#34;color:#008b45&#34;&gt;cp_create&lt;/span&gt;(TreeNode *t);
	
	&lt;span style=&#34;color:#228b22&#34;&gt;//******  要补充的函数height ********
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;height&lt;/span&gt;(TreeNode *t) ;    &lt;span style=&#34;color:#228b22&#34;&gt;//求二叉树的高度
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;output&lt;/span&gt;() { Pro_height(root); };
	&lt;span style=&#34;color:#228b22&#34;&gt;//******  要补充的函数 Pro_height **********
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;Pro_height&lt;/span&gt;(TreeNode *t);  &lt;span style=&#34;color:#228b22&#34;&gt;// 前序顺序输出各个元素结点为根的子树的高度      
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;};
&lt;span style=&#34;color:#228b22&#34;&gt;//二叉树置空
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;void&lt;/span&gt; BinaryTree::MakeEmpty(TreeNode *t)
{	&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (t != &lt;span style=&#34;color:#658b00&#34;&gt;NULL&lt;/span&gt;)
	{	MakeEmpty(t-&amp;gt;lson);
		MakeEmpty(t-&amp;gt;rson);
		&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;delete&lt;/span&gt; t;
	}
}
&lt;span style=&#34;color:#228b22&#34;&gt;//完全前序序列创建二叉树，空指针用@表示
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;TreeNode *BinaryTree::cp_create(TreeNode *t)
{	ElemType v;
	cin &amp;gt;&amp;gt; v;
	&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (v != &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;@&amp;#39;&lt;/span&gt;)
	{	t = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; TreeNode;
		t-&amp;gt;data = v;
		t-&amp;gt;lson = cp_create(t-&amp;gt;lson);
		t-&amp;gt;rson = cp_create(t-&amp;gt;rson);
	}
	&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;else&lt;/span&gt; t = &lt;span style=&#34;color:#658b00&#34;&gt;NULL&lt;/span&gt;;
	&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; t;
}
&lt;span style=&#34;color:#228b22&#34;&gt;//********************  需要补充写出的两个函数  ****************************
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;//*******************************************************************************
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;//主函数
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;main&lt;/span&gt;()
{	BinaryTree t;
	t.create();
	t.output();	
	&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;answer&#34;&gt;Answer&lt;/h3&gt;
&lt;p&gt;求树高度，递归。貌似没有必要判断lson和rson是否为空，不过凑合着吧……&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; BinaryTree::height(TreeNode* t)
{
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt;(t==&lt;span style=&#34;color:#658b00&#34;&gt;NULL&lt;/span&gt;){
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;;
    }
    &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; l=&lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;,r=&lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;;
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt;(t-&amp;gt;lson!=&lt;span style=&#34;color:#658b00&#34;&gt;NULL&lt;/span&gt;){
        l=height(t-&amp;gt;lson);
    }
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt;(t-&amp;gt;rson!=&lt;span style=&#34;color:#658b00&#34;&gt;NULL&lt;/span&gt;){
        r=height(t-&amp;gt;rson);
    }
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;max&lt;/span&gt;(l,r)+&lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;;
}
&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;void&lt;/span&gt; BinaryTree::Pro_height(TreeNode* t)
{
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt;(t==&lt;span style=&#34;color:#658b00&#34;&gt;NULL&lt;/span&gt;){
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt;;
    }
    cout&amp;lt;&amp;lt;&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;Height(&amp;#34;&lt;/span&gt;&amp;lt;&amp;lt;t-&amp;gt;data&amp;lt;&amp;lt;&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;)=&amp;#34;&lt;/span&gt;&amp;lt;&amp;lt;height(t)&amp;lt;&amp;lt;endl;
    Pro_height(t-&amp;gt;lson);
    Pro_height(t-&amp;gt;rson);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;二&#34;&gt;二&lt;/h2&gt;
&lt;p&gt;假设二叉树的数据元素为字符，采用二叉链式存储结构。二叉树ADT实现的大部分代码已经给出，其中二叉树采用完全前序序列创建。请补充一个二叉树的输出函数，要求按目录缩进的形式输出一棵二叉树，同时要输出目录的层次。层次占2位、元素占1位，间隔4个位置（即共占7个位置）。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注意：答案区只写指定补充的函数代码，其他给定的代码不允许重写、修改和提交！
例如：有如右图的二叉树   &lt;img src=&#34;https://ntutn.top/file/down/1559400741461.jpg&#34; alt=&#34;二叉树&#34; title=&#34;二叉树&#34;&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;输入-1&#34;&gt;输入&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;ABD@@E@@C@F@@
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;输出-1&#34;&gt;输出：&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt; 1A
          2B
                   3D
                   3E
         2C
                   3F
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;给出的代码如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#1e889b&#34;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#1e889b&#34;&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;#include&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;using&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;namespace&lt;/span&gt; std;
&lt;span style=&#34;color:#228b22&#34;&gt;//数据元素类型
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;char&lt;/span&gt; ElemType;
&lt;span style=&#34;color:#228b22&#34;&gt;//二叉树结点定义
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;TreeNode&lt;/span&gt;
{	ElemType data;
	&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;TreeNode&lt;/span&gt; *lson, *rson;
} TreeNode;
&lt;span style=&#34;color:#228b22&#34;&gt;//二叉树类
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;BinaryTree&lt;/span&gt;
{ &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;private&lt;/span&gt;:
	TreeNode *root;
  &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt;:
	BinaryTree() { root = &lt;span style=&#34;color:#658b00&#34;&gt;NULL&lt;/span&gt;; };
	~BinaryTree() { MakeEmpty(root); }
	&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;MakeEmpty&lt;/span&gt;(TreeNode *t);
	&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;create&lt;/span&gt;( ) { root = cp_create(root); };  &lt;span style=&#34;color:#228b22&#34;&gt;//完全前序建立二叉树，空指针用@表示
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;	TreeNode *&lt;span style=&#34;color:#008b45&#34;&gt;cp_create&lt;/span&gt;(TreeNode *t);
	&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;output&lt;/span&gt;( ) { Index_print(root,&lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;); };
	&lt;span style=&#34;color:#228b22&#34;&gt;//*********** 下面是需要自己完成的函数 ******************   
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;Index_print&lt;/span&gt;(TreeNode *t,&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; l);  &lt;span style=&#34;color:#228b22&#34;&gt;//缩进目录形式输出二叉树      
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;};
&lt;span style=&#34;color:#228b22&#34;&gt;//二叉树置空
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;void&lt;/span&gt; BinaryTree::MakeEmpty(TreeNode *t)
{	&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (t != &lt;span style=&#34;color:#658b00&#34;&gt;NULL&lt;/span&gt;)
	{	MakeEmpty(t-&amp;gt;lson);
		MakeEmpty(t-&amp;gt;rson);
		&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;delete&lt;/span&gt; t;
	}
}
&lt;span style=&#34;color:#228b22&#34;&gt;//完全前序序列创建二叉树，空指针用@表示
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;TreeNode *BinaryTree::cp_create(TreeNode *t)
{	ElemType v;
	cin &amp;gt;&amp;gt; v;
	&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (v != &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;@&amp;#39;&lt;/span&gt;)
	{	t = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; TreeNode;
		t-&amp;gt;data = v;
		t-&amp;gt;lson = cp_create(t-&amp;gt;lson);
		t-&amp;gt;rson = cp_create(t-&amp;gt;rson);
	}
	&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;else&lt;/span&gt; t = &lt;span style=&#34;color:#658b00&#34;&gt;NULL&lt;/span&gt;;
	&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; t;
}
&lt;span style=&#34;color:#228b22&#34;&gt;//*****下面是要补充的函数Index_print  *************
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;//*************************************************
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;//主函数
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;main&lt;/span&gt;()
{	BinaryTree t;
	t.create();      &lt;span style=&#34;color:#228b22&#34;&gt;//创建二叉树
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;	t.output();       &lt;span style=&#34;color:#228b22&#34;&gt;//按规定格式输出二叉树
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;	cout&amp;lt;&amp;lt; endl;
	&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;answer-1&#34;&gt;Answer&lt;/h3&gt;
&lt;p&gt;完全前序遍历，递归，注意输出格式。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;void&lt;/span&gt; BinaryTree::Index_print(TreeNode* t, &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; l)
{
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt;(t==&lt;span style=&#34;color:#658b00&#34;&gt;NULL&lt;/span&gt;){
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt;;
    }
    cout&amp;lt;&amp;lt;&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39; &amp;#39;&lt;/span&gt;;
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt;(&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; i=&lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;;i&amp;lt;l-&lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;;i++){
        cout&amp;lt;&amp;lt;&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;       &amp;#34;&lt;/span&gt;;
    }
    cout&amp;lt;&amp;lt;l&amp;lt;&amp;lt;t-&amp;gt;data&amp;lt;&amp;lt;endl;
    Index_print(t-&amp;gt;lson,l+&lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;);
    Index_print(t-&amp;gt;rson,l+&lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;- https://ntutn.top/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%89%E6%AC%A1%E6%B5%8B%E8%AF%95/ - CC BY-SA 4.0</description>
        </item>
    
    
    
        <item>
        <title>稀疏矩阵的压缩存储</title>
        <link>https://ntutn.top/posts/%E7%A8%80%E7%96%8F%E7%9F%A9%E9%98%B5%E7%9A%84%E5%8E%8B%E7%BC%A9%E5%AD%98%E5%82%A8/</link>
        <pubDate>Sat, 01 Jun 2019 03:11:37 +0800</pubDate>
        
        <guid>https://ntutn.top/posts/%E7%A8%80%E7%96%8F%E7%9F%A9%E9%98%B5%E7%9A%84%E5%8E%8B%E7%BC%A9%E5%AD%98%E5%82%A8/</guid>
        <description>归零幻想 https://ntutn.top/posts/%E7%A8%80%E7%96%8F%E7%9F%A9%E9%98%B5%E7%9A%84%E5%8E%8B%E7%BC%A9%E5%AD%98%E5%82%A8/ -&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;特殊矩阵在采用二维数组存储时，尽管矩阵操作的算法都很简单，但是其空间的利用率很低。 系数矩阵就是一种应用很广泛的特殊的矩阵。现要求稀疏矩阵采用“压缩”存储，实现矩阵的常用操作，如输出、转置、求和等。&lt;/p&gt;
&lt;h2 id=&#34;question&#34;&gt;Question&lt;/h2&gt;
&lt;p&gt;矩阵采用“压缩”存储，实现矩阵的常用操作，如输出、转置、求和等。&lt;/p&gt;
&lt;p&gt;矩阵的输入：有多行，第1行包括三个整数，分别是矩阵的大小m,n及非零元素的个数r。后面r行分别输入各个非零元素的 行、列、值&lt;/p&gt;
&lt;p&gt;矩阵的输出：按人们习惯的矩阵格式输出，即输出一个&lt;code&gt;m*n&lt;/code&gt;的矩阵，是零元素的输出0，非零元素输出元素值。&lt;/p&gt;
&lt;p&gt;例如：输入如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;100 90 5 //矩阵的行数为100，列数为90，共5个非零元素。
1 10 100 //a(1,10)=100
50 60 200//a(50,60)=200
50 80 100//a(50,80)=100
60 60 200//a(60,60)=200
99 89 10//a(99,89)=10
100 90 4 //矩阵b的行数为100，列数为90，共4个非零元素。
1 1 10 //b(1,1)=10
50 60 -200//b(50,60)=-200
50 80 100 //b(50,80)=100
70 70 10 //b(70,70)=10
&lt;/code&gt;&lt;/pre&gt;&lt;!-- raw HTML omitted --&gt;
&lt;h2 id=&#34;example&#34;&gt;Example&lt;/h2&gt;
&lt;h3 id=&#34;input&#34;&gt;Input&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;100 90 5
1 10 100
50 60 200
50 80 100
60 60 200
99 89 10
100 90 4
1 1 10
50 60 -200
50 80 100
70 70 10
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;output&#34;&gt;Output&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;The transformed matrix  is:
10 1 100
60 50 200
60 60 200
80 50 100
89 99 10
The added matrix is:
1 1 10
1 10 100
50 80 200
60 60 200
70 70 10
99 89 10
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;分析&#34;&gt;分析&lt;/h2&gt;
&lt;p&gt;首先题目描述有错。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;按人们习惯的矩阵格式输出
应该是仍然按照题目中格式输出。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;所谓矩阵的压缩存储，实际上是在矩阵中元素较少时，只存非零元素的方法。在矩阵比较特殊（如三角阵）或矩阵元素比较稀疏的情况下能大大节省存储空间。但同时，压缩存储也会导致访问效率下降。&lt;/p&gt;
&lt;p&gt;所以这里我们定义了结构体来存储矩阵中的某个元素：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;struct&lt;/span&gt;{
    &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; row;
    &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; column;
    &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; data;
}point;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;此题中第一部分，矩阵转置，通过观察即可知道，行变列列变行，只需交换元素&lt;code&gt;row&lt;/code&gt;和&lt;code&gt;column&lt;/code&gt;即可。&lt;/p&gt;
&lt;p&gt;但交换后有个问题，即按照题目给出的标准输出，显然先输出行号小的元素，行号相等先输出列号小的元素。这就涉及了结构体数组的二级排序，也不难：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int cmp(const void *p1,const void *p2){
    if(((point*)p1)-&amp;gt;row==((point*)p2)-&amp;gt;row){
        return ((point*)p1)-&amp;gt;column-((point*)p2)-&amp;gt;column;
    }
    return ((point*)p1)-&amp;gt;row-((point*)p2)-&amp;gt;row;
}
qsort(res,pA,sizeof(point),cmp);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;至于第二问，两矩阵相加，类似归并的思想，每次找到小的拿过来，两者相等就相加。不过这里注意，两者相加有可能结果为0，要消去这组数据。&lt;/p&gt;
&lt;h2 id=&#34;anwser&#34;&gt;Anwser&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#1e889b&#34;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#1e889b&#34;&gt;&amp;lt;cstdlib&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;using&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;namespace&lt;/span&gt; std;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;struct&lt;/span&gt;{
    &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; row;
    &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; column;
    &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; data;
}point;
&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;cmp&lt;/span&gt;(&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;void&lt;/span&gt; *p1,&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;void&lt;/span&gt; *p2){
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt;(((point*)p1)-&amp;gt;row==((point*)p2)-&amp;gt;row){
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; ((point*)p1)-&amp;gt;column-((point*)p2)-&amp;gt;column;
    }
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; ((point*)p1)-&amp;gt;row-((point*)p2)-&amp;gt;row;
}
&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;printMatrix&lt;/span&gt;(point*p,&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; n){
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt;(&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; i=&lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;;i&amp;lt;n;i++){
        cout&amp;lt;&amp;lt;p[i].row&amp;lt;&amp;lt;&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39; &amp;#39;&lt;/span&gt;&amp;lt;&amp;lt;p[i].column&amp;lt;&amp;lt;&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39; &amp;#39;&lt;/span&gt;&amp;lt;&amp;lt;p[i].data&amp;lt;&amp;lt;endl;
    }
}
&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;cmpPos&lt;/span&gt;(point*p1,point*p2){&lt;span style=&#34;color:#228b22&#34;&gt;//其实这个函数多余，直接用前面那个cmp函数也能达到比较的目的，不过我不习惯
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt;(p1-&amp;gt;row!=p2-&amp;gt;row){
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; p1-&amp;gt;row-p2-&amp;gt;row;
    }
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt;(p1-&amp;gt;column!=p2-&amp;gt;column){
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; p1-&amp;gt;column-p2-&amp;gt;column;
    }
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;;
}
&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;main&lt;/span&gt;()
{
    &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; mA,nA,pA;&lt;span style=&#34;color:#228b22&#34;&gt;//第一个矩阵的行数、列数、非空元素数目
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; mB,nB,pB;
    point*dataA;
    point*dataB;
    point*res;&lt;span style=&#34;color:#228b22&#34;&gt;//存储结果
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    cin&amp;gt;&amp;gt;mA&amp;gt;&amp;gt;nA&amp;gt;&amp;gt;pA;
    dataA=&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; point[pA];
    res=&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; point[pA];
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt;(&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; i=&lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;;i&amp;lt;pA;i++){
        cin&amp;gt;&amp;gt;dataA[i].row&amp;gt;&amp;gt;dataA[i].column&amp;gt;&amp;gt;dataA[i].data;
        res[i].row=dataA[i].column;&lt;span style=&#34;color:#228b22&#34;&gt;//转置
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        res[i].column=dataA[i].row;
        res[i].data=dataA[i].data;
    }
    cin&amp;gt;&amp;gt;mB&amp;gt;&amp;gt;nB&amp;gt;&amp;gt;pB;
    dataB=&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; point[pB];
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt;(&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; i=&lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;;i&amp;lt;pB;i++){
        cin&amp;gt;&amp;gt;dataB[i].row&amp;gt;&amp;gt;dataB[i].column&amp;gt;&amp;gt;dataB[i].data;
    }
    qsort(res,pA,&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;sizeof&lt;/span&gt;(point),cmp);
    cout&amp;lt;&amp;lt;&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;The transformed matrix  is:&amp;#34;&lt;/span&gt;&amp;lt;&amp;lt;endl;
    printMatrix(res,pA);
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;delete&lt;/span&gt;[] res;
    res=&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; point[pA+pB];&lt;span style=&#34;color:#228b22&#34;&gt;//结果元素数目总小于等于二者之和
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    point*p1=dataA;
    point*p2=dataB;
    point*p3=res;
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;while&lt;/span&gt;(p1&amp;lt;dataA+pA&amp;amp;&amp;amp;p2&amp;lt;dataB+pB){
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt;(cmpPos(p1,p2)&amp;lt;&lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;){
            *p3=*p1;
            p1++;
        }&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt;(cmpPos(p1,p2)==&lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;){
            *p3=*p1;
            p3-&amp;gt;data=p1-&amp;gt;data+p2-&amp;gt;data;
            p1++;
            p2++;
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt;(p3-&amp;gt;data==&lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;){
                p3--;
            }
        }&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;else&lt;/span&gt;{
            *p3=*p2;
            p2++;
        }
        p3++;
    }
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;while&lt;/span&gt;(p1&amp;lt;dataA+pA){
        *p3=*p1;
        p3++;
        p1++;
    }
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;while&lt;/span&gt;(p2&amp;lt;dataB+pB){
        *p3=*p2;
        p3++;
        p2++;
    }
    cout&amp;lt;&amp;lt;&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;The added matrix is:&amp;#34;&lt;/span&gt;&amp;lt;&amp;lt;endl;
    printMatrix(res,p3-res);
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;delete&lt;/span&gt;[] res;
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;delete&lt;/span&gt;[] dataA;
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;delete&lt;/span&gt;[] dataB;
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;- https://ntutn.top/posts/%E7%A8%80%E7%96%8F%E7%9F%A9%E9%98%B5%E7%9A%84%E5%8E%8B%E7%BC%A9%E5%AD%98%E5%82%A8/ - CC BY-SA 4.0</description>
        </item>
    
    
    
        <item>
        <title>统计递归子问题个数</title>
        <link>https://ntutn.top/posts/%E7%BB%9F%E8%AE%A1%E9%80%92%E5%BD%92%E5%AD%90%E9%97%AE%E9%A2%98%E4%B8%AA%E6%95%B0/</link>
        <pubDate>Fri, 17 May 2019 03:11:37 +0800</pubDate>
        
        <guid>https://ntutn.top/posts/%E7%BB%9F%E8%AE%A1%E9%80%92%E5%BD%92%E5%AD%90%E9%97%AE%E9%A2%98%E4%B8%AA%E6%95%B0/</guid>
        <description>归零幻想 https://ntutn.top/posts/%E7%BB%9F%E8%AE%A1%E9%80%92%E5%BD%92%E5%AD%90%E9%97%AE%E9%A2%98%E4%B8%AA%E6%95%B0/ -&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;分治策略是算法设计的重要策略之一，该策略的基本思想是把问题进行分解成一些子问题，通过子问题的求解完成对原问题的求解。其关键是分解和合并，好的分解或合并方法才会产生高效的分治算法。&lt;/p&gt;
&lt;p&gt;分治策略设计出的算法最常见的就是递归算法。但是如果在分解时，分解出的子问题有很多是重复的，那么这样的分治（递归）算法求解问题的效率就非常低。例如斐波那契数问题，如果采用递归求解，算法效率非常低：O(2^n)。而如果采用递推求解(动态规划自底向上求解)，算法效率非常高：O(n)。&lt;/p&gt;
&lt;h2 id=&#34;question&#34;&gt;Question&lt;/h2&gt;
&lt;p&gt;现在请你编写程序，统计计算一个斐波那契数时分解出的各子问题的个数。&lt;/p&gt;
&lt;p&gt;斐波那契数的定义如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Fib(0)=0
Fib(1)=1
Fib(n)=Fib(n-1)+Fib(n-2)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输入：一个整数n，即计算&lt;code&gt;Fib(n)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;输出：n+1行，即各个子问题的值及该子问题的个数。&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;h2 id=&#34;example&#34;&gt;Example&lt;/h2&gt;
&lt;h3 id=&#34;input&#34;&gt;Input&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;5
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;output&#34;&gt;Output&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;Fib(0)=0,spn=3
Fib(1)=1,spn=5
Fib(2)=1,spn=3
Fib(3)=2,spn=2
Fib(4)=3,spn=1
Fib(5)=5,spn=1
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;分析&#34;&gt;分析&lt;/h2&gt;
&lt;p&gt;一大段分治思想的介绍，递归与递推的区别，我以为这题用递归会超时，要用递推求解，于是入坑……&lt;/p&gt;
&lt;p&gt;这题要统计子问题个数，递推或者递归加备忘录根本没重复的计算怎么统计……&lt;/p&gt;
&lt;p&gt;不死心的我又仔细研究递推子问题个数的规律，发现子问题个数正好是一个反着的斐波那契数列（结尾元素特殊处理），所以可以正向递推求数列，反向递推求子问题个数。&lt;/p&gt;
&lt;p&gt;不过特殊情况研究的有点头疼，暂时就不搞了，下面给出的是老老实实递归求解的程序。&lt;/p&gt;
&lt;h2 id=&#34;answer&#34;&gt;Answer&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#1e889b&#34;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#1e889b&#34;&gt;&amp;lt;cstring&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;using&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;namespace&lt;/span&gt; std;
&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt;*spn;
&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt;*data;
&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;fib&lt;/span&gt;(&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; n){
    spn[n]++;
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt;(n==&lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;){
        data[&lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;]=&lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;;
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;;
    }
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt;(n==&lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;){
        data[&lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;]=&lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;;
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;;
    }
    &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; res=fib(n-&lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;)+fib(n-&lt;span style=&#34;color:#b452cd&#34;&gt;2&lt;/span&gt;);
    data[n]=res;
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; res;
}
&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;main&lt;/span&gt;()
{
    &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; n;
    cin&amp;gt;&amp;gt;n;
    spn=&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt;[n+&lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;];
    data=&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt;[n+&lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;];
    memset(spn,&lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;,(n+&lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;)*&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;sizeof&lt;/span&gt;(&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt;));
    memset(data,-&lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;,(n+&lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;)*&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;sizeof&lt;/span&gt;(&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt;));
    data[&lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;]=&lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;;
    data[&lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;]=&lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;;
    fib(n);
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt;(&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; i=&lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;;i&amp;lt;=n;i++){
        cout&amp;lt;&amp;lt;&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;Fib(&amp;#34;&lt;/span&gt;&amp;lt;&amp;lt;i&amp;lt;&amp;lt;&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;)=&amp;#34;&lt;/span&gt;&amp;lt;&amp;lt;data[i]&amp;lt;&amp;lt;&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;,spn=&amp;#34;&lt;/span&gt;&amp;lt;&amp;lt;spn[i]&amp;lt;&amp;lt;endl;
    }
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;- https://ntutn.top/posts/%E7%BB%9F%E8%AE%A1%E9%80%92%E5%BD%92%E5%AD%90%E9%97%AE%E9%A2%98%E4%B8%AA%E6%95%B0/ - CC BY-SA 4.0</description>
        </item>
    
    
    
        <item>
        <title>二叉树ADT的实现</title>
        <link>https://ntutn.top/posts/%E4%BA%8C%E5%8F%89%E6%A0%91adt%E7%9A%84%E5%AE%9E%E7%8E%B0/</link>
        <pubDate>Tue, 14 May 2019 03:11:37 +0800</pubDate>
        
        <guid>https://ntutn.top/posts/%E4%BA%8C%E5%8F%89%E6%A0%91adt%E7%9A%84%E5%AE%9E%E7%8E%B0/</guid>
        <description>归零幻想 https://ntutn.top/posts/%E4%BA%8C%E5%8F%89%E6%A0%91adt%E7%9A%84%E5%AE%9E%E7%8E%B0/ -&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;人工智能知识点整理Question&lt;/p&gt;
&lt;p&gt;假设二叉数的数据元素为字符，采用二叉链式存储结构。请编码实现二叉树ADT，其中包括创建二叉树、遍历二叉树（深度、广度）、求二叉树的深度（高度）、计算二叉树的元素个数、计算二叉树的叶子数、二叉树的格式输出等。&lt;/p&gt;
&lt;p&gt;根据输入的符号，执行相应的操作。如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;C：根据完全前序序列创建二叉树，#表示空结点（空子树）；输入：二叉树的完全前序序列，创建成功输出 &lt;code&gt;Created success!&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;H：求二叉树的高度；   输出： &lt;code&gt;Height=高度&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;L：计算二叉树的叶子数；输出：&lt;code&gt;Leaves=叶子个数&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;N：计算二叉树中元素总个数；输出：&lt;code&gt;Nodes=结点个数&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;1：先序遍历二叉树；输出：&lt;code&gt;Preorder is:序列 .&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;2：中序遍历二叉树；输出：&lt;code&gt;Inorder is:序列 .&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;3：后序遍历二叉树；输出：&lt;code&gt;Postorder is:序列 .&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;4：广度遍历二叉树；输出：&lt;code&gt;BFSorder is:序列 .&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;F：查找值为x的结点个数；输出：&lt;code&gt;The count of x is 个数 .&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;P：以目录缩格文本形式输出所有节点。输出：&lt;code&gt;The tree is:&lt;/code&gt;（换行，下面各行是输出的二叉树）&lt;/li&gt;
&lt;li&gt;X：退出&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;h2 id=&#34;example&#34;&gt;Example&lt;/h2&gt;
&lt;h3 id=&#34;input&#34;&gt;Input&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;C
ABC##DE#G##F###
H
L
N
1
2
3
4
F
A
P
X
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;output&#34;&gt;Output&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;Created success!
Height=5
Leaves=3
Nodes=7
Preorder is:A B C D E G F .
Inorder is:C B E G D F A .
Postorder is:C G E F D B A .
BFSorder is:A B C D E F G .
The count of A is 1
The tree is:
A
  B
    C
    D
      E
        G
      F
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;分析&#34;&gt;分析&lt;/h2&gt;
&lt;p&gt;二叉树不多说，数据结构的基本内容。这题主要就是麻烦，要求的操作比较多，一看肯定不卡时间，递归走起。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;递归一时爽，一直递归一直爽。
在思路清晰的情况下，递归大大降低了编码的复杂程度，于是创建递归，求叶子数递归，求高度递归，总个数递归，查找递归，目录形式输出递归，深度遍历递归，广度……咳咳，好吧，这个不用递归，要用个队列。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;不让用&lt;code&gt;STL&lt;/code&gt;，队列也只好手写。&lt;/p&gt;
&lt;p&gt;我一开始写程序&lt;code&gt;Leaves=&lt;/code&gt;写成了&lt;code&gt;Leaf=&lt;/code&gt;，这鬼畜的错误半天没检查出来。顺便推荐个文本差异对比工具吧，这样找起来也容易：&lt;a href=&#34;http://www.jq22.com/textDifference&#34; title=&#34;在线文本差异对比&#34;&gt;在线文本差异对比&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;算上空行都300行了，真是够麻烦的。&lt;/p&gt;
&lt;h2 id=&#34;answer&#34;&gt;Answer&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#1e889b&#34;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;using&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;namespace&lt;/span&gt; std;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;template&lt;/span&gt;&amp;lt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;T&lt;/span&gt;&amp;gt;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;QueueNode&lt;/span&gt;{
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt;:
    T data;
    QueueNode*link=&lt;span style=&#34;color:#658b00&#34;&gt;NULL&lt;/span&gt;;
    QueueNode(){
        ;
    }
    QueueNode(T data){
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;-&amp;gt;data=data;
    }
};
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;template&lt;/span&gt;&amp;lt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;T&lt;/span&gt;&amp;gt;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;Queue&lt;/span&gt;{
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;private&lt;/span&gt;:
    QueueNode&amp;lt;T&amp;gt;*tail=&lt;span style=&#34;color:#658b00&#34;&gt;NULL&lt;/span&gt;;
    QueueNode&amp;lt;T&amp;gt;*head=&lt;span style=&#34;color:#658b00&#34;&gt;NULL&lt;/span&gt;;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt;:
    &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;bool&lt;/span&gt; isEmpty(){
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; head==&lt;span style=&#34;color:#658b00&#34;&gt;NULL&lt;/span&gt;;
    }
    ~Queue(){
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;while&lt;/span&gt;(head!=&lt;span style=&#34;color:#658b00&#34;&gt;NULL&lt;/span&gt;){
            QueueNode&amp;lt;T&amp;gt;*p=head-&amp;gt;link;
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;delete&lt;/span&gt; head;
            head=p;
        }
    }
    &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;enQueue&lt;/span&gt;(T data){
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt;(tail==&lt;span style=&#34;color:#658b00&#34;&gt;NULL&lt;/span&gt;){
            head=tail=&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; QueueNode&amp;lt;T&amp;gt;(data);
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt;;
        }
        tail-&amp;gt;link=&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; QueueNode&amp;lt;T&amp;gt;(data);
        tail=tail-&amp;gt;link;
    }
    T &lt;span style=&#34;color:#008b45&#34;&gt;deQueue&lt;/span&gt;(){
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt;(isEmpty()){
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#658b00&#34;&gt;NULL&lt;/span&gt;;
        }
        T res=head-&amp;gt;data;
        QueueNode&amp;lt;T&amp;gt;*tmp=head;
        head=head-&amp;gt;link;
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;delete&lt;/span&gt; tmp;
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt;(head==&lt;span style=&#34;color:#658b00&#34;&gt;NULL&lt;/span&gt;){
            tail=&lt;span style=&#34;color:#658b00&#34;&gt;NULL&lt;/span&gt;;
        }
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; res;
    }
};
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;Tree&lt;/span&gt;;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;Node&lt;/span&gt;{
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;friend&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;Tree&lt;/span&gt;;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;private&lt;/span&gt;:
    &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;char&lt;/span&gt; data=&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;\0&amp;#39;&lt;/span&gt;;
    Node*lChild=&lt;span style=&#34;color:#658b00&#34;&gt;NULL&lt;/span&gt;;
    Node*rChild=&lt;span style=&#34;color:#658b00&#34;&gt;NULL&lt;/span&gt;;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt;:
    Node(){
        ;
    }
    Node(&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;char&lt;/span&gt; data){
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;-&amp;gt;data=data;
    }
};
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;Tree&lt;/span&gt;{
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;private&lt;/span&gt;:
    Node*root=&lt;span style=&#34;color:#658b00&#34;&gt;NULL&lt;/span&gt;;
    &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;createTree&lt;/span&gt;(Node*&amp;amp;p,string&amp;amp;str,&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt;&amp;amp;id){
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt;(id&amp;gt;=str.size()){
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt;;
        }
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt;(str.at(id)==&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;#&amp;#39;&lt;/span&gt;){
            id++;
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt;;
        }
        p=&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; Node();
        p-&amp;gt;data=str.at(id);
        id++;
        createTree(p-&amp;gt;lChild,str,id);
        createTree(p-&amp;gt;rChild,str,id);
    }
    size_t &lt;span style=&#34;color:#008b45&#34;&gt;getHeight&lt;/span&gt;(Node*p){
        size_t lHeight;
        size_t rHeight;
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt;(p-&amp;gt;lChild==&lt;span style=&#34;color:#658b00&#34;&gt;NULL&lt;/span&gt;){
            lHeight=&lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;;
        }&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;else&lt;/span&gt;{
            lHeight=getHeight(p-&amp;gt;lChild);
        }
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt;(p-&amp;gt;rChild==&lt;span style=&#34;color:#658b00&#34;&gt;NULL&lt;/span&gt;){
            rHeight=&lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;;
        }&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;else&lt;/span&gt;{
            rHeight=getHeight(p-&amp;gt;rChild);
        }
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; max(lHeight,rHeight)+&lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;;
    }
    size_t &lt;span style=&#34;color:#008b45&#34;&gt;getLeaves&lt;/span&gt;(Node*p){
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt;(p==&lt;span style=&#34;color:#658b00&#34;&gt;NULL&lt;/span&gt;){
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;;
        }
        size_t res=&lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;;
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt;(p-&amp;gt;lChild==&lt;span style=&#34;color:#658b00&#34;&gt;NULL&lt;/span&gt;&amp;amp;&amp;amp;p-&amp;gt;rChild==&lt;span style=&#34;color:#658b00&#34;&gt;NULL&lt;/span&gt;){
            res++;
        }
        res+=getLeaves(p-&amp;gt;lChild);
        res+=getLeaves(p-&amp;gt;rChild);
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; res;
    }
    size_t &lt;span style=&#34;color:#008b45&#34;&gt;getNodes&lt;/span&gt;(Node*p){
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt;(p==&lt;span style=&#34;color:#658b00&#34;&gt;NULL&lt;/span&gt;){
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;;
        }
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; getNodes(p-&amp;gt;lChild)+getNodes(p-&amp;gt;rChild)+&lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;;
    }
    &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;visit1&lt;/span&gt;(Node*p){
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt;(p==&lt;span style=&#34;color:#658b00&#34;&gt;NULL&lt;/span&gt;){
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt;;
        }
        cout&amp;lt;&amp;lt;p-&amp;gt;data&amp;lt;&amp;lt;&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39; &amp;#39;&lt;/span&gt;;
        visit1(p-&amp;gt;lChild);
        visit1(p-&amp;gt;rChild);
    }
    &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;visit2&lt;/span&gt;(Node*p){
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt;(p==&lt;span style=&#34;color:#658b00&#34;&gt;NULL&lt;/span&gt;){
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt;;
        }
        visit2(p-&amp;gt;lChild);
        cout&amp;lt;&amp;lt;p-&amp;gt;data&amp;lt;&amp;lt;&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39; &amp;#39;&lt;/span&gt;;
        visit2(p-&amp;gt;rChild);
    }
    &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;visit3&lt;/span&gt;(Node*p){
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt;(p==&lt;span style=&#34;color:#658b00&#34;&gt;NULL&lt;/span&gt;){
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt;;
        }
        visit3(p-&amp;gt;lChild);
        visit3(p-&amp;gt;rChild);
        cout&amp;lt;&amp;lt;p-&amp;gt;data&amp;lt;&amp;lt;&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39; &amp;#39;&lt;/span&gt;;
    }
    &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;delNode&lt;/span&gt;(Node*p){
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt;(p==&lt;span style=&#34;color:#658b00&#34;&gt;NULL&lt;/span&gt;){
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt;;
        }
        delNode(p-&amp;gt;lChild);
        delNode(p-&amp;gt;rChild);
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;delete&lt;/span&gt; p;
    }
    &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;search&lt;/span&gt;(&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;char&lt;/span&gt; c,Node*p){
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt;(p==&lt;span style=&#34;color:#658b00&#34;&gt;NULL&lt;/span&gt;){
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;;
        }
        &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; res=p-&amp;gt;data==c?&lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;:&lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;;
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; search(c,p-&amp;gt;lChild)+search(c,p-&amp;gt;rChild)+res;
    }
    &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;indexTree&lt;/span&gt;(Node*p,&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; depth){
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt;(p==&lt;span style=&#34;color:#658b00&#34;&gt;NULL&lt;/span&gt;){
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt;;
        }
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt;(&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; i=&lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;;i&amp;lt;depth;i++){
            cout&amp;lt;&amp;lt;&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39; &amp;#39;&lt;/span&gt;&amp;lt;&amp;lt;&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39; &amp;#39;&lt;/span&gt;;
        }
        cout&amp;lt;&amp;lt;p-&amp;gt;data&amp;lt;&amp;lt;endl;
        indexTree(p-&amp;gt;lChild,depth+&lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;);
        indexTree(p-&amp;gt;rChild,depth+&lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;);
    }
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt;:
    Tree(string str){
        &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; id=&lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;;
        createTree(root,str,id);
    }
    size_t &lt;span style=&#34;color:#008b45&#34;&gt;getHeight&lt;/span&gt;(){
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; getHeight(root);
    }
    size_t &lt;span style=&#34;color:#008b45&#34;&gt;getLeaves&lt;/span&gt;(){
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; getLeaves(root);
    }
    size_t &lt;span style=&#34;color:#008b45&#34;&gt;getNodes&lt;/span&gt;(){
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; getNodes(root);
    }
    &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;visit1&lt;/span&gt;(){
        cout&amp;lt;&amp;lt;&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;Preorder is:&amp;#34;&lt;/span&gt;;
        visit1(root);
        cout&amp;lt;&amp;lt;&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;.&amp;#39;&lt;/span&gt;&amp;lt;&amp;lt;endl;
    }
    &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;visit2&lt;/span&gt;(){
        cout&amp;lt;&amp;lt;&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;Inorder is:&amp;#34;&lt;/span&gt;;
        visit2(root);
        cout&amp;lt;&amp;lt;&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;.&amp;#39;&lt;/span&gt;&amp;lt;&amp;lt;endl;
    }
    &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;visit3&lt;/span&gt;(){
        cout&amp;lt;&amp;lt;&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;Postorder is:&amp;#34;&lt;/span&gt;;
        visit3(root);
        cout&amp;lt;&amp;lt;&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;.&amp;#39;&lt;/span&gt;&amp;lt;&amp;lt;endl;
    }
    &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;visitBFS&lt;/span&gt;(){
        Queue&amp;lt;Node*&amp;gt;*q=&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; Queue&amp;lt;Node*&amp;gt;();
        q-&amp;gt;enQueue(root);
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;while&lt;/span&gt;(!q-&amp;gt;isEmpty()){
            Node*tmp=q-&amp;gt;deQueue();
            cout&amp;lt;&amp;lt;tmp-&amp;gt;data&amp;lt;&amp;lt;&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39; &amp;#39;&lt;/span&gt;;
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt;(tmp-&amp;gt;lChild!=&lt;span style=&#34;color:#658b00&#34;&gt;NULL&lt;/span&gt;){
                q-&amp;gt;enQueue(tmp-&amp;gt;lChild);
            }
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt;(tmp-&amp;gt;rChild!=&lt;span style=&#34;color:#658b00&#34;&gt;NULL&lt;/span&gt;){
                q-&amp;gt;enQueue(tmp-&amp;gt;rChild);
            }
        }
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;delete&lt;/span&gt; q;
    }
    &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;search&lt;/span&gt;(&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;char&lt;/span&gt; c){
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; search(c,root);
    }
    &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;indexTree&lt;/span&gt;(){
        indexTree(root,&lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;);
    }
    ~Tree(){
        delNode(root);
    }
};
&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;main&lt;/span&gt;()
{
    &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;char&lt;/span&gt; Op;
    Tree*tree;
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;while&lt;/span&gt;(cin&amp;gt;&amp;gt;Op){
        string str;
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;switch&lt;/span&gt;(Op){
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;case&lt;/span&gt; &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;C&amp;#39;&lt;/span&gt;:
            cin&amp;gt;&amp;gt;str;
            tree=&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; Tree(str);
            cout&amp;lt;&amp;lt;&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;Created success!&amp;#34;&lt;/span&gt;&amp;lt;&amp;lt;endl;
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;break&lt;/span&gt;;
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;case&lt;/span&gt; &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;H&amp;#39;&lt;/span&gt;:
            cout&amp;lt;&amp;lt;&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;Height=&amp;#34;&lt;/span&gt;&amp;lt;&amp;lt;tree-&amp;gt;getHeight()&amp;lt;&amp;lt;endl;
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;break&lt;/span&gt;;
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;case&lt;/span&gt; &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;L&amp;#39;&lt;/span&gt;:
            cout&amp;lt;&amp;lt;&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;Leaves=&amp;#34;&lt;/span&gt;&amp;lt;&amp;lt;tree-&amp;gt;getLeaves()&amp;lt;&amp;lt;endl;
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;break&lt;/span&gt;;
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;case&lt;/span&gt; &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;N&amp;#39;&lt;/span&gt;:
            cout&amp;lt;&amp;lt;&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;Nodes=&amp;#34;&lt;/span&gt;&amp;lt;&amp;lt;tree-&amp;gt;getNodes()&amp;lt;&amp;lt;endl;
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;break&lt;/span&gt;;
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;case&lt;/span&gt; &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;1&amp;#39;&lt;/span&gt;:
            tree-&amp;gt;visit1();
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;break&lt;/span&gt;;
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;case&lt;/span&gt; &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;2&amp;#39;&lt;/span&gt;:
            tree-&amp;gt;visit2();
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;break&lt;/span&gt;;
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;case&lt;/span&gt; &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;3&amp;#39;&lt;/span&gt;:
            tree-&amp;gt;visit3();
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;break&lt;/span&gt;;
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;case&lt;/span&gt; &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;4&amp;#39;&lt;/span&gt;:
            cout&amp;lt;&amp;lt;&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;BFSorder is:&amp;#34;&lt;/span&gt;;
            tree-&amp;gt;visitBFS();
            cout&amp;lt;&amp;lt;&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;.&amp;#39;&lt;/span&gt;&amp;lt;&amp;lt;endl;
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;break&lt;/span&gt;;
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;case&lt;/span&gt; &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;F&amp;#39;&lt;/span&gt;:
            &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;char&lt;/span&gt; x;
            cin&amp;gt;&amp;gt;x;
            cout&amp;lt;&amp;lt;&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;The count of &amp;#34;&lt;/span&gt;&amp;lt;&amp;lt;x&amp;lt;&amp;lt;&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34; is &amp;#34;&lt;/span&gt;&amp;lt;&amp;lt;tree-&amp;gt;search(x)&amp;lt;&amp;lt;endl;
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;break&lt;/span&gt;;
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;case&lt;/span&gt; &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;P&amp;#39;&lt;/span&gt;:
            cout&amp;lt;&amp;lt;&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;The tree is:&amp;#34;&lt;/span&gt;&amp;lt;&amp;lt;endl;
            tree-&amp;gt;indexTree();
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;break&lt;/span&gt;;
        }
    }
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;delete&lt;/span&gt; tree;
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;- https://ntutn.top/posts/%E4%BA%8C%E5%8F%89%E6%A0%91adt%E7%9A%84%E5%AE%9E%E7%8E%B0/ - CC BY-SA 4.0</description>
        </item>
    
    
    
        <item>
        <title>活动安排问题</title>
        <link>https://ntutn.top/posts/%E6%B4%BB%E5%8A%A8%E5%AE%89%E6%8E%92%E9%97%AE%E9%A2%98/</link>
        <pubDate>Mon, 13 May 2019 03:11:37 +0800</pubDate>
        
        <guid>https://ntutn.top/posts/%E6%B4%BB%E5%8A%A8%E5%AE%89%E6%8E%92%E9%97%AE%E9%A2%98/</guid>
        <description>归零幻想 https://ntutn.top/posts/%E6%B4%BB%E5%8A%A8%E5%AE%89%E6%8E%92%E9%97%AE%E9%A2%98/ -&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;经典的贪心问题。&lt;/p&gt;
&lt;h2 id=&#34;question&#34;&gt;Question&lt;/h2&gt;
&lt;p&gt;假设有n个活动的集合&lt;code&gt;E={a1,a2,...,an}&lt;/code&gt;，其每个活动都要求使用同一资源（如某个设备、教室、场地等），而在同一时间内只允许一个活动使用这一资源。&lt;/p&gt;
&lt;p&gt;每个活动都有一个要求使用该资源的起止时间&lt;code&gt;si&lt;/code&gt;,&lt;code&gt;fi&lt;/code&gt;，且&lt;code&gt;si&amp;lt;fi&lt;/code&gt;。如果选择了活动ai，则它在半开的时间区间&lt;code&gt;[si,fi)&lt;/code&gt;内占有资源。两个活动&lt;code&gt;ai&lt;/code&gt;,&lt;code&gt;aj&lt;/code&gt;称为是相容的，当且仅当它们的时间区间&lt;code&gt;[si,fi)&lt;/code&gt;和&lt;code&gt;[sj,fj)&lt;/code&gt;不相交，即&lt;code&gt;si&amp;gt;=fj&lt;/code&gt; 或 &lt;code&gt;sj &amp;gt;=fi&lt;/code&gt;。现要求在所给定的活动集中选出最大的相容活动子集。&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;请补充要求的函数代码。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;提示：贪心策略&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;输入，有多行，第1行是活动的个数n，后面n行，每行3个整数，是每个活动的编号、占用资源的开始时间、结束时间。&lt;/p&gt;
&lt;p&gt;输出，选出的最大活动子集，即有多行，每行包括活动的编号、开始时间、结束时间。&lt;/p&gt;
&lt;h2 id=&#34;example&#34;&gt;Example&lt;/h2&gt;
&lt;h3 id=&#34;input&#34;&gt;Input&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;11
1 3 8
2 2 13
3 1 4
4 5 7
5 6 10
6 8 11
7 12 14
8 5 9
9 3 5
10 0 6
11 8 12
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;output&#34;&gt;Output&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;3：1-4
4：5-7
6：8-11
7：12-14
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;分析&#34;&gt;分析&lt;/h2&gt;
&lt;p&gt;经典的贪心问题，贪心策略为选择结束时间最早的活动，因为这样就可以给后面的活动留出更多的时间。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;掉坑：在选择活动时只处理了前24小时的活动，而事实证明我画蛇添足了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;answer&#34;&gt;Answer&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#1e889b&#34;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#1e889b&#34;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#1e889b&#34;&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;using&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;namespace&lt;/span&gt; std;
&lt;span style=&#34;color:#228b22&#34;&gt;//定义允许的最大活动数
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;#define Maxn  100
&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;//定义活动的类型
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;typedef&lt;/span&gt;  &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;act_Node&lt;/span&gt;
{  &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; Id;       &lt;span style=&#34;color:#228b22&#34;&gt;//活动ID
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;   &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; s_Time;   &lt;span style=&#34;color:#228b22&#34;&gt;//活动开始时间
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;   &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; f_Time;   &lt;span style=&#34;color:#228b22&#34;&gt;//活动结束时间
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;} ACND;
&lt;span style=&#34;color:#228b22&#34;&gt;//对活动按贪心准则排序
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;Sort&lt;/span&gt;(&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; n,ACND arr[])
{
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt;(&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; i=&lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;;i&amp;lt;n;i++){
        &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; tmp=i;
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt;(&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; j=i+&lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;;j&amp;lt;n;j++){
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt;(arr[j].f_Time&amp;lt;arr[tmp].f_Time){
                tmp=j;
            }
        }
        ACND tmpSwap=arr[i];
        arr[i]=arr[tmp];
        arr[tmp]=tmpSwap;
    }
}
&lt;span style=&#34;color:#228b22&#34;&gt;//进行贪心选择，得到最大相容的活动集合输出
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;Select&lt;/span&gt;(&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; n,ACND arr[])
{
    &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; nTime=&lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;;
    ACND*p=arr;
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;while&lt;/span&gt;(p-arr&amp;lt;n){
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt;(p-&amp;gt;s_Time&amp;gt;=nTime){
            cout&amp;lt;&amp;lt;p-&amp;gt;Id&amp;lt;&amp;lt;&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;:&amp;#34;&lt;/span&gt;&amp;lt;&amp;lt;p-&amp;gt;s_Time&amp;lt;&amp;lt;&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;-&amp;#34;&lt;/span&gt;&amp;lt;&amp;lt;p-&amp;gt;f_Time&amp;lt;&amp;lt;endl;
            nTime=p-&amp;gt;f_Time;
        }
        p++;
    }
}
&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;main&lt;/span&gt;()
{  ACND arr[Maxn];
   &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; an,i;
   cin&amp;gt;&amp;gt;an;           &lt;span style=&#34;color:#228b22&#34;&gt;//读入活动个数
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;   &lt;span style=&#34;color:#228b22&#34;&gt;//读入各个活动的编号和占用资源的起止时间
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;   &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt;(i=&lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;;i&amp;lt;an;i++)
     cin&amp;gt;&amp;gt;arr[i].Id&amp;gt;&amp;gt;arr[i].s_Time&amp;gt;&amp;gt;arr[i].f_Time;
   &lt;span style=&#34;color:#228b22&#34;&gt;//对活动按贪心准则进行排序
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;   Sort(an,arr);
   &lt;span style=&#34;color:#228b22&#34;&gt;//进行贪心选择，获得最优解并输出
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;   Select(an,arr);
  &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;- https://ntutn.top/posts/%E6%B4%BB%E5%8A%A8%E5%AE%89%E6%8E%92%E9%97%AE%E9%A2%98/ - CC BY-SA 4.0</description>
        </item>
    
    
    
        <item>
        <title>线性表ADT的实现</title>
        <link>https://ntutn.top/posts/%E7%BA%BF%E6%80%A7%E8%A1%A8adt%E7%9A%84%E5%AE%9E%E7%8E%B0/</link>
        <pubDate>Mon, 13 May 2019 03:11:37 +0800</pubDate>
        
        <guid>https://ntutn.top/posts/%E7%BA%BF%E6%80%A7%E8%A1%A8adt%E7%9A%84%E5%AE%9E%E7%8E%B0/</guid>
        <description>归零幻想 https://ntutn.top/posts/%E7%BA%BF%E6%80%A7%E8%A1%A8adt%E7%9A%84%E5%AE%9E%E7%8E%B0/ -&lt;!-- raw HTML omitted --&gt;
&lt;h1 id=&#34;线性表adt的实现&#34;&gt;线性表ADT的实现&lt;/h1&gt;
&lt;p&gt;数据结构平时测试的题目开放了，这次平时测试睡过了，全宿舍都睡过了。现在回头做做题目，还是有坑点的。&lt;/p&gt;
&lt;h2 id=&#34;question&#34;&gt;Question&lt;/h2&gt;
&lt;p&gt;假设线性表ADT的数据元素类型为正整数，采用带头结点的单链式存储结构。线性表ADT实现的大部分代码已经给出，请补充写出类的两个成员函数&lt;code&gt;insert&lt;/code&gt;和&lt;code&gt;reverse&lt;/code&gt;。  注意：&lt;strong&gt;只需提交需要补充的函数代码，其他代码不能自己重写和修改。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;insert&lt;/code&gt;函数：在元素值从小到大有序的线性表中插入一个元素，仍然保持有序。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;reverse&lt;/code&gt;函数：实现线性表元素的倒置，即将线性表中数据元素的顺序反转。&lt;/p&gt;
&lt;p&gt;线性表元素输入时，以 &lt;code&gt;endTag&lt;/code&gt; 作为结束标志。&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;例如输入：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;3 8 7 2 4 9 1 6 5 0
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;则输出：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;9 8 7 6 5 4 3 2 1
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;预置代码如下： （其中/*   */ 部分是要补充的&lt;code&gt;insert&lt;/code&gt;和&lt;code&gt;reverse&lt;/code&gt;函数）&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;#include&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;#include&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;using&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;namespace&lt;/span&gt; std;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; ElemType;  &lt;span style=&#34;color:#228b22&#34;&gt;//数据元素类型
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;List&lt;/span&gt;; &lt;span style=&#34;color:#228b22&#34;&gt;//前视定义,否则友元无法定义
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;//结点类定义
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;LinkNode&lt;/span&gt;
{  &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;friend&lt;/span&gt;  &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;List&lt;/span&gt;; 
   &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;private&lt;/span&gt;: 
     LinkNode *link; 
     ElemType data;  
   &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt;: 
     LinkNode (LinkNode *ptr = &lt;span style=&#34;color:#658b00&#34;&gt;NULL&lt;/span&gt;)    {link=ptr;}
     LinkNode(&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; ElemType &amp;amp; item, LinkNode *ptr = &lt;span style=&#34;color:#658b00&#34;&gt;NULL&lt;/span&gt;){  data=item;link=ptr;} 
     ~LinkNode(){}; 
}; 
&lt;span style=&#34;color:#228b22&#34;&gt;//单链表类定义 
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;List&lt;/span&gt;   
{  &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;private&lt;/span&gt;:    
     LinkNode *first; &lt;span style=&#34;color:#228b22&#34;&gt;//指向链表头结点的指针          
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;   &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt;:
     List (ElemType x) { first = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; LinkNode (x);}   &lt;span style=&#34;color:#228b22&#34;&gt;// 带头结点
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;     ~List (){ MakeEmpty();}         &lt;span style=&#34;color:#228b22&#34;&gt;//析构函数
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;     &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;MakeEmpty&lt;/span&gt; ( );      &lt;span style=&#34;color:#228b22&#34;&gt;//线性表置空    
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;     &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;insert&lt;/span&gt;(ElemType val);   &lt;span style=&#34;color:#228b22&#34;&gt;//在有序线性表中插入元素val
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;     &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;reverse&lt;/span&gt;();   &lt;span style=&#34;color:#228b22&#34;&gt;//线性表的倒置
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;     &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;output&lt;/span&gt;();    &lt;span style=&#34;color:#228b22&#34;&gt;//线性表的输出               
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;}; 
&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;void&lt;/span&gt; List:: MakeEmpty ( )
 { LinkNode *q;
   &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;while&lt;/span&gt; (  first-&amp;gt;link != &lt;span style=&#34;color:#658b00&#34;&gt;NULL&lt;/span&gt; ) 
	{ q = first-&amp;gt;link;  &lt;span style=&#34;color:#228b22&#34;&gt;//指向别摘下结点 
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;      first-&amp;gt;link = q-&amp;gt;link;&lt;span style=&#34;color:#228b22&#34;&gt;//从链中摘下结点
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;      &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;delete&lt;/span&gt; q;        &lt;span style=&#34;color:#228b22&#34;&gt;//释放摘下的结点 
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    }
};	
&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;void&lt;/span&gt; List ::output ( )
{  LinkNode  *p=first-&amp;gt;link; 
   &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;while&lt;/span&gt;(p!=&lt;span style=&#34;color:#658b00&#34;&gt;NULL&lt;/span&gt;)
   { &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt;(p==first-&amp;gt;link) cout&amp;lt;&amp;lt;p-&amp;gt;data;
     &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;else&lt;/span&gt;  cout&amp;lt;&amp;lt;&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34; &amp;#34;&lt;/span&gt;&amp;lt;&amp;lt;p-&amp;gt;data;
     p=p-&amp;gt;link;
   }
   cout&amp;lt;&amp;lt;endl;
}
&lt;span style=&#34;color:#228b22&#34;&gt;/*
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;**************************************************
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;请写出 insert 成员函数
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;**************************************************
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;**************************************************
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;请写出 reverse 成员函数
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;**************************************************
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;*/&lt;/span&gt;
&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt;  &lt;span style=&#34;color:#008b45&#34;&gt;main&lt;/span&gt;()
{   List list(&lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;);
    ElemType endTag=&lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;;
    ElemType val;
    &lt;span style=&#34;color:#228b22&#34;&gt;//下面通过不断读入元素，插入到有序单链表中，建立从小到大的有序单链表
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    cin&amp;gt;&amp;gt;val;
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;while&lt;/span&gt;(val!=endTag) 
     {  list.insert(val);     &lt;span style=&#34;color:#228b22&#34;&gt;//在有序表中插入一个元素
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        cin&amp;gt;&amp;gt;val;  
      }
    list.reverse ();   &lt;span style=&#34;color:#228b22&#34;&gt;//线性表倒置
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    cout&amp;lt;&amp;lt;&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;The result is:&amp;#34;&lt;/span&gt;&amp;lt;&amp;lt;endl;
    list.output ();
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;分析&#34;&gt;分析&lt;/h2&gt;
&lt;p&gt;基础题，注意边界的判断和特例的处理。&lt;/p&gt;
&lt;h2 id=&#34;answer&#34;&gt;Answer&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#228b22&#34;&gt;/*
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;**************************************************
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;请写出 insert 成员函数
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;**************************************************
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;*/&lt;/span&gt;
&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;void&lt;/span&gt; List::insert(ElemType val){
    LinkNode*pNew=&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; LinkNode(val);
    LinkNode*pPointer=first;
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;while&lt;/span&gt;(pPointer-&amp;gt;link!=&lt;span style=&#34;color:#658b00&#34;&gt;NULL&lt;/span&gt;){
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt;(val&amp;lt;pPointer-&amp;gt;link-&amp;gt;data){
            pNew-&amp;gt;link=pPointer-&amp;gt;link;
            pPointer-&amp;gt;link=pNew;
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt;;
        }
        pPointer=pPointer-&amp;gt;link;
    }
    pPointer-&amp;gt;link=pNew;
}
&lt;span style=&#34;color:#228b22&#34;&gt;/*
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;**************************************************
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;请写出 reverse 成员函数
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;**************************************************
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;*/&lt;/span&gt;
&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;void&lt;/span&gt; List::reverse(){
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt;(first-&amp;gt;link==&lt;span style=&#34;color:#658b00&#34;&gt;NULL&lt;/span&gt;||first-&amp;gt;link-&amp;gt;link==&lt;span style=&#34;color:#658b00&#34;&gt;NULL&lt;/span&gt;){
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt;;
    }
    LinkNode*pParent=first-&amp;gt;link;
    LinkNode*pChild=first-&amp;gt;link-&amp;gt;link;
    first-&amp;gt;link-&amp;gt;link=&lt;span style=&#34;color:#658b00&#34;&gt;NULL&lt;/span&gt;;
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;while&lt;/span&gt;(pChild!=&lt;span style=&#34;color:#658b00&#34;&gt;NULL&lt;/span&gt;){
        LinkNode*pTemp=pChild-&amp;gt;link;
        pChild-&amp;gt;link=pParent;
        pParent=pChild;
        pChild=pTemp;
    }
    first-&amp;gt;link=pParent;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;- https://ntutn.top/posts/%E7%BA%BF%E6%80%A7%E8%A1%A8adt%E7%9A%84%E5%AE%9E%E7%8E%B0/ - CC BY-SA 4.0</description>
        </item>
    
    
    
        <item>
        <title>计算机组成原理笔记</title>
        <link>https://ntutn.top/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/</link>
        <pubDate>Mon, 13 May 2019 03:11:37 +0800</pubDate>
        
        <guid>https://ntutn.top/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/</guid>
        <description>归零幻想 https://ntutn.top/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/ -&lt;!-- raw HTML omitted --&gt;
&lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;
&lt;p&gt;计算机组成原理马上就要期中考试了，我也在积极准备复习，顺着课本也做了一波笔记，把每个部分的知识点都整理了一下。没理解的暂时还空着（比如海明校验码），有些整理起来不方便的也暂时空着，回头去查课本吧。&lt;/p&gt;
&lt;p&gt;结课了，顺着课本捋了一遍，做的一些笔记：&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;h1 id=&#34;计算机组成原理&#34;&gt;计算机组成原理&lt;/h1&gt;
&lt;h2 id=&#34;概述-1&#34;&gt;概述&lt;/h2&gt;
&lt;h3 id=&#34;计算机硬件&#34;&gt;计算机硬件&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;采用&lt;strong&gt;存储程序&lt;/strong&gt;工作方式。&lt;/li&gt;
&lt;li&gt;由&lt;strong&gt;运算器&lt;/strong&gt;、&lt;strong&gt;控制器&lt;/strong&gt;、&lt;strong&gt;存储器&lt;/strong&gt;、&lt;strong&gt;输入设备&lt;/strong&gt;、&lt;strong&gt;输出设备&lt;/strong&gt;部件组成。&lt;/li&gt;
&lt;li&gt;存储器：存储数据/指令
控制器：控制指令的自动执行
运算器：加减乘除、逻辑运算
操作人员通过输入输出设备控制计算机。&lt;/li&gt;
&lt;li&gt;计算机内部以&lt;strong&gt;二进制&lt;/strong&gt;表示指令和数据
指令由&lt;strong&gt;操作码&lt;/strong&gt;和&lt;strong&gt;地址码&lt;/strong&gt;组成。
总线：传输信息的介质。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ALU：数据处理部件，执行算数和逻辑运算。&lt;/p&gt;
&lt;h3 id=&#34;计算机软件&#34;&gt;计算机软件&lt;/h3&gt;
&lt;h2 id=&#34;计算机系统层次结构&#34;&gt;计算机系统层次结构&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;应用（问题）        最终用户
算法                程序员
编程（语言）
操作系统/虚拟机
指令集体系结构（ISA）架构师
微体系结构
功能部件/RTL        电子工程师
电路
器件
&lt;/code&gt;&lt;/pre&gt;
&lt;ol&gt;
&lt;li&gt;机器级语言&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;和运行程序的计算机底层结构密切相关。
可读性差，不易于记忆。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;汇编语言&lt;/li&gt;
&lt;li&gt;机器语言&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;高级语言&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;和底层计算机结构关系不大。
可读性相当较好。
大多数程序员使用高级语言编写程序。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;程序设计语言处理系统&#34;&gt;程序设计语言处理系统&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;汇编程序：汇编器，汇编语言》机器语言&lt;/li&gt;
&lt;li&gt;解释程序：解释器，将源程序中的语句按顺序逐条翻译并立即执行。&lt;/li&gt;
&lt;li&gt;编译程序：编译器，高级语言》汇编语言/机器语言。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;计算机系统的不同用户&#34;&gt;计算机系统的不同用户&lt;/h2&gt;
&lt;h3 id=&#34;最终用户&#34;&gt;最终用户&lt;/h3&gt;
&lt;p&gt;使应用程序完成特定任务的用户。&lt;/p&gt;
&lt;p&gt;简单的人机交互界面、安装在计算机中的相关应用程序。&lt;/p&gt;
&lt;h3 id=&#34;系统管理员&#34;&gt;系统管理员&lt;/h3&gt;
&lt;p&gt;利用操作系统等软件提供的功能对系统进行配置管理维护的操作人员。&lt;/p&gt;
&lt;p&gt;部分硬件层面、系统管理层面、相关实用程序和人机交互界面。&lt;/p&gt;
&lt;h3 id=&#34;应用程序员&#34;&gt;应用程序员&lt;/h3&gt;
&lt;p&gt;使用高级语言编制应用软件的程序员。&lt;/p&gt;
&lt;p&gt;硬件、操作系统提供的编程接口、人机交互界面、实用程序、相关的语言程序处理系统。&lt;/p&gt;
&lt;h3 id=&#34;系统程序员&#34;&gt;系统程序员&lt;/h3&gt;
&lt;p&gt;设计和开发系统软件的程序员。&lt;/p&gt;
&lt;p&gt;计算机底层相关硬件和系统结构。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;一个人可以既是最终用户，又是系统管理员、……
ISA处于硬件和软件交界面，是计算机系统核心部分。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;程序开发与执行过程&#34;&gt;程序开发与执行过程&lt;/h2&gt;
&lt;p&gt;对于&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;#include&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;main&lt;/span&gt;(){
    printf(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;Hello World!&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;&lt;/span&gt;);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ol&gt;
&lt;li&gt;通过程序编辑软件得到&lt;code&gt;hello.c&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;将&lt;code&gt;hello.c&lt;/code&gt;预处理、编译、汇编、链接，生成可执行目标程序&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;gcc -o hello hello.c
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;预处理：将以&lt;code&gt;#&lt;/code&gt;开头的命令进行处理
编译：编译得到汇编语言源程序
汇编：得到（二进制）可重定位目标文件
链接：多个可重定位目标文件和标准库函数合并为一个可执行目标文件。&lt;/p&gt;
&lt;p&gt;启动和执行依靠操作系统的支持。&lt;/p&gt;
&lt;h3 id=&#34;程序与指令之间的关系&#34;&gt;程序与指令之间的关系&lt;/h3&gt;
&lt;p&gt;可执行程序目标文件包括机器代码段，执行实质是机器代码段执行。机器代码段由一条条指令构成。&lt;/p&gt;
&lt;p&gt;指令是一个0/1序列，用来指示CPU完成一个特定的原子操作。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;操作码 指令操作类型&lt;/li&gt;
&lt;li&gt;地址码 指令操作数的地址&lt;/li&gt;
&lt;li&gt;立即数 具体一个数/偏移地址&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;指令的执行过程&#34;&gt;指令的执行过程&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;根据PC取指令到IR&lt;/li&gt;
&lt;li&gt;指令译码并送出控制信号&lt;/li&gt;
&lt;li&gt;取操作数&lt;/li&gt;
&lt;li&gt;指令执行&lt;/li&gt;
&lt;li&gt;回写结果&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;计算机系统性能评价&#34;&gt;计算机系统性能评价&lt;/h2&gt;
&lt;p&gt;用户感觉到的时间分为CPU时间和其他时间。&lt;/p&gt;
&lt;p&gt;CPU时间分为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用户CPU时间&lt;/li&gt;
&lt;li&gt;系统CPU时间&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;时钟周期：CPU的主脉冲信号宽度。&lt;/p&gt;
&lt;p&gt;时钟频率：CPU的主脉冲信号的频率，时钟周期的倒数。&lt;/p&gt;
&lt;p&gt;CPI：执行一条指令所用的时钟周期数&lt;/p&gt;
&lt;p&gt;$$CPU执行时间=\frac{程序所含时钟周期数}{时钟频率}=程序所含时钟周期数×时钟周期$$&lt;/p&gt;
&lt;p&gt;$$程序总时钟周期数=程序所含指令条数×CPI$$&lt;/p&gt;
&lt;p&gt;n种不同指令，第i条指令数和CPI已知综合CPI：&lt;/p&gt;
&lt;p&gt;$$程序总时钟周期数=\sum_{i=1}^n(CPI_i\times F_i)$$&lt;/p&gt;
&lt;p&gt;所以：
$$CPU执行时间=CPI\times 程序总指令条数\times 时钟周期$$&lt;/p&gt;
&lt;h2 id=&#34;用指令执行速度进行性能评估&#34;&gt;用指令执行速度进行性能评估&lt;/h2&gt;
&lt;p&gt;MIPS：指令速度的单位，每秒钟执行多少百万条指令。&lt;/p&gt;
&lt;p&gt;相对MIPS：被测机型速度是相对参考机型的多少倍。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;不同机器用MIPS进行性能比较是不准确/不客观的：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;M1上一条指令的功能，M2上要多条指令来完成&lt;/li&gt;
&lt;li&gt;不同机器的CPI和时钟周期不同，执行一条指令所用的时间也不同。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;数据的机器级表示&#34;&gt;数据的机器级表示&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;二进制八进制十六进制十进制写法标记（开头）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;十进制非零开头&lt;/li&gt;
&lt;li&gt;二进制0b开头&lt;/li&gt;
&lt;li&gt;八进制0开头&lt;/li&gt;
&lt;li&gt;十六进制0x开头&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;进制简化符号（结尾）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;二进制 B（Binary）&lt;/li&gt;
&lt;li&gt;八进制 （Octal）&lt;/li&gt;
&lt;li&gt;十进制 D（Decimal）&lt;/li&gt;
&lt;li&gt;十六进制 H（Hexadecimal）&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;数制和编码&#34;&gt;数制和编码&lt;/h3&gt;
&lt;p&gt;信息使用二进制编码原因：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;二进制只有两种状态，制作有两种稳态的物理器件很方便。&lt;/li&gt;
&lt;li&gt;编码和运算规则简单，可以开关电路实现，简单易行。&lt;/li&gt;
&lt;li&gt;1、0对应逻辑真假，为逻辑运算和逻辑判断提供便利条件，可以用逻辑门电路实现算术运算。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;进位计数制&#34;&gt;进位计数制&lt;/h3&gt;
&lt;p&gt;（略）&lt;/p&gt;
&lt;h3 id=&#34;定点与浮点表示&#34;&gt;定点与浮点表示&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;定点 小数点固定&lt;/li&gt;
&lt;li&gt;浮点 尾数决定表示精度，指数决定表示范围&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;定点数的编码表示&#34;&gt;定点数的编码表示&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;真值：现实世界带有正负号的数。&lt;/li&gt;
&lt;li&gt;原码：符号位后跟数值位。&lt;/li&gt;
&lt;li&gt;反码：正数不变，数（除符号位）按位取反&lt;/li&gt;
&lt;li&gt;补码：正数不变，负数反码加一&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;已知反码/补码求原码，同上述操作。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;移码：每个数加一个偏置常数&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;若将移码第一位看做符号位，则同一个真值的移码和补码只有符号位不同&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;整数的表示&#34;&gt;整数的表示&lt;/h2&gt;
&lt;h3 id=&#34;无符号整数的表示&#34;&gt;无符号整数的表示&lt;/h3&gt;
&lt;p&gt;无符号位，略&lt;/p&gt;
&lt;h3 id=&#34;带符号数的表示&#34;&gt;带符号数的表示&lt;/h3&gt;
&lt;p&gt;常用补码表示。优点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;0的表示形式唯一&lt;/li&gt;
&lt;li&gt;可以用加法实现减法运算，符号位可以参与运算&lt;/li&gt;
&lt;li&gt;与原码和反码相比，多一个最小负数&lt;/li&gt;
&lt;li&gt;不需要通过循环进位调整结果&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;c语言中的整数类型&#34;&gt;C语言中的整数类型&lt;/h3&gt;
&lt;p&gt;（略）&lt;/p&gt;
&lt;h2 id=&#34;实数的表示&#34;&gt;实数的表示&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;计算机中用浮点数表示实数&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;浮点数的表示格式&#34;&gt;浮点数的表示格式&lt;/h3&gt;
&lt;p&gt;（无）&lt;/p&gt;
&lt;h3 id=&#34;浮点数的规格化&#34;&gt;浮点数的规格化&lt;/h3&gt;
&lt;p&gt;规格化数：尾数最高位具有非零数字&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;右归：有效数字在小数点之前，需右归。尾数每右移一位，阶码+1。&lt;/li&gt;
&lt;li&gt;左归：……&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;ieee754浮点数标准&#34;&gt;IEEE754浮点数标准&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;32位单精度 1符号 8阶码 32尾数&lt;/li&gt;
&lt;li&gt;64位双精度 1符号 11阶码 52尾数&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;尾数用原码，1在小数点之前（省略第一个1）&lt;/p&gt;
&lt;p&gt;指数用移码&lt;/p&gt;
&lt;h3 id=&#34;c语言中的浮点数类型&#34;&gt;C语言中的浮点数类型&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;转换&lt;/th&gt;
&lt;th&gt;int&lt;/th&gt;
&lt;th&gt;float&lt;/th&gt;
&lt;th&gt;double&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;int&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;可能有数据被舍入&lt;/td&gt;
&lt;td&gt;保留精确值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;float&lt;/td&gt;
&lt;td&gt;可能向0方向截断，可能溢出&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;保留精确值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;double&lt;/td&gt;
&lt;td&gt;可能向0方向截断，可能溢出&lt;/td&gt;
&lt;td&gt;可能有数据被舍入，可能溢出&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;十进制数的表示&#34;&gt;十进制数的表示&lt;/h2&gt;
&lt;h3 id=&#34;ascii字符表示&#34;&gt;ASCII字符表示&lt;/h3&gt;
&lt;p&gt;将数看做字符串，方便输入输出，但运算不方便。&lt;/p&gt;
&lt;h3 id=&#34;用bcd码表示&#34;&gt;用BCD码表示&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;有权BCD码&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;8421&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;无权BCD码&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;余三码、格雷码&lt;/p&gt;
&lt;h2 id=&#34;非数值数据的编码表示&#34;&gt;非数值数据的编码表示&lt;/h2&gt;
&lt;h3 id=&#34;逻辑值&#34;&gt;逻辑值&lt;/h3&gt;
&lt;p&gt;0 1&lt;/p&gt;
&lt;h2 id=&#34;数据的宽度和存储&#34;&gt;数据的宽度和存储&lt;/h2&gt;
&lt;h3 id=&#34;数据的宽度和单位&#34;&gt;数据的宽度和单位&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;字 用来处理信息的单位，用来度量各种数据类型的宽度&lt;/li&gt;
&lt;li&gt;字长 表示进行数据运算、存储、传送的各种部件的宽度，反映计算机处理信息的能力&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;数据的存储和排列顺序&#34;&gt;数据的存储和排列顺序&lt;/h3&gt;
&lt;p&gt;i=01234567H&lt;/p&gt;
&lt;p&gt;&amp;amp;i=0800H&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;地址&lt;/th&gt;
&lt;th&gt;0800H&lt;/th&gt;
&lt;th&gt;0801H&lt;/th&gt;
&lt;th&gt;0802H&lt;/th&gt;
&lt;th&gt;0803H&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;大端方式&lt;/td&gt;
&lt;td&gt;01H&lt;/td&gt;
&lt;td&gt;23H&lt;/td&gt;
&lt;td&gt;45H&lt;/td&gt;
&lt;td&gt;67H&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;小端方式&lt;/td&gt;
&lt;td&gt;67H&lt;/td&gt;
&lt;td&gt;45H&lt;/td&gt;
&lt;td&gt;23H&lt;/td&gt;
&lt;td&gt;01H&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;数据校验码&#34;&gt;数据校验码&lt;/h2&gt;
&lt;h3 id=&#34;奇偶校验码&#34;&gt;奇偶校验码&lt;/h3&gt;
&lt;p&gt;不能确定错误位置，没有纠错能力。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;奇校验位 有奇数个1时P取0&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;$$B=b_{n-1}\oplus b_{n-2}\oplus \ldots \oplus b_1 \oplus b_0 \oplus 1$$&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;偶校验位&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;$$B=b_{n-1}\oplus b_{n-2}\oplus \ldots \oplus b_1 \oplus b_0$$&lt;/p&gt;
&lt;h3 id=&#34;海明校验码&#34;&gt;海明校验码&lt;/h3&gt;
&lt;p&gt;（待补全）&lt;/p&gt;
&lt;h3 id=&#34;循环冗余校验码&#34;&gt;循环冗余校验码&lt;/h3&gt;
&lt;p&gt;（待补全）&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;高级语言和机器指令中的运算&#34;&gt;高级语言和机器指令中的运算&lt;/h2&gt;
&lt;h3 id=&#34;c程序中涉及的运算&#34;&gt;C程序中涉及的运算&lt;/h3&gt;
&lt;h3 id=&#34;mips指令中涉及的运算&#34;&gt;MIPS指令中涉及的运算&lt;/h3&gt;
&lt;h2 id=&#34;基本运算部件&#34;&gt;基本运算部件&lt;/h2&gt;
&lt;h3 id=&#34;串行进位加法器&#34;&gt;串行进位加法器&lt;/h3&gt;
&lt;h3 id=&#34;并行进位加法器&#34;&gt;并行进位加法器&lt;/h3&gt;
&lt;h3 id=&#34;带标志加法器&#34;&gt;带标志加法器&lt;/h3&gt;
&lt;h3 id=&#34;算数逻辑部件&#34;&gt;算数逻辑部件&lt;/h3&gt;
&lt;h2 id=&#34;定点数运算&#34;&gt;定点数运算&lt;/h2&gt;
&lt;h3 id=&#34;补码加减运算&#34;&gt;补码加减运算&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;Latex公式无法显示，反而导致后面排版错位……
$$
\begin{cases}
[x+y]_补=[x]_补+[y]_补(mod 2^n)\\\\
[x-y]_补=[x]_补+[-y]_补(mod 2^n)
\end{cases}
$$
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;    CF—进位标志，加法时的最高位（D7或D15）产生进位或减法时最高位出现借位，则CF=1，否则CF=0；
    AF—辅助进位标志，供BCD码使用。当D3位出现进位或借位时AF=1，否则AF=0；
    OF—溢出标志，带符号数进行算术运算时，其结果超出了8位或16位的表示范围，产生溢出，则OF=1，否则OF=0；
    ZF—零标志，运算结果各位都为零，则ZF=1，否则ZF=0；
    SF—符号标志，运算结果为负数时，即运算结果的最高位为1，则SF=1，否则SF=0；
    PF—奇偶标志，反映操作结果中“1”的个数的情况，若有偶数个“1”，则PF=1，否则PF=0。
3个控制标志位
   DF—方向标志，用来控制数据串操作指令的步进方向；
    当设置DF=1时，将以递减顺序对数据串中的数据进行处理。当设置DF=0时，递增。
   IF—中断允许标志，当设置IF=1，开中断，CPU可响应可屏蔽中断请求；当设置IF=0时，关中断，CPU不响应可屏蔽中断请求。 
   TF—陷阱标志，为程序调试而设的。当设置TF=1，CPU处于单步执行指令的方式；当设置TF=0时，CPU正常执行程序。
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;原码加减运算&#34;&gt;原码加减运算&lt;/h3&gt;
&lt;h3 id=&#34;移码加减运算&#34;&gt;移码加减运算&lt;/h3&gt;
&lt;h3 id=&#34;原码乘法运算&#34;&gt;原码乘法运算&lt;/h3&gt;
&lt;h4 id=&#34;原码一位乘&#34;&gt;原码一位乘&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;确定乘机的符号位&lt;/li&gt;
&lt;li&gt;计算乘积的数值位&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;自行查书看样例掌握无符号数相乘运算&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;补码一位乘&#34;&gt;补码一位乘&lt;/h4&gt;
&lt;h4 id=&#34;原码一位除&#34;&gt;原码一位除&lt;/h4&gt;
&lt;h4 id=&#34;补码一位除&#34;&gt;补码一位除&lt;/h4&gt;
&lt;h2 id=&#34;浮点数运算&#34;&gt;浮点数运算&lt;/h2&gt;
&lt;h3 id=&#34;浮点数加减运算&#34;&gt;浮点数加减运算&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;对阶&lt;/li&gt;
&lt;li&gt;尾数加减&lt;/li&gt;
&lt;li&gt;规格化&lt;/li&gt;
&lt;li&gt;舍入&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;运算部件的组成&#34;&gt;运算部件的组成&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;所谓运算部件，通常是指ALU、移位器、存放临时数据的寄存器，加上用于数据选择的多路选择器和实现数据传送的总线等构成的一个运算数据通路。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;指令系统&#34;&gt;指令系统&lt;/h1&gt;
&lt;h2 id=&#34;指令格式设计&#34;&gt;指令格式设计&lt;/h2&gt;
&lt;h3 id=&#34;指令地址码的个数&#34;&gt;指令地址码的个数&lt;/h3&gt;
&lt;p&gt;每条指令必须包含：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;操作码 指定操作类型&lt;/li&gt;
&lt;li&gt;源操作数或地址&lt;/li&gt;
&lt;li&gt;结果的地址&lt;/li&gt;
&lt;li&gt;下一条指令地址&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;指令格式设计原则&#34;&gt;指令格式设计原则&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;指令应尽量短 减少空间开销&lt;/li&gt;
&lt;li&gt;要有足够的操作码位数 向后兼容，预留&lt;/li&gt;
&lt;li&gt;操作码的编码必须有唯一解释&lt;/li&gt;
&lt;li&gt;指令长度应是字节的整数倍 便于指令的读取和指令地址的计算&lt;/li&gt;
&lt;li&gt;合理选择地址字段的个数 空间开销与事件开销权衡&lt;/li&gt;
&lt;li&gt;指令应尽量规整 简化硬件的设计&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;指令系统的设计&#34;&gt;指令系统的设计&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;完整性或完备性 较复杂的功能可以通过伪指令实现&lt;/li&gt;
&lt;li&gt;兼容性 高档机的指令系统应兼容以前低端机的指令系统，给软件资源重复利用带来方便&lt;/li&gt;
&lt;li&gt;均匀性 运算系统应能应对多种类型的数据进行处理&lt;/li&gt;
&lt;li&gt;可扩充性 操作码预留编码空间&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;基本设计问题&#34;&gt;基本设计问题&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;操作码的个数、种类、复杂度如何选择？&lt;/li&gt;
&lt;li&gt;运算指令能对哪几种数据类型进行操作？&lt;/li&gt;
&lt;li&gt;采用什么样的指令格式？&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;规整型 定长指令字定长操作码，减少时间开销，增加空间开销&lt;/li&gt;
&lt;li&gt;紧凑型&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;通用寄存器的个数、功能、长度如何规定？&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;增加通用寄存器个数可以减少指令执行访存次数，但会增加寄存器存取延迟，增大CPU成本&lt;/p&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;如何设计寻址方式的种类和编码已经各种寻址方式下有效地址如何计算？&lt;/li&gt;
&lt;li&gt;下一条指令的地址如何确定？&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;一般通过一个专门的寄存器，叫做 &lt;strong&gt;程序计数器（PC）&lt;/strong&gt; 或 &lt;strong&gt;指令指针（IP）&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;操作数类型&#34;&gt;操作数类型&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;指针或地址&lt;/li&gt;
&lt;li&gt;数值数据 带符号整数、浮点数&lt;/li&gt;
&lt;li&gt;位、位串、字符、字符串&lt;/li&gt;
&lt;li&gt;布尔&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;寻址方式&#34;&gt;寻址方式&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;立即寻址 指令中直接给出操作数本身&lt;/li&gt;
&lt;li&gt;直接寻址 指令中给出操作数的地址&lt;/li&gt;
&lt;li&gt;间接寻址 指令中给出操作数的地址的地址……&lt;/li&gt;
&lt;li&gt;寄存器寻址 指令中给出寄存器的编号&lt;/li&gt;
&lt;li&gt;寄存器间接寻址 寄存器中存的是操作数的地址&lt;/li&gt;
&lt;li&gt;变址寻址 指令中给出基准地址，变址寄存器给出偏移量，相加得到实际地址&lt;/li&gt;
&lt;li&gt;相对寻址 指令中给出偏移量，基准地址由PC给出&lt;/li&gt;
&lt;li&gt;基址寻址 指令中给出偏移量，基准地址由基址寄存器给出&lt;/li&gt;
&lt;li&gt;其他寻址方式&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;基址寻址、变址寻址、相对寻址&lt;/strong&gt;统称为 &lt;strong&gt;偏移寻址&lt;/strong&gt; 。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;操作数类型-1&#34;&gt;操作数类型&lt;/h3&gt;
&lt;h3 id=&#34;操作码编码&#34;&gt;操作码编码&lt;/h3&gt;
&lt;h3 id=&#34;标志信息的生成和使用&#34;&gt;标志信息的生成和使用&lt;/h3&gt;
&lt;h3 id=&#34;指令系统设计风格&#34;&gt;指令系统设计风格&lt;/h3&gt;
&lt;h4 id=&#34;按操作数位置指定风格来分&#34;&gt;按操作数位置指定风格来分&lt;/h4&gt;
&lt;h4 id=&#34;按指令格式的复杂度来分&#34;&gt;按指令格式的复杂度来分&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;CISC指令系统&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;指令系统复杂&lt;/li&gt;
&lt;li&gt;指令周期长&lt;/li&gt;
&lt;li&gt;指令周期差距大&lt;/li&gt;
&lt;li&gt;采用微程序控制&lt;/li&gt;
&lt;li&gt;难以进行编译优化&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;RISC指令系统&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;指令数目少&lt;/li&gt;
&lt;li&gt;指令格式规整&lt;/li&gt;
&lt;li&gt;采用&lt;code&gt;Load/Store&lt;/code&gt;型指令设计风格&lt;/li&gt;
&lt;li&gt;采用流水线方式执行指令&lt;/li&gt;
&lt;li&gt;采用大量寄存器&lt;/li&gt;
&lt;li&gt;采用硬连线控制器&lt;/li&gt;
&lt;li&gt;采用优化的编译系统&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;指令系统实例&#34;&gt;指令系统实例&lt;/h2&gt;
&lt;h2 id=&#34;程序的机器级表示&#34;&gt;程序的机器级表示&lt;/h2&gt;
&lt;h1 id=&#34;中央处理器&#34;&gt;中央处理器&lt;/h1&gt;
&lt;h2 id=&#34;cpu概述&#34;&gt;CPU概述&lt;/h2&gt;
&lt;h3 id=&#34;指令执行过程&#34;&gt;指令执行过程&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;取指令并计算下一条指令地址&lt;/li&gt;
&lt;li&gt;对指令操作码译码&lt;/li&gt;
&lt;li&gt;计算源操作数地址并取源操作数&lt;/li&gt;
&lt;li&gt;数据操作&lt;/li&gt;
&lt;li&gt;目的操作数地址计算并存结果&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;cpu的基本功能和基本组成&#34;&gt;CPU的基本功能和基本组成&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;程序计数器PC 用来存指令的地址&lt;/li&gt;
&lt;li&gt;指令寄存器IR 用于存现行指令‘&lt;/li&gt;
&lt;li&gt;指令译码器&lt;/li&gt;
&lt;li&gt;脉冲源及启停控制线路&lt;/li&gt;
&lt;li&gt;时序信号产生部件&lt;/li&gt;
&lt;li&gt;操作控制信号形成部件&lt;/li&gt;
&lt;li&gt;总线控制逻辑&lt;/li&gt;
&lt;li&gt;中断机构&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;数据通路的基本结构&#34;&gt;数据通路的基本结构&lt;/h3&gt;
&lt;h2 id=&#34;单周期处理器设计&#34;&gt;单周期处理器设计&lt;/h2&gt;
&lt;h3 id=&#34;指令功能的描述&#34;&gt;指令功能的描述&lt;/h3&gt;
&lt;h3 id=&#34;数据通路的设计&#34;&gt;数据通路的设计&lt;/h3&gt;
&lt;h3 id=&#34;控制逻辑单元的设计&#34;&gt;控制逻辑单元的设计&lt;/h3&gt;
&lt;h3 id=&#34;时钟周期的确定&#34;&gt;时钟周期的确定&lt;/h3&gt;
&lt;h2 id=&#34;多周期处理器的设计&#34;&gt;多周期处理器的设计&lt;/h2&gt;
&lt;h2 id=&#34;微程序控制器设计&#34;&gt;微程序控制器设计&lt;/h2&gt;
&lt;p&gt;硬连线控制器速度快，适合简单或规整的指令系统。对于复杂指令系统或其中的复杂指令，大多采用微程序方式设计控制器。&lt;/p&gt;
&lt;h3 id=&#34;微程序控制器的结构&#34;&gt;微程序控制器的结构&lt;/h3&gt;
&lt;h2 id=&#34;异常和中断处理&#34;&gt;异常和中断处理&lt;/h2&gt;
&lt;h3 id=&#34;基本概念&#34;&gt;基本概念&lt;/h3&gt;
&lt;p&gt;在程序正常执行过程中，CPU会遇到一些特殊情况而无法继续执行。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;内部异常 处理器内部异常引起的意外事件&lt;/li&gt;
&lt;li&gt;外部中断 外设完成任务或完成某些特殊事件，发中断事件，等待处理。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;指令流水线&#34;&gt;指令流水线&lt;/h1&gt;
&lt;h2 id=&#34;流水线概述&#34;&gt;流水线概述&lt;/h2&gt;
&lt;h3 id=&#34;流水线的执行效率&#34;&gt;流水线的执行效率&lt;/h3&gt;
&lt;h3 id=&#34;适合流水线的指令集特征&#34;&gt;适合流水线的指令集特征&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;指令长度尽量一致&lt;/li&gt;
&lt;li&gt;指令格式尽量规整，尽量保持源寄存器的位置相同&lt;/li&gt;
&lt;li&gt;采用&lt;code&gt;Load/Store&lt;/code&gt;型指令风格&lt;/li&gt;
&lt;li&gt;数据和指令在存储器中“对齐”存放&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;流水线处理器的实现&#34;&gt;流水线处理器的实现&lt;/h2&gt;
&lt;h3 id=&#34;每条指令的流水段的分析&#34;&gt;每条指令的流水段的分析&lt;/h3&gt;
&lt;h3 id=&#34;流水线数据通路的设计&#34;&gt;流水线数据通路的设计&lt;/h3&gt;
&lt;h3 id=&#34;流水线控制器的设计&#34;&gt;流水线控制器的设计&lt;/h3&gt;
&lt;h2 id=&#34;流水线冒险及处理&#34;&gt;流水线冒险及处理&lt;/h2&gt;
&lt;h3 id=&#34;结构冒险&#34;&gt;结构冒险&lt;/h3&gt;
&lt;p&gt;也称硬件资源冲突，同一部件被不同指令同时使用。&lt;/p&gt;
&lt;h3 id=&#34;数据冒险&#34;&gt;数据冒险&lt;/h3&gt;
&lt;p&gt;后一指令要用到前面指令的结果，而结果还没产生。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;插入空操作&lt;/li&gt;
&lt;li&gt;插入气泡 阻塞&lt;/li&gt;
&lt;li&gt;使用转发技术 将中间数据之间转发到ALU的输入端&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;控制冒险&#34;&gt;控制冒险&lt;/h3&gt;
&lt;h2 id=&#34;高级流水线技术&#34;&gt;高级流水线技术&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;超流水线技术
增加流水线级数使更多的指令同时在流水线中重叠执行。&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;流水线的级数越多，用于流水段寄存器的开销越大，因而流水线级数是有限制的，不可能无限增加。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;多发射流水线技术
同时启动多条指令独立运行提高指令并行性。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;指令打包 将并行处理的多条指令同时发送到发射槽 推测技术&lt;/li&gt;
&lt;li&gt;冒险处理&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;存储器分层体系结构&#34;&gt;存储器分层体系结构&lt;/h1&gt;
&lt;h2 id=&#34;存储器概述&#34;&gt;存储器概述&lt;/h2&gt;
&lt;h3 id=&#34;存储器的分类&#34;&gt;存储器的分类&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;按存储原件分类&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;半导体存储器&lt;/li&gt;
&lt;li&gt;磁表面存储器&lt;/li&gt;
&lt;li&gt;光盘存储器&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;按存取方式分类&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;随机存取存储器 按地址访问存储单元&lt;/li&gt;
&lt;li&gt;顺序存取存储器 信息按顺序存入和读出 存储容量大，存取速度慢&lt;/li&gt;
&lt;li&gt;直接存取存储器 兼有随机访问和顺序存储的特点 磁盘&lt;/li&gt;
&lt;li&gt;相联存储器&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;按信息的可更改性分类&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;读写存储器&lt;/li&gt;
&lt;li&gt;只读存储器&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;按断电后信息的可保存程度分类&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;非易失性存储器&lt;/li&gt;
&lt;li&gt;易失性存储器&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;按功能分类&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;高速缓冲存储器 静态RAM芯片&lt;/li&gt;
&lt;li&gt;主存储器 &lt;strong&gt;核心存储器&lt;/strong&gt; MOS管半导体存储器&lt;/li&gt;
&lt;li&gt;辅助存储器 磁盘存储器&lt;/li&gt;
&lt;li&gt;海量后备存储器 容量大 速度慢&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;辅存和海量后备存储器统称为 &lt;em&gt;外部存储器&lt;/em&gt; ，简称 &lt;em&gt;外存&lt;/em&gt; 。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;主存储器的组成和基本操作&#34;&gt;主存储器的组成和基本操作&lt;/h3&gt;
&lt;h3 id=&#34;存储器的主要性能指标&#34;&gt;存储器的主要性能指标&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;容量&lt;/li&gt;
&lt;li&gt;价格&lt;/li&gt;
&lt;li&gt;速度&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;访问时间用读出时间T_A和写入时间T_W来描述&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;接到命令开始到信息被送到数据线上的时间&lt;/li&gt;
&lt;li&gt;接到命令到信息写入存储器的时间&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;存储周期（T_M）：一次读写操作需要的全部时间，存储器进行连续读写操作的最短时间间隔。&lt;/p&gt;
&lt;h3 id=&#34;存储器的层次化结构&#34;&gt;存储器的层次化结构&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;典型存取时间&lt;/th&gt;
&lt;th&gt;存储器&lt;/th&gt;
&lt;th&gt;典型容量&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1ns&lt;/td&gt;
&lt;td&gt;寄存器&lt;/td&gt;
&lt;td&gt;&amp;lt;1KB&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2ns&lt;/td&gt;
&lt;td&gt;高速缓存（cache）&lt;/td&gt;
&lt;td&gt;4MB&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;10ns&lt;/td&gt;
&lt;td&gt;主存储器（RAM和ROM）&lt;/td&gt;
&lt;td&gt;500MB~4GB&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;10ms&lt;/td&gt;
&lt;td&gt;辅助存储器（硬盘）&lt;/td&gt;
&lt;td&gt;40~500G&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;10s&lt;/td&gt;
&lt;td&gt;海量后备存储器（磁带库、光盘等）&lt;/td&gt;
&lt;td&gt;10~100TB&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;半导体随机存取存储器&#34;&gt;半导体随机存取存储器&lt;/h2&gt;
&lt;h3 id=&#34;基本存储原件&#34;&gt;基本存储原件&lt;/h3&gt;
&lt;p&gt;用来存储一位二进制信息，是组成存储器的最基本电路。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;六管静态MOS管存储元件&lt;/li&gt;
&lt;li&gt;单管动态MOS管存储元件 降低了功耗&lt;/li&gt;
&lt;li&gt;静态存储元件和动态存储元件的比较&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;SRAM存储元件所用MOS管多，占硅片面积大，功耗大，集成度低&lt;/li&gt;
&lt;li&gt;DRAM存储元件MOS管少，占硅片面积小，功耗小，集成度更高，但因电容存储电荷，有漏电现象，必须定时刷新。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;sram芯片和dram芯片&#34;&gt;SRAM芯片和DRAM芯片&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;存储器芯片的内部结构&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;存储体&lt;/li&gt;
&lt;li&gt;地址译码器&lt;/li&gt;
&lt;li&gt;驱动器&lt;/li&gt;
&lt;li&gt;I/O控制电路 放大信息的作用&lt;/li&gt;
&lt;li&gt;片选控制信号&lt;/li&gt;
&lt;li&gt;读写控制信号&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;DRAM芯片的刷新&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;集中刷新 时间较长，影响系统的执行效率&lt;/li&gt;
&lt;li&gt;分散刷新 不存在死时间区，但每个存储时间周期被加成&lt;/li&gt;
&lt;li&gt;异步刷新&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;DRAM芯片读写周期&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;sdram芯片技术&#34;&gt;SDRAM芯片技术&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;SDRAM&lt;/code&gt;芯片技术
每一步操作都在CLK的控制下，支持 &lt;strong&gt;突发&lt;/strong&gt; 传输方式。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;DDR SDRAM&lt;/code&gt;芯片技术&lt;/li&gt;
&lt;li&gt;&lt;code&gt;DDR2 SDRAM&lt;/code&gt;芯片技术&lt;/li&gt;
&lt;li&gt;&lt;code&gt;DDR3 SDRAM&lt;/code&gt;芯片技术&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;存储器芯片的扩展及其与cpu的连接&#34;&gt;存储器芯片的扩展及其与CPU的连接&lt;/h2&gt;
&lt;h3 id=&#34;内存条和内存条插槽&#34;&gt;内存条和内存条插槽&lt;/h3&gt;
&lt;h3 id=&#34;存储器芯片的扩展&#34;&gt;存储器芯片的扩展&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;位扩展&lt;/li&gt;
&lt;li&gt;字扩展 容量扩充，位数不变&lt;/li&gt;
&lt;li&gt;字、位同时扩展&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;半导体只读存储器和flash存储器&#34;&gt;半导体只读存储器和Flash存储器&lt;/h2&gt;
&lt;h3 id=&#34;半导体只读存储器&#34;&gt;半导体只读存储器&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;掩膜只读存储器&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;双极型&lt;/li&gt;
&lt;li&gt;MOS型&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;内容固定，可靠性高，但灵活性差，生产周期长，用户和厂家依赖性大，只适合定型批量生产&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;可编程只读存储器&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;熔丝型&lt;/li&gt;
&lt;li&gt;反向二极管型&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;写入不可逆&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;可擦除可编程只读存储器&lt;/li&gt;
&lt;li&gt;电擦除电改写只读存储器&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;半导体flash存储器&#34;&gt;半导体Flash存储器&lt;/h3&gt;
&lt;p&gt;闪存，高密度非易失型读写存储器。功耗低，集成度高，不需要后备电源。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Flash存储元&lt;/li&gt;
&lt;li&gt;Flash存储器的基本操作&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;编程&lt;/li&gt;
&lt;li&gt;擦除&lt;/li&gt;
&lt;li&gt;读取&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;并行存储器结构技术&#34;&gt;并行存储器结构技术&lt;/h2&gt;
&lt;h3 id=&#34;双口存储器&#34;&gt;双口存储器&lt;/h3&gt;
&lt;p&gt;两组独立的读写控制电路和两个独立的读写端口。&lt;/p&gt;
&lt;h3 id=&#34;多模块存储器&#34;&gt;多模块存储器&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;连续编址方式&lt;/li&gt;
&lt;li&gt;交叉编址方式&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;高速缓冲存储器&#34;&gt;高速缓冲存储器&lt;/h2&gt;
&lt;h3 id=&#34;程序访问的局限性&#34;&gt;程序访问的局限性&lt;/h3&gt;
&lt;p&gt;较短时间间隔内，程序产生的地址往往集中在存储器的很小的一个范围。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;时间局限性 被访问的某存储单元在较短时间内可能又被访问&lt;/li&gt;
&lt;li&gt;空间局限性 被访问的某个存储单元在一个较短的时间间隔内很可能也被访问&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;cache的基本工作原理&#34;&gt;cache的基本工作原理&lt;/h3&gt;
&lt;h3 id=&#34;cache行和主内存块之间的映射关系&#34;&gt;cache行和主内存块之间的映射关系&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;直接映射&lt;/li&gt;
&lt;li&gt;全相联映射&lt;/li&gt;
&lt;li&gt;组相联映射&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;cache中主存块的替换算法&#34;&gt;cache中主存块的替换算法&lt;/h3&gt;
&lt;h3 id=&#34;cache的一致性问题&#34;&gt;cache的一致性问题&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;全写法&lt;/li&gt;
&lt;li&gt;回写法&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;虚拟存储器&#34;&gt;虚拟存储器&lt;/h2&gt;
&lt;h3 id=&#34;虚拟地址空间&#34;&gt;虚拟地址空间&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;简化存储&lt;/li&gt;
&lt;li&gt;使主存空间有效利用&lt;/li&gt;
&lt;li&gt;保护各自进程不被其他进程破坏&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;虚拟存储器的实现&#34;&gt;虚拟存储器的实现&lt;/h3&gt;
&lt;h1 id=&#34;互联及输入输出组织&#34;&gt;互联及输入输出组织&lt;/h1&gt;
&lt;h2 id=&#34;外部设备的分类和特点&#34;&gt;外部设备的分类和特点&lt;/h2&gt;
&lt;h3 id=&#34;外设的分类&#34;&gt;外设的分类&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;按信息的传输方向分类&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;输入设备&lt;/li&gt;
&lt;li&gt;输出设备&lt;/li&gt;
&lt;li&gt;输入输出设备&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;按功能分类&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;人机交互设备&lt;/li&gt;
&lt;li&gt;存储设备&lt;/li&gt;
&lt;li&gt;机-机通信设备&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;外设的特点&#34;&gt;外设的特点&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;异步性&lt;/li&gt;
&lt;li&gt;实时性&lt;/li&gt;
&lt;li&gt;多样性&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;输入设备和输出设备&#34;&gt;输入设备和输出设备&lt;/h2&gt;
&lt;h2 id=&#34;外部存储设备&#34;&gt;外部存储设备&lt;/h2&gt;
&lt;h3 id=&#34;磁表面存储器的原理&#34;&gt;磁表面存储器的原理&lt;/h3&gt;
&lt;h3 id=&#34;硬盘存储器&#34;&gt;硬盘存储器&lt;/h3&gt;
&lt;h3 id=&#34;冗余磁盘阵列&#34;&gt;冗余磁盘阵列&lt;/h3&gt;
&lt;h3 id=&#34;u盘和固态硬盘&#34;&gt;U盘和固态硬盘&lt;/h3&gt;
&lt;h2 id=&#34;外设与cpu主存的互联&#34;&gt;外设与CPU、主存的互联&lt;/h2&gt;
&lt;h3 id=&#34;总线概述&#34;&gt;总线概述&lt;/h3&gt;
&lt;p&gt;计算机内数据传输的公共路径，用于实现两个或两个以上部件之间的信息交换。&lt;/p&gt;
&lt;p&gt;通常由一组数据线、一组控制线和一组地址线组成。有些总线没有单独的地址线，地址信息通过数据线来传送，这种行为称为数据线和地址线复用。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;总线宽度 总线中数据线的条数&lt;/li&gt;
&lt;li&gt;总线工作频率&lt;/li&gt;
&lt;li&gt;总线带宽 单位时间最多可传递的数据量
$B=W*F/N$&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;W 总线宽度&lt;/li&gt;
&lt;li&gt;F 总线的时钟频率&lt;/li&gt;
&lt;li&gt;N 完成一次数据传送所用的时钟周期数&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;总线的寻址能力 地址线位数所确定的可寻址空间的大小&lt;/li&gt;
&lt;li&gt;总线定时方式&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;同步&lt;/li&gt;
&lt;li&gt;异步&lt;/li&gt;
&lt;li&gt;半同步&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;6&#34;&gt;
&lt;li&gt;总线传送方式&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;非突发 先传地址，再传数据&lt;/li&gt;
&lt;li&gt;突发 先给出首地址，连续传送数据块&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在总线宽度和总线时钟频率相同的情况下，突发方式数据传输更快。&lt;/p&gt;
&lt;ol start=&#34;7&#34;&gt;
&lt;li&gt;总线负载能力 总线的负载一般指总线上扩展槽的个数&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;基于总线的互连结构&#34;&gt;基于总线的互连结构&lt;/h3&gt;
&lt;h2 id=&#34;io接口&#34;&gt;I/O接口&lt;/h2&gt;
&lt;p&gt;解决外设与主机之间同步与协调、工作速度的匹配和数据格式的转换等问题。&lt;/p&gt;
&lt;h3 id=&#34;io接口的功能&#34;&gt;I/O接口的功能&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;数据缓冲&lt;/li&gt;
&lt;li&gt;错误或状态检测&lt;/li&gt;
&lt;li&gt;控制和定时&lt;/li&gt;
&lt;li&gt;数据格式转换&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;io接口的通用结构&#34;&gt;I/O接口的通用结构&lt;/h3&gt;
&lt;h3 id=&#34;io端口及其编址&#34;&gt;I/O端口及其编址&lt;/h3&gt;
&lt;h2 id=&#34;io数据传送控制方式&#34;&gt;I/O数据传送控制方式&lt;/h2&gt;
&lt;h3 id=&#34;程序直接控制io方式&#34;&gt;程序直接控制I/O方式&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;无条件传送方式 适用于简单外设&lt;/li&gt;
&lt;li&gt;条件传送方式 适用于自身能独立启动I/O的设备&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;定时查询&lt;/li&gt;
&lt;li&gt;独占查询&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;程序中新io方式&#34;&gt;程序中新I/O方式&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;中断的概念&lt;/li&gt;
&lt;li&gt;中断系统的基本职能和结构&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;及时记录各种中断请求信号&lt;/li&gt;
&lt;li&gt;自动响应中断请求&lt;/li&gt;
&lt;li&gt;自动判优&lt;/li&gt;
&lt;li&gt;保护被中断程序的断点和现场&lt;/li&gt;
&lt;li&gt;中断屏蔽&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;中断过程&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;io子系统概述&#34;&gt;I/O子系统概述&lt;/h2&gt;
&lt;h2 id=&#34;内核空间io软件&#34;&gt;内核空间I/O软件&lt;/h2&gt;
&lt;h3 id=&#34;与设备无关的io软件&#34;&gt;与设备无关的I/O软件&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;设备驱动程序统一接口&lt;/li&gt;
&lt;li&gt;缓冲区处理&lt;/li&gt;
&lt;li&gt;错误报告&lt;/li&gt;
&lt;li&gt;打开和关闭文件&lt;/li&gt;
&lt;li&gt;逻辑块大小处理&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;设备驱动程序&#34;&gt;设备驱动程序&lt;/h3&gt;
&lt;h3 id=&#34;中断服务程序&#34;&gt;中断服务程序&lt;/h3&gt;
&lt;h1 id=&#34;并行处理系统&#34;&gt;并行处理系统&lt;/h1&gt;
&lt;p&gt;通过采用多个功能部件或多个处理器核或多个CPU或多台计算机的互连，使得一个系统中可以同时进行多条指令或多个线程或多个任务的处理，从而实现计算速度和计算能力的大幅提升。&lt;/p&gt;
&lt;h2 id=&#34;并行处理系统概述&#34;&gt;并行处理系统概述&lt;/h2&gt;
&lt;h3 id=&#34;并行处理的主要技术性问题&#34;&gt;并行处理的主要技术性问题&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;互连&lt;/li&gt;
&lt;li&gt;数据一致性&lt;/li&gt;
&lt;li&gt;同步控制&lt;/li&gt;
&lt;li&gt;任务划分&lt;/li&gt;
&lt;li&gt;并行程序设计&lt;/li&gt;
&lt;li&gt;资源调度和管理&lt;/li&gt;
&lt;li&gt;容错性和安全性&lt;/li&gt;
&lt;li&gt;性能分析与评估&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;并行处理系统的分类&#34;&gt;并行处理系统的分类&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;Flynn分类&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;单指令流单数据流结构&lt;/li&gt;
&lt;li&gt;单指令流多数据流结构&lt;/li&gt;
&lt;li&gt;多指令流单数据流结构&lt;/li&gt;
&lt;li&gt;多指令流多数据流结构&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;按地址空间的访问方式分类&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;多计算机系统 具有多个私有地址空间的并行处理系统&lt;/li&gt;
&lt;li&gt;多处理器系统 共享的单一地址空间的并行处理器系统&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;按存储访问时间是否一致划分&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;一致性内存访问结构&lt;/li&gt;
&lt;li&gt;非一致性内存访问结构&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;按处理器单元的位置及其互连方式划分&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;多核芯片 一个CPU芯片中包含多个处理单元，每个处理单元称为一个 &lt;strong&gt;核&lt;/strong&gt;，所有核可能共享一个LLC，并共享主存储器&lt;/li&gt;
&lt;li&gt;众核芯片 一个面向三维图形、视频和可视化处理的GPU芯片中，包含多达几百个的简单核&lt;/li&gt;
&lt;li&gt;对称多处理器 多个相同类型的GPU通过总线互连，并以相同地位共享系统的所有资源&lt;/li&gt;
&lt;li&gt;大规模并行处理机 以专用内联网络连接数量众多的处理单元而构成的一种并行计算系统&lt;/li&gt;
&lt;li&gt;集群 通过高性能网卡将若干个普通PC或SMP服务器或工作站连接而成的并行处理系统&lt;/li&gt;
&lt;li&gt;网格 用因特网等广域网连接起来的远距离分布的一组异构计算机系统构成的分布式并行处理系统&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;多处理器系统&#34;&gt;多处理器系统&lt;/h2&gt;
&lt;h3 id=&#34;uma多处理器系统&#34;&gt;UMA多处理器系统&lt;/h3&gt;
&lt;p&gt;每个处理器对存储单元的访问时间是一致的&lt;/p&gt;
&lt;h3 id=&#34;numa多处理器系统&#34;&gt;NUMA多处理器系统&lt;/h3&gt;
&lt;h3 id=&#34;多处理器系统中的互连网络&#34;&gt;多处理器系统中的互连网络&lt;/h3&gt;
&lt;h3 id=&#34;片级多处理器和多线程技术&#34;&gt;片级多处理器和多线程技术&lt;/h3&gt;
&lt;h2 id=&#34;多计算机系统&#34;&gt;多计算机系统&lt;/h2&gt;
&lt;h3 id=&#34;集群多计算机系统&#34;&gt;集群多计算机系统&lt;/h3&gt;
&lt;h2 id=&#34;向量处理机和simd技术&#34;&gt;向量处理机和SIMD技术&lt;/h2&gt;
&lt;h3 id=&#34;向量处理机&#34;&gt;向量处理机&lt;/h3&gt;
&lt;h3 id=&#34;intel中的simd技术&#34;&gt;Intel中的SIMD技术&lt;/h3&gt;
&lt;h3 id=&#34;gpu架构&#34;&gt;GPU架构&lt;/h3&gt;
&lt;h2 id=&#34;并行处理编程模式简介&#34;&gt;并行处理编程模式简介&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;共享存储变量方式&lt;/li&gt;
&lt;li&gt;消息传递方式&lt;/li&gt;
&lt;li&gt;MapReduce并行程序设计方式&lt;/li&gt;
&lt;li&gt;CUDA并行程序设计方式&lt;/li&gt;
&lt;/ol&gt;
- https://ntutn.top/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/ - CC BY-SA 4.0</description>
        </item>
    
    
    
        <item>
        <title>数据结构 栈应用 1 括号匹配</title>
        <link>https://ntutn.top/posts/%E6%8B%AC%E5%8F%B7%E5%8C%B9%E9%85%8D/</link>
        <pubDate>Thu, 25 Apr 2019 03:11:37 +0800</pubDate>
        
        <guid>https://ntutn.top/posts/%E6%8B%AC%E5%8F%B7%E5%8C%B9%E9%85%8D/</guid>
        <description>归零幻想 https://ntutn.top/posts/%E6%8B%AC%E5%8F%B7%E5%8C%B9%E9%85%8D/ -&lt;!-- raw HTML omitted --&gt;
&lt;blockquote&gt;
&lt;p&gt;大概是一道栈的应用的水题吧。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;输入一行符号,以&lt;code&gt;#&lt;/code&gt;结束，判断其中的括号是否匹配。
遇到左括号入栈，遇到右括号出栈。如果字符串结束栈不空，输出栈内左括号对应右括号。&lt;/p&gt;
&lt;h2 id=&#34;question&#34;&gt;Question&lt;/h2&gt;
&lt;p&gt;用栈实现：输入一行符号,以#结束，判断其中的括号是否匹配。括号包括：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{ } 、 [ ] 、 ( )、  &amp;lt; &amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果匹配，输出 &lt;code&gt;right&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;如果不匹配，给出错误提示。包括：&lt;/p&gt;
&lt;p&gt;第几个符号处理时出现错误；哪几个符号失配等&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;h2 id=&#34;example&#34;&gt;Example&lt;/h2&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;h2 id=&#34;思路&#34;&gt;思路&lt;/h2&gt;
&lt;p&gt;遇到左括号入栈，遇到右括号出栈。如果字符串结束栈不空，输出栈内左括号对应右括号。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;没有一遍过，因为题目中没说如果出错就不再继续处理。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;相关&#34;&gt;相关&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;栈：顺序表，只允许在一端输入输出。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;getline(cin,str);&lt;/code&gt;可输入整行，支持空格。&lt;/li&gt;
&lt;li&gt;如果用数组实现栈，则其存储空间必须是一次性申请得到的。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;answer&#34;&gt;Answer&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;指定初始&lt;code&gt;maxsize=1&lt;/code&gt;是我某种程度上的强迫症，反正这题时间限制很宽松。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#1e889b&#34;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;#include&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;&amp;lt;cstring&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;#include&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;&amp;lt;string&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;using&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;namespace&lt;/span&gt; std;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;mystack&lt;/span&gt;{
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;private&lt;/span&gt;:
    &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;char&lt;/span&gt; *data;
    &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; maxsize;
    &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; top;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt;:
    mystack(){
        maxsize=&lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;;
        data=&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;char&lt;/span&gt;[maxsize];
        top=-&lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;;
    }
    &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;bool&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;isEmpty&lt;/span&gt;(){
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; top==-&lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;;
    }
    &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;char&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;getTop&lt;/span&gt;(){
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt;(top&amp;gt;-&lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;){
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; data[top];
        }
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;\0&amp;#39;&lt;/span&gt;;
    }
    &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;pop&lt;/span&gt;(){
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt;(top&amp;gt;=&lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;){
            top--;
        }
    }
    &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;expand&lt;/span&gt;(){
        &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;char&lt;/span&gt;*tmp=&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;char&lt;/span&gt;[maxsize*&lt;span style=&#34;color:#b452cd&#34;&gt;2&lt;/span&gt;];
        strncpy(tmp,data,maxsize);
        maxsize*=&lt;span style=&#34;color:#b452cd&#34;&gt;2&lt;/span&gt;;
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;delete&lt;/span&gt;[] data;
        data=tmp;
    }
    &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;push&lt;/span&gt;(&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;char&lt;/span&gt; x){
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt;(top+&lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;==maxsize){
            expand();
        }
        data[++top]=x;
    }
    ~mystack(){
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;delete&lt;/span&gt;[] data;
    }
};
&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;char&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;getPar&lt;/span&gt;(&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;char&lt;/span&gt; x){
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;switch&lt;/span&gt;(x){
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;case&lt;/span&gt; &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;{&amp;#39;&lt;/span&gt;:
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;}&amp;#39;&lt;/span&gt;;
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;case&lt;/span&gt; &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;[&amp;#39;&lt;/span&gt;:
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;]&amp;#39;&lt;/span&gt;;
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;case&lt;/span&gt; &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;(&amp;#39;&lt;/span&gt;:
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;)&amp;#39;&lt;/span&gt;;
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;case&lt;/span&gt; &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;&amp;lt;&amp;#39;&lt;/span&gt;:
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;&amp;gt;&amp;#39;&lt;/span&gt;;
    }
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;\0&amp;#39;&lt;/span&gt;;
}
&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;isKH&lt;/span&gt;(&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;char&lt;/span&gt; x){
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;switch&lt;/span&gt;(x){
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;case&lt;/span&gt; &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;{&amp;#39;&lt;/span&gt;:
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;case&lt;/span&gt; &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;[&amp;#39;&lt;/span&gt;:
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;case&lt;/span&gt; &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;(&amp;#39;&lt;/span&gt;:
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;case&lt;/span&gt; &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;&amp;lt;&amp;#39;&lt;/span&gt;:
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;;
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;case&lt;/span&gt; &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;}&amp;#39;&lt;/span&gt;:
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;case&lt;/span&gt; &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;]&amp;#39;&lt;/span&gt;:
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;case&lt;/span&gt; &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;)&amp;#39;&lt;/span&gt;:
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;case&lt;/span&gt; &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;&amp;gt;&amp;#39;&lt;/span&gt;:
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#b452cd&#34;&gt;2&lt;/span&gt;;
    }
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;;
}
&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;main&lt;/span&gt;()
{
    string tmp;
    getline(cin,tmp);
    mystack*stk=&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; mystack();
    &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;bool&lt;/span&gt; erred=&lt;span style=&#34;color:#658b00&#34;&gt;false&lt;/span&gt;;
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt;(&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; i=&lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;;i&amp;lt;tmp.size();i++){
        &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;char&lt;/span&gt; x=tmp.at(i);
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt;(x==&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;#&amp;#39;&lt;/span&gt;){
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt;(!stk-&amp;gt;isEmpty()){
                cout&amp;lt;&amp;lt;&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;loss of right character &amp;#34;&lt;/span&gt;;
                &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;while&lt;/span&gt;(!stk-&amp;gt;isEmpty()){
                    cout&amp;lt;&amp;lt;getPar(stk-&amp;gt;getTop());
                    stk-&amp;gt;pop();
                }
                cout&amp;lt;&amp;lt;&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;.&amp;#34;&lt;/span&gt;&amp;lt;&amp;lt;endl;
                &lt;span style=&#34;color:#228b22&#34;&gt;//erred=true;
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;                &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;;
            }
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt;(!erred){
                cout&amp;lt;&amp;lt;&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;right&amp;#34;&lt;/span&gt;&amp;lt;&amp;lt;endl;
            }
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;;
        }
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt;(isKH(x)==&lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;){
            stk-&amp;gt;push(x);
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;continue&lt;/span&gt;;
        }
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt;(isKH(x)==&lt;span style=&#34;color:#b452cd&#34;&gt;2&lt;/span&gt;){
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt;(getPar(stk-&amp;gt;getTop())==x){
                stk-&amp;gt;pop();
                &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;continue&lt;/span&gt;;
            }&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;else&lt;/span&gt;{
                cout&amp;lt;&amp;lt;&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;The &amp;#34;&lt;/span&gt;&amp;lt;&amp;lt;i+&lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;&amp;lt;&amp;lt;&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34; character &amp;#39;&amp;#34;&lt;/span&gt;&amp;lt;&amp;lt;x&amp;lt;&amp;lt;&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;&amp;#39; is wrong.&amp;#34;&lt;/span&gt;&amp;lt;&amp;lt;endl;
                &lt;span style=&#34;color:#228b22&#34;&gt;//erred=true;
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;                &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;;
            }
        }
    }
    &lt;span style=&#34;color:#228b22&#34;&gt;//cout &amp;lt;&amp;lt; &amp;#34;Hello world!&amp;#34; &amp;lt;&amp;lt; endl;
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;- https://ntutn.top/posts/%E6%8B%AC%E5%8F%B7%E5%8C%B9%E9%85%8D/ - CC BY-SA 4.0</description>
        </item>
    
    
  </channel>
</rss> 