<?xml-stylesheet href="/rss.xsl" type="text/xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>归零幻想</title>
    <link>https://ntutn.top/</link>
    <description>Recent content on 归零幻想</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <copyright>CC BY-SA 4.0</copyright>
    <lastBuildDate>Sun, 24 Oct 2021 03:11:37 +0800</lastBuildDate>
    
        <atom:link href="https://ntutn.top/index.xml" rel="self" type="application/rss+xml" />
    
    
    
        <item>
        <title>B站的搬运机制和盗视频行为有区别吗</title>
        <link>https://ntutn.top/posts/b%E7%AB%99%E7%9A%84%E6%90%AC%E8%BF%90%E6%9C%BA%E5%88%B6%E5%92%8C%E7%9B%97%E8%A7%86%E9%A2%91%E8%A1%8C%E4%B8%BA%E6%9C%89%E5%8C%BA%E5%88%AB%E5%90%97/</link>
        <pubDate>Tue, 24 Nov 2020 03:11:37 +0800</pubDate>
        
        <guid>https://ntutn.top/posts/b%E7%AB%99%E7%9A%84%E6%90%AC%E8%BF%90%E6%9C%BA%E5%88%B6%E5%92%8C%E7%9B%97%E8%A7%86%E9%A2%91%E8%A1%8C%E4%B8%BA%E6%9C%89%E5%8C%BA%E5%88%AB%E5%90%97/</guid>
        <description>归零幻想 https://ntutn.top/posts/b%E7%AB%99%E7%9A%84%E6%90%AC%E8%BF%90%E6%9C%BA%E5%88%B6%E5%92%8C%E7%9B%97%E8%A7%86%E9%A2%91%E8%A1%8C%E4%B8%BA%E6%9C%89%E5%8C%BA%E5%88%AB%E5%90%97/ -&lt;p&gt;在知乎看到这样的问题&lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;，写下我的观点，也同步写到这里。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;『搬运』同『转载』，『盗视频』特指『无授权转载视频』并隐含指『借此获得收益』。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;p&gt;b站用户被指责双标， &lt;strong&gt;最大的锅是b站而不是up主&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;b站没有明显区分转载作品和原创作品，在我看来就是享受了转载内容带来的红利又想规避因此带来的舆论和法律问题。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如何判断视频是转载的还是原创的？你看这里它只能投一个币这是搬运的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;h2 id=&#34;收益&#34;&gt;收益&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;『搬运』视频是不能获得收益的。
很大程度这与是否获得授权无关，甚至与界定是否『商业使用』无关。up主没有获得收益，但显而易见b站是有收益的。比如一篇文章，转载到我的个人博客大概可以算非商业使用，因为博客中 &lt;strong&gt;没有任何广告，没有打赏或捐赠选项，没有对任何产品的商业宣传。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当然这一点不是up主的锅，但至少 &lt;strong&gt;请收起『搬运是给你免费做宣传』的说辞。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;授权问题&#34;&gt;授权问题&lt;/h2&gt;
&lt;p&gt;『转载』行为是应当获取授权的，退一步讲至少是应当标明出处的。b站自己产生的内容默认会标注『禁止转载』，但大多网站不会有明显标注，所以给转载者留下余地，有人认为未标注默认应该是允许转载。在我看来这一点是不成立的，至少 &lt;strong&gt;在github，如果一个项目没有任何LICENSE说明和文件，应该被理解为保留授权&lt;/strong&gt; ，即使大多数情况只是作者忘了。&lt;/p&gt;
&lt;h2 id=&#34;标注出处&#34;&gt;标注出处&lt;/h2&gt;
&lt;p&gt;转载应标注出处，如何才算『标注出处』呢？很多视频中一句『来自Youtube』就算标注了出处了，标题还是翻译后的，你根据这句话能找到来源？&lt;/p&gt;
&lt;p&gt;即使标注了出处，基本上也只能写在视频的简介中。很多人不习惯看视频简介，尤其是b站还会默认折叠比较长的简介。 &lt;em&gt;还是b站的锅&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;我认为，合适的转载应该明显标出作品来源，并 &lt;strong&gt;至少要提供出足以找到来源作品的信息&lt;/strong&gt; 。书籍杂志没办法，但对于互联网的文章，提供来源链接才算诚意。当然有些平台带超链接会无法过审，那可以再做权衡。&lt;/p&gt;
&lt;h2 id=&#34;倡议&#34;&gt;倡议&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;对于内容创作者，顺手标注是否允许转载，比如我在自己博客标注了『在未另行说明的情况下，本站内容遵守 &lt;a href=&#34;https://creativecommons.org/licenses/by-sa/4.0/deed.zh&#34;&gt;署名-相同方式共享 4.0 国际&lt;/a&gt; (CC BY-SA 4.0)』 ，这样非商业转载就无须另外询问我的意见了。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对于转载内容的人，建议在来源未写明是否授权转载的情况下，主动向原作者申请授权。知乎曾经流行过『来自网络，侵删』式的标注，虽然也表达了态度，但实际上并不能规避因此带来的侵权法律风险。能找到作者情况下，申请授权才是正理。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对于用户，自觉抵制不标注出处甚至不标注『转载』的转载内容。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;section class=&#34;footnotes&#34; role=&#34;doc-endnotes&#34;&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id=&#34;fn:1&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;&lt;a href=&#34;https://www.zhihu.com/question/379843948&#34;&gt;B站的搬运机制和盗视频行为有区别吗？ - 知乎&lt;/a&gt; &lt;a href=&#34;#fnref:1&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
- https://ntutn.top/posts/b%E7%AB%99%E7%9A%84%E6%90%AC%E8%BF%90%E6%9C%BA%E5%88%B6%E5%92%8C%E7%9B%97%E8%A7%86%E9%A2%91%E8%A1%8C%E4%B8%BA%E6%9C%89%E5%8C%BA%E5%88%AB%E5%90%97/ - CC BY-SA 4.0</description>
        </item>
    
    
    
        <item>
        <title>android项目开发：多线程编程</title>
        <link>https://ntutn.top/posts/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/</link>
        <pubDate>Fri, 21 Aug 2020 03:11:37 +0800</pubDate>
        
        <guid>https://ntutn.top/posts/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/</guid>
        <description>归零幻想 https://ntutn.top/posts/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/ -&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;仍然是《第一行代码》的笔记，不过略过了deprated的内容，并探究了下Handler的工作机制。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;上班了，果然没有那么多大块时间写博客了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;handler&#34;&gt;Handler&lt;/h2&gt;
&lt;p&gt;主线程不能进行耗时处理，子线程不能访问UI，所以我们需要异步消息处理机制。&lt;/p&gt;
&lt;h3 id=&#34;使用&#34;&gt;使用&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-kotlin&#34; data-lang=&#34;kotlin&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;MainActivity&lt;/span&gt; : AppCompatActivity() {
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;lateinit&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;var&lt;/span&gt; binding: ActivityMainBinding
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;val&lt;/span&gt; handler = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;object&lt;/span&gt; &lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;: &lt;/span&gt;&lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;Handler&lt;/span&gt;(Looper.getMainLooper()) {
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;override&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;handleMessage&lt;/span&gt;(msg: Message) {
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;when&lt;/span&gt;(msg.what){
                MSG_UPDATE_TEXT -&amp;gt; binding.textView.text = &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;Nice to meet you. &amp;#34;&lt;/span&gt;
            }
        }
    }
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;override&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;onCreate&lt;/span&gt;(savedInstanceState: Bundle?) {
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;super&lt;/span&gt;.onCreate(savedInstanceState)
        binding = ActivityMainBinding.inflate(layoutInflater)
        setContentView(binding.root)
        initView()
    }
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;initView&lt;/span&gt;() {
        binding.apply {
            changeTextButton.setOnClickListener {
                thread {
                    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;val&lt;/span&gt; msg = Message()
                    msg.what = MSG_UPDATE_TEXT
                    handler.sendMessage(msg)
                }
            }
        }
    }
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;companion&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;object&lt;/span&gt; {
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;val&lt;/span&gt; MSG_UPDATE_TEXT = &lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;原理&#34;&gt;原理&lt;/h3&gt;
&lt;p&gt;图片有点多，懒得一张张转移了，去我整理的文档看吧：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://bytedance.feishu.cn/docs/doccnRaxHFiTJDYLBuYMzpSSJAd&#34;&gt;安卓Handler异步消息处理机制&lt;/a&gt;&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;h2 id=&#34;service&#34;&gt;Service&lt;/h2&gt;
&lt;p&gt;三个回调：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;onCreate()&lt;/code&gt; 在Service创建时调用&lt;/li&gt;
&lt;li&gt;&lt;code&gt;onStartCommand()&lt;/code&gt;在Service每次启动时被调用&lt;/li&gt;
&lt;li&gt;&lt;code&gt;onDestory()&lt;/code&gt;在Service销毁时调用&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;通过&lt;code&gt;startService(intent)&lt;/code&gt;和&lt;code&gt;stopService(intent)&lt;/code&gt;的方式启动和停止Service。&lt;/p&gt;
&lt;p&gt;Binder用于和View绑定通信。Binder和前台Service具体参见下面例子。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-kotlin&#34; data-lang=&#34;kotlin&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;package&lt;/span&gt; &lt;span style=&#34;color:#008b45;text-decoration:underline&#34;&gt;top.ntutn.servicetest&lt;/span&gt;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color:#008b45;text-decoration:underline&#34;&gt;android.app.NotificationChannel&lt;/span&gt;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color:#008b45;text-decoration:underline&#34;&gt;android.app.NotificationManager&lt;/span&gt;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color:#008b45;text-decoration:underline&#34;&gt;android.app.PendingIntent&lt;/span&gt;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color:#008b45;text-decoration:underline&#34;&gt;android.app.Service&lt;/span&gt;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color:#008b45;text-decoration:underline&#34;&gt;android.content.Context&lt;/span&gt;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color:#008b45;text-decoration:underline&#34;&gt;android.content.Intent&lt;/span&gt;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color:#008b45;text-decoration:underline&#34;&gt;android.graphics.BitmapFactory&lt;/span&gt;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color:#008b45;text-decoration:underline&#34;&gt;android.os.Binder&lt;/span&gt;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color:#008b45;text-decoration:underline&#34;&gt;android.os.Build&lt;/span&gt;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color:#008b45;text-decoration:underline&#34;&gt;android.util.Log&lt;/span&gt;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color:#008b45;text-decoration:underline&#34;&gt;androidx.core.app.NotificationCompat&lt;/span&gt;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;MyService&lt;/span&gt; : Service() {
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;val&lt;/span&gt; mBinder = DownloadBinder()
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;DownloadBinder&lt;/span&gt; : Binder() {
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;startDownload&lt;/span&gt;() {
            Log.d(javaClass.simpleName, &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;startDownload() executed&amp;#34;&lt;/span&gt;)
        }
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;getProcess&lt;/span&gt;(): Int {
            Log.d(javaClass.simpleName, &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;getProcess() executed&amp;#34;&lt;/span&gt;)
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;
        }
    }
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;override&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;onBind&lt;/span&gt;(intent: Intent) = mBinder
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;override&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;onCreate&lt;/span&gt;() {
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;super&lt;/span&gt;.onCreate()
        Log.d(javaClass.simpleName, &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;onCreate() executed&amp;#34;&lt;/span&gt;)
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;val&lt;/span&gt; manager = getSystemService(Context.NOTIFICATION_SERVICE) &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;as&lt;/span&gt; NotificationManager
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (Build.VERSION.SDK_INT &amp;gt;= Build.VERSION_CODES.O) {
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;val&lt;/span&gt; channel = NotificationChannel(
                &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;my_service&amp;#34;&lt;/span&gt;,
                &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;前台Service通知&amp;#34;&lt;/span&gt;,
                NotificationManager.IMPORTANCE_DEFAULT
            )
            manager.createNotificationChannel(channel)
        }
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;val&lt;/span&gt; intent = Intent(&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;, MainActivity::&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt;.java)
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;val&lt;/span&gt; pi = PendingIntent.getActivity(&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;, REQ_MY_SERVICE, intent, &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;)
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;val&lt;/span&gt; notification = NotificationCompat.Builder(&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;, &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;my_service&amp;#34;&lt;/span&gt;)
            .setContentTitle(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;This is content title&amp;#34;&lt;/span&gt;)
            .setContentText(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;This is content text. &amp;#34;&lt;/span&gt;)
            .setContentIntent(pi)
            .setSmallIcon(R.drawable.ic_launcher_foreground)
            .setLargeIcon(BitmapFactory.decodeResource(resources,R.drawable.ic_launcher_foreground))
            .build()
        startForeground(&lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;, notification)
    }
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;override&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;onStartCommand&lt;/span&gt;(intent: Intent?, flags: Int, startId: Int): Int {
        Log.d(javaClass.simpleName, &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;onStartCommand() executed&amp;#34;&lt;/span&gt;)
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;super&lt;/span&gt;.onStartCommand(intent, flags, startId)
    }
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;override&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;onDestroy&lt;/span&gt;() {
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;super&lt;/span&gt;.onDestroy()
        Log.d(javaClass.simpleName, &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;onDestroy() executed&amp;#34;&lt;/span&gt;)
    }
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;companion&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;object&lt;/span&gt; {
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;val&lt;/span&gt; REQ_MY_SERVICE = &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-kotlin&#34; data-lang=&#34;kotlin&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;package&lt;/span&gt; &lt;span style=&#34;color:#008b45;text-decoration:underline&#34;&gt;top.ntutn.servicetest&lt;/span&gt;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color:#008b45;text-decoration:underline&#34;&gt;android.content.ComponentName&lt;/span&gt;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color:#008b45;text-decoration:underline&#34;&gt;android.content.Context&lt;/span&gt;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color:#008b45;text-decoration:underline&#34;&gt;android.content.Intent&lt;/span&gt;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color:#008b45;text-decoration:underline&#34;&gt;android.content.ServiceConnection&lt;/span&gt;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color:#008b45;text-decoration:underline&#34;&gt;android.os.Bundle&lt;/span&gt;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color:#008b45;text-decoration:underline&#34;&gt;android.os.IBinder&lt;/span&gt;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color:#008b45;text-decoration:underline&#34;&gt;androidx.appcompat.app.AppCompatActivity&lt;/span&gt;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color:#008b45;text-decoration:underline&#34;&gt;top.ntutn.servicetest.databinding.ActivityMainBinding&lt;/span&gt;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;MainActivity&lt;/span&gt; : AppCompatActivity() {
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;lateinit&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;var&lt;/span&gt; binding: ActivityMainBinding
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;lateinit&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;var&lt;/span&gt; downloadBinder: MyService.DownloadBinder
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;val&lt;/span&gt; connection = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;object&lt;/span&gt; &lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;: &lt;/span&gt;&lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;ServiceConnection&lt;/span&gt; {
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;override&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;onServiceConnected&lt;/span&gt;(name: ComponentName, service: IBinder) {
            downloadBinder = service &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;as&lt;/span&gt; MyService.DownloadBinder
            downloadBinder.startDownload()
            downloadBinder.getProcess()
        }
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;override&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;onServiceDisconnected&lt;/span&gt;(name: ComponentName?) = Unit
    }
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;override&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;onCreate&lt;/span&gt;(savedInstanceState: Bundle?) {
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;super&lt;/span&gt;.onCreate(savedInstanceState)
        binding = ActivityMainBinding.inflate(layoutInflater)
        setContentView(binding.root)
        initView()
    }
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;initView&lt;/span&gt;() {
        binding.apply {
            startServiceButton.setOnClickListener {
                &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;val&lt;/span&gt; intent = Intent(&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;&lt;span style=&#34;color:#707a7c&#34;&gt;@MainActivity&lt;/span&gt;, MyService::&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt;.java)
                startService(intent)
            }
            stopServiceButton.setOnClickListener {
                &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;val&lt;/span&gt; intent = Intent(&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;&lt;span style=&#34;color:#707a7c&#34;&gt;@MainActivity&lt;/span&gt;, MyService::&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt;.java)
                stopService(intent)
            }
            bindServiceButton.setOnClickListener {
                &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;val&lt;/span&gt; intent = Intent(&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;&lt;span style=&#34;color:#707a7c&#34;&gt;@MainActivity&lt;/span&gt;, MyService::&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt;.java)
                bindService(intent, connection, Context.BIND_AUTO_CREATE)
            }
            unbindServiceButton.setOnClickListener {
                unbindService(connection)
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;- https://ntutn.top/posts/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/ - CC BY-SA 4.0</description>
        </item>
    
    
    
        <item>
        <title>EventBus初探</title>
        <link>https://ntutn.top/posts/eventbus%E5%88%9D%E6%8E%A2/</link>
        <pubDate>Fri, 21 Aug 2020 03:11:37 +0800</pubDate>
        
        <guid>https://ntutn.top/posts/eventbus%E5%88%9D%E6%8E%A2/</guid>
        <description>归零幻想 https://ntutn.top/posts/eventbus%E5%88%9D%E6%8E%A2/ -&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;公司项目中大量运用了EventBus&lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;，这两天在做的需求相关的代码也用到了，于是还是要先去研究下这个EventBus是什么。&lt;/p&gt;
&lt;p&gt;EventBus，顾名思义，事件总线，是一个安卓上的事件管理平台。用事件驱动的机制来简化事件传递的逻辑。在这层意义上也许可以类比&lt;code&gt;Qt&lt;/code&gt;的信号槽机制，或者安卓的广播。当你需要把一个事件传递给多个对象，EventBus就变得非常有用。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/greenrobot/EventBus/raw/master/EventBus-Publish-Subscribe.png&#34; alt=&#34;EventBus&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;该图片来自EventBus的github仓库&lt;/em&gt;&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;h2 id=&#34;eventbus的使用&#34;&gt;EventBus的使用&lt;/h2&gt;
&lt;p&gt;首先当然是添加依赖&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-groovy&#34; data-lang=&#34;groovy&#34;&gt;implementation &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;org.greenrobot:eventbus:3.2.0&amp;#39;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;写个demo展示下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2020/09/08/CzpLZxPkrJiqaDm.jpg&#34; alt=&#34;photo_2020-09-08_15-58-48.jpg&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2020/09/08/SwM6ljRtPkgdGLT.jpg&#34; alt=&#34;photo_2020-09-08_15-59-12.jpg&#34;&gt;&lt;/p&gt;
&lt;p&gt;点击按钮后，将两处文本的值修改为文本框中的值。注意：上面的那个红色的文本处于一个fragment中。&lt;/p&gt;
&lt;p&gt;为此，我们先准备一个Event：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-kotlin&#34; data-lang=&#34;kotlin&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;data&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;ButtonEvent&lt;/span&gt;(&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;val&lt;/span&gt; text: String)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;点击按钮时，发送这个Event：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-kotlin&#34; data-lang=&#34;kotlin&#34;&gt;        button.setOnClickListener {
            EventBus.getDefault().post(ButtonEvent(editTextTextPersonName.text.toString()))
        }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;然后在需要接收这个请求的地方，比如我们在&lt;code&gt;MainActivity&lt;/code&gt;的&lt;code&gt;onCreate()&lt;/code&gt;中注册EventBus：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-kotlin&#34; data-lang=&#34;kotlin&#34;&gt;EventBus.getDefault().register(&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在&lt;code&gt;onDestory()&lt;/code&gt;中解除&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-kotlin&#34; data-lang=&#34;kotlin&#34;&gt;EventBus.getDefault().unregister(&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;然后就可以接收那个Event了。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-kotlin&#34; data-lang=&#34;kotlin&#34;&gt;    &lt;span style=&#34;color:#707a7c&#34;&gt;@Subscribe&lt;/span&gt;
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;onButtonEvent&lt;/span&gt;(buttonEvent: ButtonEvent){
        textView.text=buttonEvent.text
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;同样对于Fragment，我们只需要做同样的事情，就可以监听这个Event了。很明显，这对于一个事件有多个处理的场景是很方便的。&lt;/p&gt;
&lt;h2 id=&#34;订阅者的threadmode&#34;&gt;订阅者的threadMode&lt;/h2&gt;
&lt;p&gt;安卓应用启动时，系统会创建一个主线程，负责向UI组件分发事件&lt;sup id=&#34;fnref:2&#34;&gt;&lt;a href=&#34;#fn:2&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;，所有对UI的操作应该放到主线程中。EventBus是一种重要的跨线程更新UI的方式。&lt;sup id=&#34;fnref:3&#34;&gt;&lt;a href=&#34;#fn:3&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;3&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;@Subscribe&lt;/code&gt;注解有一个参数&lt;code&gt;threadMode&lt;/code&gt;，有以下取值：&lt;/p&gt;
&lt;h3 id=&#34;threadmodeposting&#34;&gt;ThreadMode.POSTING&lt;/h3&gt;
&lt;p&gt;默认值，在同一线程中调用，开销最小。&lt;/p&gt;
&lt;h3 id=&#34;threadmodemain&#34;&gt;ThreadMode.MAIN&lt;/h3&gt;
&lt;p&gt;在主线程中调用。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果发送事件的是主线程，则直接调用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;threadmodemain_ordered&#34;&gt;ThreadMode.MAIN_ORDERED&lt;/h3&gt;
&lt;p&gt;在主线程中调用，同步调用（排队）。&lt;/p&gt;
&lt;h3 id=&#34;threadmodebackground&#34;&gt;ThreadMode.BACKGROUND&lt;/h3&gt;
&lt;p&gt;在后台线程中调用。&lt;/p&gt;
&lt;h3 id=&#34;threadmodeasync&#34;&gt;ThreadMode.ASYNC&lt;/h3&gt;
&lt;p&gt;在单独线程中调用，用于耗时操作。&lt;/p&gt;
&lt;p&gt;对于EventBus更新UI，我同样写了demo：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-kotlin&#34; data-lang=&#34;kotlin&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;package&lt;/span&gt; &lt;span style=&#34;color:#008b45;text-decoration:underline&#34;&gt;com.example.eventbustimerdemo&lt;/span&gt;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color:#008b45;text-decoration:underline&#34;&gt;android.os.Bundle&lt;/span&gt;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color:#008b45;text-decoration:underline&#34;&gt;androidx.appcompat.app.AppCompatActivity&lt;/span&gt;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color:#008b45;text-decoration:underline&#34;&gt;kotlinx.android.synthetic.main.activity_main.*&lt;/span&gt;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color:#008b45;text-decoration:underline&#34;&gt;org.greenrobot.eventbus.EventBus&lt;/span&gt;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color:#008b45;text-decoration:underline&#34;&gt;org.greenrobot.eventbus.Subscribe&lt;/span&gt;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color:#008b45;text-decoration:underline&#34;&gt;org.greenrobot.eventbus.ThreadMode&lt;/span&gt;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;MainActivity&lt;/span&gt; : AppCompatActivity() {
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;override&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;onCreate&lt;/span&gt;(savedInstanceState: Bundle?) {
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;super&lt;/span&gt;.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        btnStart.setOnClickListener {
            Thread {
                &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;while&lt;/span&gt; (&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;true&lt;/span&gt;) {
                    Thread.sleep(&lt;span style=&#34;color:#b452cd&#34;&gt;1000&lt;/span&gt;)
                    EventBus.getDefault().post(TickEvent())
                }
            }.start()
            btnStart.isEnabled = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;false&lt;/span&gt;
        }
        EventBus.getDefault().register(&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;)
    }
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;override&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;onDestroy&lt;/span&gt;() {
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;super&lt;/span&gt;.onDestroy()
        EventBus.getDefault().unregister(&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;)
    }
    &lt;span style=&#34;color:#707a7c&#34;&gt;@Subscribe&lt;/span&gt;(threadMode = ThreadMode.MAIN)&lt;span style=&#34;color:#228b22&#34;&gt;//只有在UI线程中才能更新UI
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;onTimeTick&lt;/span&gt;(event: TickEvent) {
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;val&lt;/span&gt; currentNum = tvTime.text.toString().toInt()
        tvTime.text = (currentNum + &lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;).toString()
    }
}
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;TickEvent&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;stickyevent&#34;&gt;StickyEvent&lt;/h2&gt;
&lt;p&gt;『粘性事件』&lt;sup id=&#34;fnref:4&#34;&gt;&lt;a href=&#34;#fn:4&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;4&lt;/a&gt;&lt;/sup&gt;，即在事件被广播后将长时间存在，新的订阅者仍然能收到。在一些场景下还是有用的，比如我们可能在一个详情页进行投票操作，在返回主页后才进行统计。这时粘性事件会带来帮助。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-kotlin&#34; data-lang=&#34;kotlin&#34;&gt;        button.setOnClickListener {
            EventBus.getDefault().postSticky(VoteEvent(&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;true&lt;/span&gt;))
            finish()
        }
        button2.setOnClickListener {
            EventBus.getDefault().postSticky(VoteEvent(&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;false&lt;/span&gt;))
            finish()
        }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-kotlin&#34; data-lang=&#34;kotlin&#34;&gt;    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;override&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;onResume&lt;/span&gt;() {
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;super&lt;/span&gt;.onResume()
        EventBus.getDefault().register(&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;)
    }
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;override&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;onPause&lt;/span&gt;() {
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;super&lt;/span&gt;.onPause()
        EventBus.getDefault().unregister(&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;)
    }
    &lt;span style=&#34;color:#707a7c&#34;&gt;@Subscribe&lt;/span&gt;(threadMode = ThreadMode.MAIN,sticky = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;true&lt;/span&gt;)
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;onVoteEvent&lt;/span&gt;(event: VoteEvent) {
        textView.text = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (event.result) &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;你投票赞同&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;你投票反对&amp;#34;&lt;/span&gt;
        EventBus.getDefault().removeStickyEvent(event)
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;section class=&#34;footnotes&#34; role=&#34;doc-endnotes&#34;&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id=&#34;fn:1&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/greenrobot/EventBus&#34;&gt;EventBus&lt;/a&gt; &lt;a href=&#34;#fnref:1&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:2&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;&lt;a href=&#34;https://www.jianshu.com/p/0f5ed338feeb&#34;&gt;Android UI线程和非UI线程 &lt;/a&gt; &lt;a href=&#34;#fnref:2&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:3&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/haoyuegongzi/article/details/78406342&#34;&gt;Android开发中更新UI的几种常用方式 &lt;/a&gt; &lt;a href=&#34;#fnref:3&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:4&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/IO_Field/article/details/52185717&#34;&gt;深入理解EventBus - ThreadMode、Sticky Event等&lt;/a&gt; &lt;a href=&#34;#fnref:4&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
- https://ntutn.top/posts/eventbus%E5%88%9D%E6%8E%A2/ - CC BY-SA 4.0</description>
        </item>
    
    
    
        <item>
        <title>掉坑的日常：springboot的json属性名大小写问题</title>
        <link>https://ntutn.top/posts/%E6%8E%89%E5%9D%91%E7%9A%84%E6%97%A5%E5%B8%B8springboot%E7%9A%84json%E5%B1%9E%E6%80%A7%E5%90%8D%E5%A4%A7%E5%B0%8F%E5%86%99%E9%97%AE%E9%A2%98/</link>
        <pubDate>Tue, 24 Mar 2020 03:11:37 +0800</pubDate>
        
        <guid>https://ntutn.top/posts/%E6%8E%89%E5%9D%91%E7%9A%84%E6%97%A5%E5%B8%B8springboot%E7%9A%84json%E5%B1%9E%E6%80%A7%E5%90%8D%E5%A4%A7%E5%B0%8F%E5%86%99%E9%97%AE%E9%A2%98/</guid>
        <description>归零幻想 https://ntutn.top/posts/%E6%8E%89%E5%9D%91%E7%9A%84%E6%97%A5%E5%B8%B8springboot%E7%9A%84json%E5%B1%9E%E6%80%A7%E5%90%8D%E5%A4%A7%E5%B0%8F%E5%86%99%E9%97%AE%E9%A2%98/ -&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;这两天想给自己小组的项目添加一个自动升级功能。这事听着复杂，但毕竟是个很常见的功能，github上的轮子很多。经过考虑，我决定选择&lt;a href=&#34;https://github.com/xuexiangjys/XUpdate&#34;&gt;这个组件&lt;/a&gt;，然后自己写后端。反正后端就返回一个json的事。然后就掉了坑。&lt;/p&gt;
&lt;h2 id=&#34;起因&#34;&gt;起因&lt;/h2&gt;
&lt;p&gt;案发现场没什么好说的，就是我发现自己设置的不能实现升级，在客户端调试半天发现用官方的json能升级。然后我就找我的json和官方的json有什么区别，看ContentType也没设置错，仔细比对发现属性大小写竟然不对。我当时还挺惊讶的，毕竟是直接复制的。&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;springboot可以使用&lt;code&gt;@ResponseBody&lt;/code&gt;返回对象自动转换json，而转换成的json属性名首字母会被转换成小写。&lt;/p&gt;
&lt;h2 id=&#34;解决方案&#34;&gt;解决方案&lt;/h2&gt;
&lt;h3 id=&#34;引入fastjson&#34;&gt;引入&lt;code&gt;fastjson&lt;/code&gt;&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-xml&#34; data-lang=&#34;xml&#34;&gt;		&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;
			&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;com.alibaba&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
			&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;fastjson&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
			&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;&amp;lt;version&amp;gt;&lt;/span&gt;1.2.66&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;
		&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;注入bean&#34;&gt;注入&lt;code&gt;bean&lt;/code&gt;&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;    &lt;span style=&#34;color:#707a7c&#34;&gt;@Bean&lt;/span&gt;
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; HttpMessageConverters &lt;span style=&#34;color:#008b45&#34;&gt;httpMessageConverters&lt;/span&gt;() {
        FastJsonHttpMessageConverter fastJsonHttpMessageConverter = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; FastJsonHttpMessageConverter(); &lt;span style=&#34;color:#228b22&#34;&gt;// 添加fastJson的配置信息
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        FastJsonConfig fastJsonConfig = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; FastJsonConfig();
        fastJsonConfig.&lt;span style=&#34;color:#658b00&#34;&gt;setSerializerFeatures&lt;/span&gt;(SerializerFeature.&lt;span style=&#34;color:#658b00&#34;&gt;PrettyFormat&lt;/span&gt;); &lt;span style=&#34;color:#228b22&#34;&gt;// 处理中文乱码问题
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        List&amp;lt;MediaType&amp;gt; fastMediaTypes = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();
        fastMediaTypes.&lt;span style=&#34;color:#658b00&#34;&gt;add&lt;/span&gt;(MediaType.&lt;span style=&#34;color:#658b00&#34;&gt;APPLICATION_JSON&lt;/span&gt;); &lt;span style=&#34;color:#228b22&#34;&gt;// 在convert中添加配置信息.
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        fastJsonHttpMessageConverter.&lt;span style=&#34;color:#658b00&#34;&gt;setSupportedMediaTypes&lt;/span&gt;(fastMediaTypes);
        fastJsonHttpMessageConverter.&lt;span style=&#34;color:#658b00&#34;&gt;setFastJsonConfig&lt;/span&gt;(fastJsonConfig);
        HttpMessageConverter&amp;lt;?&amp;gt; converter = fastJsonHttpMessageConverter;
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; HttpMessageConverters(converter);
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;在属性上加注解&#34;&gt;在属性上加注解&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;package&lt;/span&gt; &lt;span style=&#34;color:#008b45;text-decoration:underline&#34;&gt;edu.upc.mishuserver.vo&lt;/span&gt;;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color:#008b45;text-decoration:underline&#34;&gt;com.alibaba.fastjson.annotation.JSONField&lt;/span&gt;;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color:#008b45;text-decoration:underline&#34;&gt;lombok.AllArgsConstructor&lt;/span&gt;;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color:#008b45;text-decoration:underline&#34;&gt;lombok.Builder&lt;/span&gt;;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color:#008b45;text-decoration:underline&#34;&gt;lombok.Data&lt;/span&gt;;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color:#008b45;text-decoration:underline&#34;&gt;lombok.NoArgsConstructor&lt;/span&gt;;
&lt;span style=&#34;color:#228b22&#34;&gt;/**
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt; * UpdateInfo
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt; */&lt;/span&gt;
&lt;span style=&#34;color:#707a7c&#34;&gt;@Data&lt;/span&gt;
&lt;span style=&#34;color:#707a7c&#34;&gt;@AllArgsConstructor&lt;/span&gt;
&lt;span style=&#34;color:#707a7c&#34;&gt;@NoArgsConstructor&lt;/span&gt;
&lt;span style=&#34;color:#707a7c&#34;&gt;@Builder&lt;/span&gt;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;UpdateInfo&lt;/span&gt; {
    &lt;span style=&#34;color:#707a7c&#34;&gt;@JSONField&lt;/span&gt;(name=&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;Code&amp;#34;&lt;/span&gt;)
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;private&lt;/span&gt; Long code;
    &lt;span style=&#34;color:#707a7c&#34;&gt;@JSONField&lt;/span&gt;(name = &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;Msg&amp;#34;&lt;/span&gt;)
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;private&lt;/span&gt; String msg;
    &lt;span style=&#34;color:#707a7c&#34;&gt;@JSONField&lt;/span&gt;(name = &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;UpdateStatus&amp;#34;&lt;/span&gt;)
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;private&lt;/span&gt; Integer updateStatus;
    &lt;span style=&#34;color:#707a7c&#34;&gt;@JSONField&lt;/span&gt;(name = &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;VersionCode&amp;#34;&lt;/span&gt;)
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;private&lt;/span&gt; Long versionCode;
    &lt;span style=&#34;color:#707a7c&#34;&gt;@JSONField&lt;/span&gt;(name = &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;VersionName&amp;#34;&lt;/span&gt;)
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;private&lt;/span&gt; String versionName;
    &lt;span style=&#34;color:#707a7c&#34;&gt;@JSONField&lt;/span&gt;(name = &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;ModifyContent&amp;#34;&lt;/span&gt;)
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;private&lt;/span&gt; String modifyContent;
    &lt;span style=&#34;color:#707a7c&#34;&gt;@JSONField&lt;/span&gt;(name = &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;DownloadUrl&amp;#34;&lt;/span&gt;)
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;private&lt;/span&gt; String downloadUrl;
    &lt;span style=&#34;color:#707a7c&#34;&gt;@JSONField&lt;/span&gt;(name = &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;ApkSize&amp;#34;&lt;/span&gt;)
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;private&lt;/span&gt; Long apkSize;
    &lt;span style=&#34;color:#707a7c&#34;&gt;@JSONField&lt;/span&gt;(name = &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;ApkMd5&amp;#34;&lt;/span&gt;)
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;private&lt;/span&gt; String apkMd5;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;- https://ntutn.top/posts/%E6%8E%89%E5%9D%91%E7%9A%84%E6%97%A5%E5%B8%B8springboot%E7%9A%84json%E5%B1%9E%E6%80%A7%E5%90%8D%E5%A4%A7%E5%B0%8F%E5%86%99%E9%97%AE%E9%A2%98/ - CC BY-SA 4.0</description>
        </item>
    
    
    
        <item>
        <title>Typora&#43;git自动同步你的笔记</title>
        <link>https://ntutn.top/posts/typora&#43;git%E8%87%AA%E5%8A%A8%E5%90%8C%E6%AD%A5%E4%BD%A0%E7%9A%84%E7%AC%94%E8%AE%B0/</link>
        <pubDate>Mon, 02 Mar 2020 03:11:37 +0800</pubDate>
        
        <guid>https://ntutn.top/posts/typora&#43;git%E8%87%AA%E5%8A%A8%E5%90%8C%E6%AD%A5%E4%BD%A0%E7%9A%84%E7%AC%94%E8%AE%B0/</guid>
        <description>归零幻想 https://ntutn.top/posts/typora&#43;git%E8%87%AA%E5%8A%A8%E5%90%8C%E6%AD%A5%E4%BD%A0%E7%9A%84%E7%AC%94%E8%AE%B0/ -&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;这两天看了群里某个大佬的笔记，突然觉得自己用VSCode记笔记的方案不香了。VSCode虽然对&lt;code&gt;markdown&lt;/code&gt;的支持不错，但毕竟本职工作不是这个，直接拿来做笔记还是不够方便，太笨重了。于是我终于想起之前同学给我安利的&lt;code&gt;markdown&lt;/code&gt;编辑器：Typora。&lt;/p&gt;
&lt;h2 id=&#34;dalao的笔记&#34;&gt;dalao的笔记&lt;/h2&gt;
&lt;p&gt;首先看看大佬的笔记：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2020/08/20/1Lr3BfMvSw8haYy.png&#34; alt=&#34;1.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;好想去偷他的笔记。不过话说他这笔记软件也不错啊，看起来简约清晰，我也有试一试的想法了。&lt;/p&gt;
&lt;p&gt;他用的笔记软件：&lt;a href=&#34;https://github.com/tsujan/FeatherNotes&#34;&gt;https://github.com/tsujan/FeatherNotes&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;然后就被编译安装劝退了。一个是不太想这么折腾，另一个是这个软件没有提供编译好的包，感觉还是不够放心啊，毕竟如果以后开发者不维护了要再折腾一遍会非常麻烦。&lt;/p&gt;
&lt;h2 id=&#34;typora同学安利的markdown编辑工具&#34;&gt;Typora，同学安利的markdown编辑工具&lt;/h2&gt;
&lt;p&gt;与多数markdown编辑工具不同，Typora是所见即所得的markdown编辑工具。为什么程序员偏爱markdown？就是因为markdown可以让我们写作的时候只关注内容本身，而不用太在意排版的问题。而Typora又改变了传统的左右分栏或者点击切换预览的传统markdown编辑模式，用起来就更舒服了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2020/08/20/V7LzFNRXyT1hUbj.png&#34; alt=&#34;2.png&#34;&gt;&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;h3 id=&#34;安装&#34;&gt;安装&lt;/h3&gt;
&lt;p&gt;在Ubuntu下安装还是非常方便的：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;color:#228b22&#34;&gt;# or run:&lt;/span&gt;
&lt;span style=&#34;color:#228b22&#34;&gt;# sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys BA300B7755AFCFAE&lt;/span&gt;
wget -qO - https://typora.io/linux/public-key.asc | sudo apt-key add -
&lt;span style=&#34;color:#228b22&#34;&gt;# add Typora&amp;#39;s repository&lt;/span&gt;
sudo add-apt-repository &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;deb https://typora.io/linux ./&amp;#39;&lt;/span&gt;
sudo apt-get update
&lt;span style=&#34;color:#228b22&#34;&gt;# install typora&lt;/span&gt;
sudo apt-get install typora
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;其他系统参考&lt;a href=&#34;https://www.typora.net/#download&#34;&gt;官网&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&#34;复制图片&#34;&gt;复制图片&lt;/h3&gt;
&lt;p&gt;不过有一点要注意：我们写文档常常要插入一些图片，为了后面和git好配合，我们需要将这些图片也放到当前文件夹里。按下&lt;code&gt;Ctrl+逗号&lt;/code&gt;打开设置，将图片复制到当前文件夹下。如图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2020/08/20/VWcp6qEGOF9beZf.png&#34; alt=&#34;3.png&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;重要的快捷键&#34;&gt;重要的快捷键&lt;/h3&gt;
&lt;p&gt;都是重点等于没有重点。我们只要记住能让我们离开鼠标提高效率的就行了。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;快捷键&lt;/th&gt;
&lt;th&gt;功能&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;Ctrl+S&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;保存&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;Ctrl+Z&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;撤销&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;Ctrl+Y&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;重做&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;Ctrl+Shift+L&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;侧边栏&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;Ctrl+/&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;切换源代码模式&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;表格中，&lt;code&gt;Ctrl+Enter&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;添加一行&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;用git管理笔记&#34;&gt;用git管理笔记&lt;/h2&gt;
&lt;p&gt;首先什么是git？有些少年区分不了git和github，这是姿势水平还不够啊。听说过GitLab没？听说过码云没？不是修福报的那个马云哦。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;git：当前最流行的分布式版本控制软件&lt;/li&gt;
&lt;li&gt;github：通过Git进行版本控制的软件源代码托管服务平台&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;鉴于本文并不是为了介绍这二者，本人就简单粗暴放个链接了。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://zh.wikipedia.org/wiki/Git&#34;&gt;https://zh.wikipedia.org/wiki/Git&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://zh.wikipedia.org/wiki/GitHub&#34;&gt;https://zh.wikipedia.org/wiki/GitHub&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;git虽然大多用于管理程序源代码，但用来管理我们的笔记却也正好。虽然笔记对于版本控制的需求不是非常大，但聊胜于无嘛。最重要的是，你可以把笔记借助git同步到github上，什么时候换工作环境完全可以全pull下来，岂不美滋滋？&lt;/p&gt;
&lt;p&gt;git版本库托管平台有很多，这里我并没有选择github，而是选择了&lt;a href=&#34;https://code.aliyun.com&#34;&gt;阿里云的Code平台&lt;/a&gt;。毕竟在国内速度比较快啊。阿里云单个仓库容量足有2G，足够我们放笔记和笔记涉及的图片了。&lt;/p&gt;
&lt;p&gt;怎么注册账号，怎么建立仓库我就不说了。clone下来，这就是以后笔记安家的地方了。&lt;/p&gt;
&lt;h2 id=&#34;自动同步笔记&#34;&gt;自动同步笔记&lt;/h2&gt;
&lt;p&gt;然而，我们还是需要运行&lt;code&gt;git add&lt;/code&gt;、&lt;code&gt;git commit&lt;/code&gt;、&lt;code&gt;git push&lt;/code&gt;，而且在别处修改了笔记还得手动pull一下。执行的命令这么固定，肯定是要写成脚本(.sync.sh)了。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;color:#658b00&#34;&gt;cd&lt;/span&gt; /home/zero/Documents/Notes
git pull &amp;amp;
typora . TODO.md
git add .
git commit -m &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;Sync&amp;#34;&lt;/span&gt;
git push
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;注意上面的路径改为你自己笔记文件夹的路径。第二行的&lt;code&gt;&amp;amp;&lt;/code&gt;不要省，我们没必要等pull完才打开Typora，这样可以加快一点启动速度。&lt;/p&gt;
&lt;p&gt;好了，现在我们执行脚本就能打开Typora，而且所有编辑还能自动同步。由于git默认不允许保留空提交，没有修改的时候也不会产生大量无用的记录，完美。&lt;/p&gt;
&lt;p&gt;最后写个桌面启动器就大功告成了：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-ini&#34; data-lang=&#34;ini&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;[Desktop Entry]&lt;/span&gt;
&lt;span style=&#34;color:#658b00&#34;&gt;Type&lt;/span&gt;=&lt;span style=&#34;color:#cd5555&#34;&gt;Application&lt;/span&gt;
&lt;span style=&#34;color:#658b00&#34;&gt;Icon&lt;/span&gt;=&lt;span style=&#34;color:#cd5555&#34;&gt;typora&lt;/span&gt;
&lt;span style=&#34;color:#658b00&#34;&gt;Name&lt;/span&gt;=&lt;span style=&#34;color:#cd5555&#34;&gt;笔记&lt;/span&gt;
&lt;span style=&#34;color:#658b00&#34;&gt;Exec&lt;/span&gt;=&lt;span style=&#34;color:#cd5555&#34;&gt;/home/zero/Documents/Notes/.sync.sh&lt;/span&gt;
&lt;span style=&#34;color:#658b00&#34;&gt;Terminal&lt;/span&gt;=&lt;span style=&#34;color:#cd5555&#34;&gt;false&lt;/span&gt;
&lt;span style=&#34;color:#658b00&#34;&gt;Hidden&lt;/span&gt;=&lt;span style=&#34;color:#cd5555&#34;&gt;false&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;Note.desktop&lt;/code&gt;文件名保存到桌面就成了。&lt;/p&gt;
&lt;h2 id=&#34;windows下的配置&#34;&gt;Windows下的配置&lt;/h2&gt;
&lt;p&gt;Git是跨平台的，Typora也是跨平台的，那么我们这个方案自然同样可以跨平台。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Windows下的Typora并没有默认添加环境变量，请手动添加。添加后需要重启。
首先对应上面的sh，写个cmd(.sync.cmd)：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cmd&#34; data-lang=&#34;cmd&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;start&lt;/span&gt; /b git pull
typora . TODO.md
git add .
git commit -m &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;Sync&amp;#34;&lt;/span&gt;
git push
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;第一行不一样，这是因为cmd后台执行是用&lt;code&gt;start /b&lt;/code&gt;的，与shell脚本的&lt;code&gt;&amp;amp;&lt;/code&gt;效果是一样的。&lt;/p&gt;
&lt;p&gt;此时双击这个cmd已经能看到效果了。&lt;/p&gt;
&lt;p&gt;但cmd执行时会有黑窗口，很影响美观，我们写个vbs脚本(.sync.vbs)来调用它，这样可以不显示黑窗口。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-vbs&#34; data-lang=&#34;vbs&#34;&gt;WScript.CreateObject(&amp;quot;WScript.Shell&amp;quot;).Run &amp;quot;.sync.cmd&amp;quot;,0
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;最后创建个桌面快捷方式，指向&lt;code&gt;.sync.vbs&lt;/code&gt;，就大功告成了。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注意：快捷方式的起始目录要指向笔记的目录。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;p&gt;美中不足的是，在Android上我没找到比较合适的git客户端。虽然看到有个商用的评价不错，但为了这点笔记花那么多银子还是不值得。Android上的笔记软件倒是找到一个不错的：&lt;a href=&#34;https://github.com/gsantner/markor&#34;&gt;Markor&lt;/a&gt;。虽然没有Typora的所见即所得那么厉害，但他的编辑界面做的很不错，配上蓝牙键盘，非常适合某些科目上课做笔记。&lt;/p&gt;
- https://ntutn.top/posts/typora&#43;git%E8%87%AA%E5%8A%A8%E5%90%8C%E6%AD%A5%E4%BD%A0%E7%9A%84%E7%AC%94%E8%AE%B0/ - CC BY-SA 4.0</description>
        </item>
    
    
    
        <item>
        <title>Java自动装箱自动拆箱踩坑</title>
        <link>https://ntutn.top/posts/java%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1%E8%87%AA%E5%8A%A8%E6%8B%86%E7%AE%B1%E8%B8%A9%E5%9D%91/</link>
        <pubDate>Sun, 01 Mar 2020 03:11:37 +0800</pubDate>
        
        <guid>https://ntutn.top/posts/java%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1%E8%87%AA%E5%8A%A8%E6%8B%86%E7%AE%B1%E8%B8%A9%E5%9D%91/</guid>
        <description>归零幻想 https://ntutn.top/posts/java%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1%E8%87%AA%E5%8A%A8%E6%8B%86%E7%AE%B1%E8%B8%A9%E5%9D%91/ -&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;int和Integer有什么区别？前者是基础数据类型，后者是封装的Java对象。但在有&lt;code&gt;Autoboxing&lt;/code&gt;和&lt;code&gt;Unboxing&lt;/code&gt;的情况下我们常常就把两者等同看待，无非后者能放&lt;code&gt;null&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;事情要首先从一道力扣题目说起：&lt;/p&gt;
&lt;h2 id=&#34;删除排序数组中的重复项-ii&#34;&gt;删除排序数组中的重复项 II&lt;/h2&gt;
&lt;p&gt;给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素最多出现两次，返回移除后数组的新长度。&lt;/p&gt;
&lt;p&gt;不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;h3 id=&#34;示例-1&#34;&gt;示例 1:&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;给定 nums = [1,1,1,2,2,3],
函数应返回新长度 length = 5, 并且原数组的前五个元素被修改为 1, 1, 2, 2, 3 。
你不需要考虑数组中超出新长度后面的元素。
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;示例-2&#34;&gt;示例 2:&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;给定 nums = [0,0,1,1,1,1,2,3,3],
函数应返回新长度 length = 7, 并且原数组的前五个元素被修改为 0, 0, 1, 1, 2, 3, 3 。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;你不需要考虑数组中超出新长度后面的元素。&lt;/p&gt;
&lt;h3 id=&#34;answer&#34;&gt;Answer&lt;/h3&gt;
&lt;p&gt;针对这个题目，我写出了这样的代码：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#228b22&#34;&gt;/*
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt; * @lc app=leetcode.cn id=80 lang=java
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt; *
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt; * [80] 删除排序数组中的重复项 II
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt; */&lt;/span&gt;
&lt;span style=&#34;color:#228b22&#34;&gt;// @lc code=start
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;Solution&lt;/span&gt; {
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;removeDuplicates&lt;/span&gt;(&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt;[] nums) {
        &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; l = 0, r = 0;
        &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; ans1 = Integer.&lt;span style=&#34;color:#658b00&#34;&gt;MIN_VALUE&lt;/span&gt;, ans2 = Integer.&lt;span style=&#34;color:#658b00&#34;&gt;MIN_VALUE&lt;/span&gt;;
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;while&lt;/span&gt; (r &amp;lt; nums.&lt;span style=&#34;color:#658b00&#34;&gt;length&lt;/span&gt;) {
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (ans1==ans2&amp;amp;&amp;amp; ans2 == nums[r]) {
                ;
            } &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;else&lt;/span&gt; {
                nums[l] = nums[r];
                ans1 = ans2;
                ans2 = nums[r];
                l++;
            }
            r++;
        }
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; l;
    }
}
&lt;span style=&#34;color:#228b22&#34;&gt;// @lc code=end
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;掉坑&#34;&gt;掉坑&lt;/h3&gt;
&lt;p&gt;这代码在一般情况是没有问题的，但题目有个测试样例是&lt;code&gt;[-2147483648,-2147483648,-2147483648,1,1,1,2]&lt;/code&gt;，WA。&lt;/p&gt;
&lt;p&gt;懒得处理开头特殊情况，但貌似运气不好，出题人是想让我处理一下的。&lt;/p&gt;
&lt;p&gt;但作为懒癌患者我立马想到了新的偷懒方案，即用Integer代替int，这样用&lt;code&gt;null&lt;/code&gt;表示没有就正好了。&lt;/p&gt;
&lt;p&gt;于是改变如上语句，&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;        Integer ans1 = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;null&lt;/span&gt;, ans2 = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;null&lt;/span&gt;;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;和，&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (ans1!=&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;null&lt;/span&gt;&amp;amp;&amp;amp;ans1== ans2&amp;amp;&amp;amp; ans2 == nums[r]) {
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;然而又WA了。那组样例输出是&lt;code&gt;[-2147483648,-2147483648,-2147483648,1,1,2]&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&#34;问题原因&#34;&gt;问题原因&lt;/h2&gt;
&lt;p&gt;打开&lt;code&gt;jshell&lt;/code&gt;，
jshell&amp;gt; Integer a=-2147483648
a ==&amp;gt; -2147483648
jshell&amp;gt; Integer b=-2147483648
b ==&amp;gt; -2147483648
jshell&amp;gt; a==b
$6 ==&amp;gt; false
jshell&amp;gt; a==-2147483648
$7 ==&amp;gt; true
jshell&amp;gt;
成功复现问题。
a与b直接比较，&lt;code&gt;a==b&lt;/code&gt;，两者不是同一对象。与基本数据类型比较，&lt;code&gt;a==-2147483648&lt;/code&gt;，发生自动拆箱，两者值相等。
所以，上述代码只需要修改&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (ans1 != &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;null&lt;/span&gt; &amp;amp;&amp;amp; ans1.&lt;span style=&#34;color:#658b00&#34;&gt;intValue&lt;/span&gt;() == ans2.&lt;span style=&#34;color:#658b00&#34;&gt;intValue&lt;/span&gt;() &amp;amp; ans2 == nums[r]) {
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;AC。&lt;/p&gt;
&lt;h2 id=&#34;另一个处坑&#34;&gt;另一个处坑&lt;/h2&gt;
&lt;p&gt;这不是&lt;em&gt;自动装箱/自动拆箱&lt;/em&gt;第一次坑我，曾经有这样一段代码：&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;自动装箱自动拆箱配上函数重载，简直法力无边。你以为你删除了元素&lt;code&gt;3&lt;/code&gt;，实际上你的代码是删除第三个元素……&lt;/p&gt;
&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://chanthuang.github.io/2016/09/07/java-autoboxing-and-unboxing/&#34;&gt;Java 的自动装箱(autoboxing)与拆箱(unboxing) &lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
- https://ntutn.top/posts/java%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1%E8%87%AA%E5%8A%A8%E6%8B%86%E7%AE%B1%E8%B8%A9%E5%9D%91/ - CC BY-SA 4.0</description>
        </item>
    
    
    
        <item>
        <title>记Lenovo V310 15 IKB的第n次死机</title>
        <link>https://ntutn.top/posts/%E8%AE%B0lenovo_v310_15_ikb%E7%9A%84%E7%AC%ACn%E6%AC%A1%E6%AD%BB%E6%9C%BA/</link>
        <pubDate>Wed, 01 Jan 2020 03:11:37 +0800</pubDate>
        
        <guid>https://ntutn.top/posts/%E8%AE%B0lenovo_v310_15_ikb%E7%9A%84%E7%AC%ACn%E6%AC%A1%E6%AD%BB%E6%9C%BA/</guid>
        <description>归零幻想 https://ntutn.top/posts/%E8%AE%B0lenovo_v310_15_ikb%E7%9A%84%E7%AC%ACn%E6%AC%A1%E6%AD%BB%E6%9C%BA/ -&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;今天我的电脑又死机了，首先切一下&lt;strong&gt;tty进不去&lt;/strong&gt;，然后试下&lt;strong&gt;SysRq键没反应&lt;/strong&gt;，熟练地按住电源10秒，松开两秒，再按一下，拿出手机刷会空间。&lt;/p&gt;
&lt;p&gt;这电脑刚买的时候给我的印象其实是不错的，虽然外壳线条有点&lt;del&gt;丑&lt;/del&gt;粗犷，但整体性能比我预期要好很多。i5的CPU，1T机械硬盘，入门级Radeon独显，毕竟价格摆在那里。&lt;/p&gt;
&lt;p&gt;因为没有固态硬盘，这电脑慢的很，但我安慰自己&lt;strong&gt;反正我也不怎么打游戏&lt;/strong&gt;。日常尽量不用UWP应用，开机刷会手机，佛系一点也没什么不好。谁说学软件就一定要用好电脑？Code Blocks不香吗？eclipse有几个电脑带不动？实在偶尔想配置安卓开发环境的时候就连自己安卓手机做测试，至于VS就不用想了，虽然号称世界上最好用的IDE，但比较新的版本&lt;strong&gt;没有固态硬盘反应跟不上打字&lt;/strong&gt;……&lt;/p&gt;
&lt;p&gt;本来也就这样了，一分钱一分货的事。但直到某次电脑毫无征兆死机……&lt;/p&gt;
&lt;p&gt;死机是正常现象，没什么好怕的。我这样告诉自己。我当时正在浏览网页&lt;del&gt;不要多想，不是那种满屏都是澳门首家线上赌场广告的网页&lt;/del&gt;，毫无征兆就死机了。一般来说，所谓死机多是资源占用过高系统失去响应的原因，根据自己的经验，按组合键尝试调出任务管理器尝试结束进程，然后没有成功。貌似死机很彻底，任务管理器根本无法调出，甚至鼠标都不能动。我放下电脑，看了集哆啦A梦，回头看电脑屏幕没有要变化的征兆。没办法，按住电源键强制关机吧。后面很久这个事情都没有再出现，我也就渐渐忘了。&lt;/p&gt;
&lt;p&gt;直到又有一天，在我玩《狂野飙车8：极速凌云》正高兴的时候，画面突然不动了。这扫兴的事让我没了继续玩的兴致，而后几天又死机几次，我觉得事情没有那么简单，在网上搜索时，我发现我这不是个例。&lt;/p&gt;
&lt;p&gt;之后我加固态硬盘装双系统，死机就跟着我到了ubuntu。一般来说，ubuntu死机多是指gnome卡死，直接Alt+F2输入r就能重启，不这样做也可以切tty进入命令操作，直到某次放歌的时候死机了，歌声都停了，别说tty了，连SysRq键都没能正常工作，这表明连linux内核都死掉了。好吧，现在有足够证据表明死机不是Windows的锅。&lt;/p&gt;
&lt;p&gt;想把电脑送去修，但很麻烦的是，这个问题复现很困难，死机是不定期的，似乎跟资源占用无关，跟电脑温度无关。先不考虑电脑店能不能找到原因，就算电脑店说修好了，我也没办法验证。我觉得就这样送去修最大可能就算店家给你重装了下系统，清了下灰，升级了下BIOS，这些我都试过了没有用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;后来一直没有解决这件事，只是我养成了随手Ctrl+S的习惯。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;不管怎样，今天偶发性的连续死机两次惹恼我了，联想会进我的黑名单。&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
- https://ntutn.top/posts/%E8%AE%B0lenovo_v310_15_ikb%E7%9A%84%E7%AC%ACn%E6%AC%A1%E6%AD%BB%E6%9C%BA/ - CC BY-SA 4.0</description>
        </item>
    
    
    
        <item>
        <title>计算机操作系统原理笔记</title>
        <link>https://ntutn.top/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/</link>
        <pubDate>Tue, 10 Dec 2019 03:11:37 +0800</pubDate>
        
        <guid>https://ntutn.top/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/</guid>
        <description>归零幻想 https://ntutn.top/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/ -&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;操作系统快考试了，我觉得自己过应该还是没问题的吧，毕竟也有认真听课。虽然对某些部分流程记忆有点发憷。&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;h2 id=&#34;操作系统做什么&#34;&gt;操作系统做什么&lt;/h2&gt;
&lt;h3 id=&#34;操作系统是用户与计算机硬件之间的接口&#34;&gt;操作系统是用户与计算机硬件之间的接口&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;用户&lt;/strong&gt; 指包括最终用户在内的各级用户。&lt;/p&gt;
&lt;h3 id=&#34;操作系统的发展&#34;&gt;操作系统的发展&lt;/h3&gt;
&lt;h4 id=&#34;微机操作系统&#34;&gt;微机操作系统&lt;/h4&gt;
&lt;p&gt;个人机操作系统。&lt;/p&gt;
&lt;h4 id=&#34;实时操作系统&#34;&gt;实时操作系统&lt;/h4&gt;
&lt;p&gt;支持实时计算的系统，实时计算即 &lt;strong&gt;系统的正确性不仅取决于计算的逻辑结果，而且还依赖于产生结果的时间。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;实时任务的类型&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;周期性实时任务&lt;/li&gt;
&lt;li&gt;非周期性实时任务&lt;/li&gt;
&lt;li&gt;硬实时任务&lt;/li&gt;
&lt;li&gt;软实时任务&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;实时计算机可以不运行实时操作系统，直接运行应用软件&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;高可用性&lt;/li&gt;
&lt;li&gt;截止时间
&lt;ul&gt;
&lt;li&gt;开始截止时间&lt;/li&gt;
&lt;li&gt;实际截止时间&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;单道批处理系统&#34;&gt;单道批处理系统&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;自动性&lt;/li&gt;
&lt;li&gt;顺序性&lt;/li&gt;
&lt;li&gt;单道性&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;优点&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;减少人工等待时间&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;缺点&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;作业独占CPU&lt;/li&gt;
&lt;li&gt;&lt;em&gt;CPU等待IO使得CPU利用率低&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;多道批处理系统&#34;&gt;多道批处理系统&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;多道性&lt;/li&gt;
&lt;li&gt;无序性&lt;/li&gt;
&lt;li&gt;调度性&lt;/li&gt;
&lt;li&gt;复杂性&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;优点&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;提高CPU利用率&lt;/li&gt;
&lt;li&gt;提高内存和IO利用率&lt;/li&gt;
&lt;li&gt;增加系统吞吐量&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;吞吐量：单位时间里系统处理的作业量
&lt;strong&gt;缺点&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;平均等待周期长&lt;/li&gt;
&lt;li&gt;缺乏交互能力&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;分时系统&#34;&gt;分时系统&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;多路性&lt;/li&gt;
&lt;li&gt;独立性&lt;/li&gt;
&lt;li&gt;及时性&lt;/li&gt;
&lt;li&gt;交互性&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;优点&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;提供人机交互&lt;/li&gt;
&lt;li&gt;多终端共享主机&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;关键问题&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;及时接收用户的命令和顺序&lt;/li&gt;
&lt;li&gt;及时处理用户的命令。 &lt;em&gt;使所有的用户作业都进入内存，在很短的的时间内使每个作业都运行一次&lt;/em&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;操作系统产品现状&#34;&gt;操作系统产品现状&lt;/h3&gt;
&lt;h4 id=&#34;嵌入式操作系统&#34;&gt;嵌入式操作系统&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;嵌入式系统&lt;/strong&gt; 是宿主于非计算机设备的操作系统。 &lt;strong&gt;嵌入式操作系统&lt;/strong&gt; 是运行于嵌入式系统中的操作系统。&lt;/p&gt;
&lt;h4 id=&#34;掌上计算机操作系统&#34;&gt;掌上计算机操作系统&lt;/h4&gt;
&lt;p&gt;PDA&lt;/p&gt;
&lt;h4 id=&#34;实时操作系统-1&#34;&gt;实时操作系统&lt;/h4&gt;
&lt;p&gt;在资源调度、中断处理等方面的设计和实现要充分考虑系统对时间都限制。应用领域如 &lt;em&gt;自动控制、军事指挥系统、民用航空管理等&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;与嵌入式系统在分类上有一定重叠，有一定时限要求，在设计和实现上也有一些共同的特点， &lt;strong&gt;专用性、规模小、实时性、高可靠性&lt;/strong&gt; 。&lt;/p&gt;
&lt;h3 id=&#34;操作系统的特征&#34;&gt;操作系统的特征&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;支持多任务的操作系统&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;并发 同一时间间隔执行多个任务&lt;/li&gt;
&lt;li&gt;共享&lt;/li&gt;
&lt;li&gt;虚拟&lt;/li&gt;
&lt;li&gt;异步&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;操作系统功能&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;内存管理功能&lt;/li&gt;
&lt;li&gt;进程管理功能&lt;/li&gt;
&lt;li&gt;设备管理功能&lt;/li&gt;
&lt;li&gt;文件管理功能&lt;/li&gt;
&lt;li&gt;用户接口&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;内存管理功能&#34;&gt;内存管理功能&lt;/h4&gt;
&lt;h5 id=&#34;内存分配&#34;&gt;内存分配&lt;/h5&gt;
&lt;h5 id=&#34;内存保护&#34;&gt;内存保护&lt;/h5&gt;
&lt;p&gt;每个进程在自己的进程空间。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;界限寄存器&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&#34;地址映射&#34;&gt;地址映射&lt;/h5&gt;
&lt;blockquote&gt;
&lt;p&gt;地址映射是硬件和操作系统配合完成的。
把进程的逻辑地址转换成内存上的物理地址。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;逻辑地址&lt;/strong&gt; ：程序中的地址是从某一地址开始，相对于起始地址计算的，称为逻辑地址。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;物理地址&lt;/strong&gt; 由内存中的一系列单元所限定的地址范围称为 &lt;em&gt;内存空间&lt;/em&gt; ，其中的地址被称为物理地址。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;obj文件中逻辑地址是从0开始的，exe中的不是。
编译系统形成逻辑地址原因：编译器并不知道操作系统会将程序载入内存的实际物理地址。
中断发生时，保存现场，PC的值已经指向下一条指令，待中断返回时继续执行下一条指令。
变长指令集，PC+1时根据当前指令的长度决定PC递增的值&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&#34;内存扩充&#34;&gt;内存扩充&lt;/h5&gt;
&lt;p&gt;虚拟技术。&lt;/p&gt;
&lt;h5 id=&#34;内存回收&#34;&gt;内存回收&lt;/h5&gt;
&lt;p&gt;将进程占据的内存空间标记为空闲。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;OS内核：在特权集下运行的程序。（除此之外，还有接口，在非特权集运行，如shell）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;进程管理功能&#34;&gt;进程管理功能&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;进程控制&lt;/li&gt;
&lt;li&gt;进程同步&lt;/li&gt;
&lt;li&gt;进程通信&lt;/li&gt;
&lt;li&gt;进程调度&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;设备管理&#34;&gt;设备管理&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;缓冲管理：管理各种缓冲区&lt;/li&gt;
&lt;li&gt;设备分配：分配用户IO需要的设备&lt;/li&gt;
&lt;li&gt;设备处理：由设备驱动程序实现CPU与设备控制器之间的通信&lt;/li&gt;
&lt;li&gt;设备独立性&lt;/li&gt;
&lt;li&gt;虚拟设备：应用程序无需关注设备品牌等细节&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;文件管理功能&#34;&gt;文件管理功能&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;文件等按名访问&lt;/li&gt;
&lt;li&gt;文件等存储&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;提供用户接口&#34;&gt;提供用户接口&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;shell运行于用户态。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;命令接口&lt;/li&gt;
&lt;li&gt;图形接口：采用图形化的操作界面&lt;/li&gt;
&lt;li&gt;程序接口：由一组系统调用组成&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;软件的体系结构&#34;&gt;软件的体系结构&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;为什么要研究软件的体系结构&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;使软件模块更清晰，提高开发效率，更好测试、维护和移植，（提高软件运行的速度）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;操作系统的体系结构&#34;&gt;操作系统的体系结构&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;微内核优点：移植性好&lt;/li&gt;
&lt;li&gt;缺点：运行效率低一点&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;指令的执行&#34;&gt;指令的执行&lt;/h3&gt;
&lt;h4 id=&#34;取指令与执行指令&#34;&gt;取指令与执行指令&lt;/h4&gt;
&lt;h5 id=&#34;取指令&#34;&gt;取指令&lt;/h5&gt;
&lt;p&gt;每个指令周期开始时，处理器从&lt;strong&gt;内存&lt;/strong&gt;中取一条指令。程序计数器&lt;strong&gt;PC&lt;/strong&gt;保存有下一次要取的指令的地址。取指令后PC递增。&lt;/p&gt;
&lt;h5 id=&#34;执行指令&#34;&gt;执行指令&lt;/h5&gt;
&lt;p&gt;取到的指令放置于&lt;strong&gt;IR&lt;/strong&gt;中，处理器解释指令并执行动作。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;一条语句常对应多条指令。
程序执行过程反复取指令执行指令（硬件完成）
指令执行结果是使寄存器或内存单元值变化
保存现场（硬件隐指令）不需要保存内存的内容。内存有隔离措施，保证中断后内存内容不变。恢复现场由操作系统完成（恢复AC等值）。
隐指令：在机器指令系统中没有的，对用户来说是不可见的，完成特定功能的指令，如中断隐指令。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;进程同步&#34;&gt;进程同步&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;操作系统快考试了，我觉得自己过应该还是没问题的吧，毕竟也有认真听课。虽然对某些部分流程记忆有点发憷。
[tag]:操作系统|笔记&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;进程同步的基本概念&#34;&gt;进程同步的基本概念&lt;/h3&gt;
&lt;p&gt;进程同步的任务：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在资源共享的情况下：保证诸进程以互斥方式访问&lt;/li&gt;
&lt;li&gt;在相互合作的情况下：保证诸进程协调执行。相互合作进程可能存在资源共享的情况。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;临界资源：必须以互斥方式访问的共享资源。&lt;/li&gt;
&lt;li&gt;临界区：每个进程总访问共享资源的那段代码&lt;/li&gt;
&lt;li&gt;进入区：检查是否可以进入“临界区”并对临界区“加锁”的代码&lt;/li&gt;
&lt;li&gt;退出区：释放临界区访问权的代码&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;同步机制应遵循准则&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;空闲让进&lt;/li&gt;
&lt;li&gt;忙则等待&lt;/li&gt;
&lt;li&gt;有限等待&lt;/li&gt;
&lt;li&gt;让权等待&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;整型信号量机制&#34;&gt;整型信号量机制&lt;/h3&gt;
&lt;h4 id=&#34;整型信号量&#34;&gt;整型信号量&lt;/h4&gt;
&lt;p&gt;整型信号量是表示共享资源状态 &lt;strong&gt;只能由特殊的原子操作(wait和signal)改变&lt;/strong&gt; 的整型量。&lt;/p&gt;
&lt;p&gt;整型量&amp;gt;0说明有可用资源。&lt;/p&gt;
&lt;h4 id=&#34;wait和signal操作pv操作&#34;&gt;wait和signal操作（P－V操作）&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;var s:integer;
wait(s){
	while s&amp;lt;=0 do no-op;//申请不到资源做空操作
	s=s-1;
}
signal(s){
	s=s+1;
}
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;思考：开关中断应该怎样加？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;整型信号量应用举例&#34;&gt;整型信号量应用举例&lt;/h4&gt;
&lt;p&gt;临界资源由程序员界定，需要为每种临界资源分别定义一种互斥信号量。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;缺陷：不能实现让权等待。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;记录型信号量机制&#34;&gt;记录型信号量机制&lt;/h3&gt;
&lt;h4 id=&#34;数据类型&#34;&gt;数据类型&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;Type semaphore=record
	Value:integer//资源数量
	L:list of process//阻塞队列（PCB）
end
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;考：记录型信号量、wait和singial操作&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;wait和signal操作&#34;&gt;wait和signal操作&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;prodcedure wait(s)
	var s:semaphore;
	begin
		s.value=s.value-1;
		if s.value&amp;lt;0 then block(s.L);
	end
procedure signal(s)
	var s:semaphore;
	begin
		s.value=s.value+1;
		if s.value&amp;lt;=0 then wakeup(s.L);
	end
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;被阻塞的是调用wait申请资源的进程（自我阻塞）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;利用记录型信号量实现互斥&#34;&gt;利用记录型信号量实现互斥&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;var s:semaphore;
	s.value=1;
begin
	repat
		wait(s);
			critical section;
		signal(s);
		reminder section;
	until false;
end
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;先唤醒哪个进程取决于操作系统，如果使用优先权，尽量不使用静态优先权。&lt;/p&gt;
&lt;h4 id=&#34;利用记录型信号量实现协调的应用举例&#34;&gt;利用记录型信号量实现“协调”的应用举例&lt;/h4&gt;
&lt;p&gt;设置两个信号量&lt;code&gt;var empty,full:semaphore&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;初始：empty.value=2,full.value=0&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入进程：
{
	从外存读数据;
	wait(empty)
	往缓冲区放数据
	signal(full)
}
计算进程：
{
	wait(full);
	从缓冲区读取数据
	signal(empty)
	处理数据
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;管程&#34;&gt;管程&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;管程由编译器提供支持。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;进程调度&#34;&gt;进程调度&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;操作系统快考试了，我觉得自己过应该还是没问题的吧，毕竟也有认真听课。虽然对某些部分流程记忆有点发憷。
[tag]:操作系统|笔记&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;操作系统的进程调度功能由进程调度程序完成
什么时候操作系统会进行进程调度？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;进程阻塞
时间片用完
程序正常或异常结束
中断返回
高优先权进程到来&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;调度算法&#34;&gt;调度算法&lt;/h3&gt;
&lt;p&gt;周转时间=服务时间+等待时间&lt;/p&gt;
&lt;p&gt;平均周转时间=总周转时间/进程数&lt;/p&gt;
&lt;p&gt;带权周转时间=服务时间/等待时间&lt;/p&gt;
&lt;p&gt;平均带权周转时间=总带权周转时间/进程数&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;立即抢占：高优先级进程立即执行的最小时间单位可以是每执行完一条指令。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;先来先服务fcfs&#34;&gt;先来先服务（FCFS）&lt;/h4&gt;
&lt;p&gt;适合长作业，不利于短作业。有利于CPU繁忙型作业，不利于I/O繁忙型作业。&lt;/p&gt;
&lt;h4 id=&#34;短作业进程优先&#34;&gt;短作业（进程）优先&lt;/h4&gt;
&lt;p&gt;短作业优先SJF&lt;/p&gt;
&lt;p&gt;短进程优先SPF&lt;/p&gt;
&lt;p&gt;有效缩短作业和进程的平均等待时间，提高系统吞吐量。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;缺陷&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;对长作业和长进程不利，如果系统中不断有短作业和短进程到来，则长作业及长进程可能长时间得不到调度。&lt;/li&gt;
&lt;li&gt;不能保证紧迫作业和进程的及时处理&lt;/li&gt;
&lt;li&gt;作业和进程的长短由用户的估算，不一定能真正做到短进程或短作业优先&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;与先来先服务相比，能缩短系统的平均周转时间和平均带权周转时间。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;优先权调度算法&#34;&gt;优先权调度算法&lt;/h4&gt;
&lt;p&gt;实时系统中非阻塞式难以保证高优先权进程得到及时调度，因此主要用于批处理系统。&lt;/p&gt;
&lt;p&gt;静态优先权存在进程饥饿问题，使用 &lt;strong&gt;老化&lt;/strong&gt; 技术动优先权避免这个问题。&lt;/p&gt;
&lt;h4 id=&#34;时间片轮转算法&#34;&gt;时间片轮转算法&lt;/h4&gt;
&lt;p&gt;进程需要在CPU上运行的时间可能小于一个时间片，也可能大于一个时间片。对于进程的时间区间小于一个时间片的情况，进程在CPU上运行结束本身会自动释放CPU，然后由操作系统执行进程调度程序为另一个就绪进程分配CPU；对于进程的时间区间大于一个时间片的情况，进程可能执行若干时间片，每当进程在CPU上连续运行的时间等于一个时间片长度时，操作系统在 &lt;strong&gt;时钟中断处理过程&lt;/strong&gt; 中就会抢占CPU，进行进程切换，用新的就绪进程替代当前进程，而被替换的当前进程则重新回到就绪队列中。&lt;/p&gt;
&lt;h5 id=&#34;时间片大型的确定&#34;&gt;时间片大型的确定&lt;/h5&gt;
&lt;p&gt;时间片太长，那么进程看上去就不是并发执行的；时间片太短，频繁切换进程上下文影响效率。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在系统允许的最大进程数一定的情况下，时间片的长短取决于系统要求的响应时间，且响应时间越短，时间片取值应该越小。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;时间片轮转需要的硬件软件：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;硬件：可编程间隔定时器、可编程中断控制器
软件：PCB中记录在CPU上运行剩余时间都字段、时钟中断处理程序、中断处理程序&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;多级队列调度算法&#34;&gt;多级队列调度算法&lt;/h4&gt;
&lt;p&gt;将就绪队列分为多个独立队列……&lt;/p&gt;
&lt;p&gt;课本p100&lt;/p&gt;
&lt;h3 id=&#34;参考&#34;&gt;参考&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/tobe98/article/details/101632841&#34;&gt;进程调度，一个调度器的自白&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;死锁&#34;&gt;死锁&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;操作系统快考试了，我觉得自己过应该还是没问题的吧，毕竟也有认真听课。虽然对某些部分流程记忆有点发憷。
[tag]:操作系统|笔记&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;产生死锁的原因和必要条件&#34;&gt;产生死锁的原因和必要条件&lt;/h3&gt;
&lt;h4 id=&#34;产生死锁的原因&#34;&gt;产生死锁的原因&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;竞争共享资源&lt;/li&gt;
&lt;li&gt;进程推进顺序不当&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;产生死锁的必要条件&#34;&gt;产生死锁的必要条件&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;互斥条件 一个进程在访问某资源的过程中，其他进程不能访问该资源&lt;/li&gt;
&lt;li&gt;请求和保持条件 进程提出新的资源请求，被阻塞，但不释放已经保持的资源&lt;/li&gt;
&lt;li&gt;不剥夺条件 进程已经获得的资源不能被剥夺，只能由进程自己释放&lt;/li&gt;
&lt;li&gt;环路等待条件 必然存在一个进程申请资源的环形链，互相等待对方占用的资源&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;只有上述四个条件同时满足时才会发生死锁。&lt;/p&gt;
&lt;h3 id=&#34;处理死锁的基本方法&#34;&gt;处理死锁的基本方法&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;预防死锁&lt;/li&gt;
&lt;li&gt;避免死锁&lt;/li&gt;
&lt;li&gt;检测并解除死锁&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;忽略死锁问题，认为死锁不可能在系统内发生&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;认为死锁不可能发生是一个经验、统计规律。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;死锁的预防&#34;&gt;死锁的预防&lt;/h4&gt;
&lt;p&gt;摒弃三个必要条件之一。&lt;/p&gt;
&lt;h5 id=&#34;摒弃请求和保持条件&#34;&gt;摒弃请求和保持条件&lt;/h5&gt;
&lt;p&gt;系统要求所有进程在执行前要一次性地申请整个运行过程中所需要的全部资源，只要有一个资源申请不成功，其他所有的资源就不分配给该进程,并阻塞该进程。&lt;/p&gt;
&lt;h5 id=&#34;摒弃不剥夺条件&#34;&gt;摒弃不剥夺条件&lt;/h5&gt;
&lt;p&gt;一个已经保持了某些资源的进程，当它再提出新的资源要求而不能立即得到满足时，必须释放它已经保持的所有资源。&lt;/p&gt;
&lt;h5 id=&#34;摒弃环路等待条件&#34;&gt;摒弃环路等待条件&lt;/h5&gt;
&lt;p&gt;规定进程必须按一定顺序申请资源。&lt;/p&gt;
&lt;h4 id=&#34;参考-1&#34;&gt;参考&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.jianshu.com/p/99f10708b1e1#&#34;&gt;哲学家就餐问题与死锁总结&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;死锁的避免&#34;&gt;死锁的避免&lt;/h4&gt;
&lt;p&gt;把系统的资源分配状态分为 &lt;strong&gt;安全状态&lt;/strong&gt; 和 &lt;strong&gt;不安全状态&lt;/strong&gt; ，只要资源分配使系统处于安全状态，死锁就不会发生。&lt;/p&gt;
&lt;h4 id=&#34;利用银行家算法避免死锁&#34;&gt;利用银行家算法避免死锁&lt;/h4&gt;
&lt;p&gt;一个进程提出资源请求后，系统先进行资源的试分配，然后检测本次的试分配是否使系统处于安全状态，若安全，则按试分配方案分配资源，否则不分配资源。&lt;/p&gt;
&lt;p&gt;安全状态：能找到一个执行序列分配资源。（满足最大需求后进程释放资源）&lt;/p&gt;
&lt;p&gt;系统处于安全状态时， &lt;strong&gt;一定不会发生死锁&lt;/strong&gt; ，进入不安全状态 &lt;strong&gt;未必会发生死锁&lt;/strong&gt; ，发生死锁 &lt;strong&gt;一定是进入了不安全状态&lt;/strong&gt; 。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;available[]&lt;/code&gt; 是个一维数组，表示系统中某种资源的可用数量。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;max[]&lt;/code&gt; 是个二维数组，表示各进程需要各类资源的最大数量，如&lt;code&gt;max[i,j]=k&lt;/code&gt;表示进程pi需要j类资源的最大数量为k。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;allocation[]&lt;/code&gt; 是个二维数组，表示某时刻已分配给进程的某类资源数，如&lt;code&gt;allocation[i,j]=k&lt;/code&gt; 表示进程pi已经占有j类资源k个。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;need[]&lt;/code&gt; 是二维数组，表示某个进程还需要多少个某类资源，如&lt;code&gt;need[i,j]=k&lt;/code&gt;表示进程pi还需要j类资源k个。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;该算法缺乏实用价值，因为很少有进程能够在运行之前就知道其所需资源的最大值，而且进程数不是固定的，往往在不断变化，原本可用的资源也可能在突然之间变成不可用。&lt;/p&gt;
&lt;h4 id=&#34;死锁的检测和解除&#34;&gt;死锁的检测和解除&lt;/h4&gt;
&lt;p&gt;操作系统可以不采取预防和避免的方法来解决死锁问题，而是检测是否有死锁发生，如果检测到系统中有死锁的进程，则解除死锁。&lt;/p&gt;
&lt;p&gt;应用检测死锁算法必须面对的问题是 &lt;strong&gt;何时调用检测算法&lt;/strong&gt; 及 &lt;strong&gt;如何检测死锁&lt;/strong&gt; 。
资源分配图：进程指向资源是资源请求边，资源指向进程是资源分配边。&lt;/p&gt;
&lt;p&gt;死锁定理用于检测系统所处的 &lt;strong&gt;资源分配状态&lt;/strong&gt; S是否为 &lt;strong&gt;死锁状态&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;S为死锁状态&amp;lt;=&amp;gt;S状态的资源分配图是不可完全简化的&lt;/p&gt;
&lt;p&gt;解除死锁的途径有两个：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;终止处于死锁状态的进程&lt;/li&gt;
&lt;li&gt;抢占死锁进程占有的资源&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;系统中不会出现单个进程死锁的情况，但会出现只有一个进程饥饿的情况。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;存储器管理&#34;&gt;存储器管理&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;操作系统快考试了，我觉得自己过应该还是没问题的吧，毕竟也有认真听课。虽然对某些部分流程记忆有点发憷。
[tag]:操作系统|笔记&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;存储器的层次结构&#34;&gt;存储器的层次结构&lt;/h3&gt;
&lt;p&gt;局部性原理&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;程序执行时，除少部分的转移和过程调用外，大多数情况下是按顺序执行的。&lt;/li&gt;
&lt;li&gt;过程调用会使程序的执行轨迹由一部分内存区域转到另一部分内存区域。但研究表明，在大多数情况下过程调用的深度都不超过5，也就是说，程序将会在一段时间内局限在很小的范围内。&lt;/li&gt;
&lt;li&gt;程序中存在很多循环结构，它们虽然由少数指令构成，但需要多次执行。&lt;/li&gt;
&lt;li&gt;程序中往往包括许多对数据结构的处理，它们往往局限在很小的范围内。&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;少用goto：goto破坏程序的局部性。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;程序的装入和链接&#34;&gt;程序的装入和链接&lt;/h3&gt;
&lt;p&gt;高级语言程序必须经过 &lt;strong&gt;编译&lt;/strong&gt; 、 &lt;strong&gt;链接&lt;/strong&gt; 才能为之成为可执行程序，可执行程序必须被操作系统 &lt;strong&gt;装入&lt;/strong&gt; 内存才能执行。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;交叉编译：开发平台不同于目标平台。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;程序的装入&#34;&gt;程序的装入&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;绝对装入方式&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在编译时形成物理地址&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可重定位装入方式（静态重定位）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;装入时形成物理地址&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;动态运行时装入方式&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;运行时形成物理地址（运行时才进行物理映射），逻辑地址在PC中。&lt;/p&gt;
&lt;p&gt;需要 &lt;strong&gt;重定位寄存器&lt;/strong&gt; 的支持。&lt;/p&gt;
&lt;h4 id=&#34;程序的链接&#34;&gt;程序的链接&lt;/h4&gt;
&lt;h5 id=&#34;链接要解决的问题&#34;&gt;链接要解决的问题&lt;/h5&gt;
&lt;p&gt;将编译后的目标模块装配成一个可执行的程序。&lt;/p&gt;
&lt;h5 id=&#34;链接的两种方式&#34;&gt;链接的两种方式&lt;/h5&gt;
&lt;h6 id=&#34;静态链接&#34;&gt;静态链接&lt;/h6&gt;
&lt;ul&gt;
&lt;li&gt;静态链接 在程序运行前，用链接程序将目标模块链接成一个完整的装入模块。&lt;/li&gt;
&lt;li&gt;静态链接的任务
&lt;ul&gt;
&lt;li&gt;对相对地址进行修改&lt;/li&gt;
&lt;li&gt;变换外部调用符号&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;存储开销大&lt;/li&gt;
&lt;li&gt;程序开发不方便&lt;/li&gt;
&lt;li&gt;程序运行相对于动态链接快&lt;/li&gt;
&lt;/ol&gt;
&lt;h6 id=&#34;动态链接&#34;&gt;动态链接&lt;/h6&gt;
&lt;ol&gt;
&lt;li&gt;节省内存和外存空间&lt;/li&gt;
&lt;li&gt;方便程序开发&lt;/li&gt;
&lt;li&gt;程序运行时的速度变慢&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;连续存储管理方式&#34;&gt;连续存储管理方式&lt;/h3&gt;
&lt;h4 id=&#34;单一连续分配&#34;&gt;单一连续分配&lt;/h4&gt;
&lt;p&gt;把内存分为系统区和用户区。&lt;/p&gt;
&lt;h4 id=&#34;固定分区分配&#34;&gt;固定分区分配&lt;/h4&gt;
&lt;p&gt;固定分区分配的 &lt;strong&gt;用户分区数量&lt;/strong&gt; 是固定的， &lt;strong&gt;每个分区的大小&lt;/strong&gt; 也是固定的，其大小可以相等也可以不想等。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;分区编号&lt;/li&gt;
&lt;li&gt;分区大小&lt;/li&gt;
&lt;li&gt;分区起始地址&lt;/li&gt;
&lt;li&gt;分区状态&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;在PCB中记录分配的分区的起始地址&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;固定分区的特点&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;管理简单&lt;/li&gt;
&lt;li&gt;内存利用率低&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;记录和维护空闲分区情况数据结构，常用空闲分区表、空闲分区链表。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;作业：写一个分配分区的程序，打印版。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;动态分区分配&#34;&gt;动态分区分配&lt;/h4&gt;
&lt;h5 id=&#34;首次适应算法&#34;&gt;首次适应算法&lt;/h5&gt;
&lt;p&gt;空闲分区地址递增，链首顺序查找，找出能满足要求的第一个。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;高地址部分大空闲区较多&lt;/li&gt;
&lt;li&gt;低地址部分容易留下小分区&lt;/li&gt;
&lt;li&gt;查找时间开销大&lt;/li&gt;
&lt;/ol&gt;
&lt;h5 id=&#34;循环首次适应&#34;&gt;循环首次适应&lt;/h5&gt;
&lt;p&gt;不再从头开始查找，从上次找到的位置开始查找。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;空闲空间分配均匀&lt;/li&gt;
&lt;li&gt;查找开销较小&lt;/li&gt;
&lt;li&gt;容易使系统缺乏较大空闲分区&lt;/li&gt;
&lt;/ol&gt;
&lt;h5 id=&#34;最佳适应算法&#34;&gt;最佳适应算法&lt;/h5&gt;
&lt;p&gt;空闲分区大小递增，返回满足条件，最小的第一个。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;避免大材小用，提高内存利用率&lt;/li&gt;
&lt;li&gt;容易留下难以利用的小空闲区&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;问题&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;考虑回收否？
起始大小、状态
代码行数、链表&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;h5 id=&#34;回收&#34;&gt;回收&lt;/h5&gt;
&lt;p&gt;修改分区大小，（删除多余的节点）&lt;/p&gt;
&lt;h5 id=&#34;紧凑&#34;&gt;紧凑&lt;/h5&gt;
&lt;p&gt;将多个空闲分区拼接成连续大空闲分区。&lt;/p&gt;
&lt;h3 id=&#34;基本分页管理方式&#34;&gt;基本分页管理方式&lt;/h3&gt;
&lt;p&gt;离散的内存管理方式&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;分页存储管理&lt;/li&gt;
&lt;li&gt;分段存储管理&lt;/li&gt;
&lt;li&gt;段页式存储管理&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;分页存储管理的方式&#34;&gt;分页存储管理的方式&lt;/h4&gt;
&lt;h5 id=&#34;基本概念&#34;&gt;基本概念&lt;/h5&gt;
&lt;ol&gt;
&lt;li&gt;页 将一个进程的逻辑地址空间分为若干大小相等的片，称为页面或 &lt;strong&gt;页&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;物理块 将内存空间分成与页相同大小的若干存储块，称为 &lt;strong&gt;物理块&lt;/strong&gt; 或页框或帧&lt;/li&gt;
&lt;li&gt;分页存储 在为进程分配内存时，以块为单位将进程的若干页分别装入多个可不连续的块中&lt;/li&gt;
&lt;li&gt;页内碎片 进程的最后一页一般装不满一块，而形成不可利用的碎片，称为 &lt;strong&gt;页内碎片&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;（一级分页）逻辑地址由页号、页内偏移量构成。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;计算关系&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;32位系统中为高20位页号，低12位页内偏移。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在有关计算题中用二进制或十六进制表示。
页表建立页号和块号联系，但一般不必存页号，用块号顺序表示。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;页表在内存中连续存放，列表项长度固定（页表本身长度是页表项项数，页表项长度是页表项占字节数），页表寄存器中存储了页表起始地址和页表长度，由硬件检索页表得到访存实际地址。
一级分页下读数据要两次访存。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&#34;地址变换过程&#34;&gt;地址变换过程&lt;/h5&gt;
&lt;ol&gt;
&lt;li&gt;进程执行，PCB中页表起始地址送页表寄存器&lt;/li&gt;
&lt;li&gt;CPU访问逻辑单元a&lt;/li&gt;
&lt;li&gt;由分页地址变换机构自动将a分为页号和页内偏移&lt;/li&gt;
&lt;li&gt;由硬件检索机构搜索页表，得到物理块号&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;得到物理地址后，先查看高速缓存，如果命中直接取，未命中则去内存找。
&lt;strong&gt;页大小的选择&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;由机器的体系结构决定，亦由硬件决定&lt;/p&gt;
&lt;p&gt;页太小，进程所需页多，页表太长，占用大量内存空间；降低页换入换出效率。&lt;/p&gt;
&lt;p&gt;页太大，页内碎片大，内存利用率低。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;页的大小是2的幂&lt;/li&gt;
&lt;li&gt;一般页大小在512B~4K&lt;/li&gt;
&lt;li&gt;现在硬件可以支持多种不同的页大小&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;快表&#34;&gt;快表&lt;/h4&gt;
&lt;p&gt;快表是为了提高CPU访存速度而采用的专用缓存，用来存放 &lt;strong&gt;最近被访问过的页表项&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;有效减少访问页表时间。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;TLB命中，1次访问TLB时间+1次访问内存的时间&lt;/li&gt;
&lt;li&gt;TLB不命中，1次访问TLB时间+2次访问内存的时间&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;TLB每CPU一个。&lt;/p&gt;
&lt;h4 id=&#34;两级和多级分页&#34;&gt;两级和多级分页&lt;/h4&gt;
&lt;p&gt;页表寄存器中的值是外层页表的起始地址。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;二级分页中TLB存放什么？
外层页号、页表分页、进程页面&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;减少页表占用内存的方法：将当前所需要的页表和外层页表放在内存中，其余页表分页放在外存中，当所需的分页不在内存时，产生中断，将请求的页表调入内存。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;分段存储管理&#34;&gt;分段存储管理&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;段的逻辑地址
&lt;ul&gt;
&lt;li&gt;段号&lt;/li&gt;
&lt;li&gt;段内偏移&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;段表&#34;&gt;段表&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;页是按物理空间划分的，段是按逻辑空间划分的&lt;/li&gt;
&lt;li&gt;页大小固定，段大小不固定&lt;/li&gt;
&lt;li&gt;分页地址空间是一维的，程序员给出的只是一个助记符&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;虚拟内存管理&#34;&gt;虚拟内存管理&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;操作系统快考试了，我觉得自己过应该还是没问题的吧，毕竟也有认真听课。虽然对某些部分流程记忆有点发憷。
[tag]:操作系统|笔记&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;虚拟存储器概述&#34;&gt;虚拟存储器概述&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;提高内存利用率&lt;/li&gt;
&lt;li&gt;提高多道程序度&lt;/li&gt;
&lt;li&gt;把逻辑空间和物理空间分开&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;虚拟存储系统具有以下主要特征：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;离散型&lt;/li&gt;
&lt;li&gt;多次性&lt;/li&gt;
&lt;li&gt;对换性&lt;/li&gt;
&lt;li&gt;虚拟性&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;请求分页存储管理方式&#34;&gt;请求分页存储管理方式&lt;/h3&gt;
&lt;p&gt;运行过程中访存，若发现所访问的页面不在内存中，则产生一个缺页中断信号，系统响应缺页中断，请求调入缺页。若调入缺页时内存已满，则需要先从内存中选择一个或若干个页面换出到外存空间，以腾出内存空间容纳请求调入的缺页。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;系统通常不会等缺页中断再选择一页换出，而是有一个最小阈值，定期扫描&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;请求分页中的硬件支持&#34;&gt;请求分页中的硬件支持&lt;/h4&gt;
&lt;h5 id=&#34;页表机制&#34;&gt;页表机制&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;页号 作为地址映射时的索引&lt;/li&gt;
&lt;li&gt;物理块号 页面在物理内存中的物理块编号&lt;/li&gt;
&lt;li&gt;状态位P 用来标识页面是否在内存中&lt;/li&gt;
&lt;li&gt;访问字段A 用来记录页面最近被访问的情况&lt;/li&gt;
&lt;li&gt;修改位M 用于标识页面最近是否被修改过&lt;/li&gt;
&lt;li&gt;外存地址 用于指出页面在外存的地址&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;缺页中断机构&#34;&gt;缺页中断机构&lt;/h5&gt;
&lt;p&gt;在访存过程中发现缺页时产生的缺页中断信号，使CPU中断当前控制流的执行，转去执行操作系统的缺页中断处理程序。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;通过检查页表的存在位P，判断当前被访问的页是否在内存中，如果不在，则产生缺页中断信号。&lt;/li&gt;
&lt;li&gt;在内存中为请求调入的页找一个空闲物理块&lt;/li&gt;
&lt;li&gt;调磁盘操作，把需要的页装入找到的空闲物理块中&lt;/li&gt;
&lt;li&gt;修改页表，更新已经调入页的存在位、在内存中的物理块号、访问位等字段的值&lt;/li&gt;
&lt;li&gt;重新执行因缺页而被中断的指令&lt;/li&gt;
&lt;/ol&gt;
&lt;h5 id=&#34;地址变换机构&#34;&gt;地址变换机构&lt;/h5&gt;
&lt;ol&gt;
&lt;li&gt;由内存地址变换机构从线性逻辑地址中分离出页号和页内偏移地址&lt;/li&gt;
&lt;li&gt;以页号作为索引查找快表，若快表中存在该页的页表项，则读出物理块号，计算物理地址&lt;/li&gt;
&lt;li&gt;若快表中不存在该页的信息，则转到内存页表中查找。若页表中状态位P显示该页已经调入内存，则从响应的页表项读出页面所在的物理块号并计算物理地址，然后把该页表项写入快表&lt;/li&gt;
&lt;li&gt;若该页尚未调入内存，则产生缺页中断，请求OS把该页从外存中调入内存，然后修改页表，重新执行被中断的指令。&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;缺页中断一定产生于指令执行的过程中。缺页中断返回时执行原指令，而不是下一条指令。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;页面分配&#34;&gt;页面分配&lt;/h4&gt;
&lt;h5 id=&#34;最少物理块数&#34;&gt;最少物理块数&lt;/h5&gt;
&lt;p&gt;最少物理块数是指能保证进程正常运行所需要的最少物理块数。保证进程正常运行所需要的最少物理块数与 &lt;del&gt;进程的大小&lt;/del&gt; 无关，与 &lt;strong&gt;计算机的硬件结构&lt;/strong&gt; 有关，取决于指令的 &lt;strong&gt;格式&lt;/strong&gt; 、 &lt;strong&gt;功能&lt;/strong&gt; 和 &lt;strong&gt;寻址方式&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;指令本身涉及的页面、操作数部分的地址涉及的页面、操作数地址中存在的内存地址中可能涉及的地址……&lt;/p&gt;
&lt;h5 id=&#34;页面分配和置换策略&#34;&gt;页面分配和置换策略&lt;/h5&gt;
&lt;ol&gt;
&lt;li&gt;固定分配局部置换&lt;/li&gt;
&lt;li&gt;可变分配全局置换 广泛使用&lt;/li&gt;
&lt;li&gt;可变分配局部置换&lt;/li&gt;
&lt;/ol&gt;
&lt;h5 id=&#34;分配算法&#34;&gt;分配算法&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;平均分配算法&lt;/li&gt;
&lt;li&gt;按比例分配算法&lt;/li&gt;
&lt;li&gt;考虑优先权的分配算法&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;页面调入策略&#34;&gt;页面调入策略&lt;/h4&gt;
&lt;p&gt;当系统产生缺页中断时，调入请求页面的同时可以只把该页面进入内存，也可以同时把与该页相邻的页面调入内存。外存页面既可以存放在对换区，也可以存放在文件区。&lt;/p&gt;
&lt;h3 id=&#34;页面置换算法&#34;&gt;页面置换算法&lt;/h3&gt;
&lt;p&gt;页面置换算法是选择淘汰页的算法。&lt;/p&gt;
&lt;h4 id=&#34;最佳置换算法&#34;&gt;最佳置换算法&lt;/h4&gt;
&lt;p&gt;选择以后永远不会被访问的页面或最长时间不会再访问的页面。&lt;/p&gt;
&lt;h4 id=&#34;先进先出页面置换算法&#34;&gt;先进先出页面置换算法&lt;/h4&gt;
&lt;p&gt;选择进入内存最早的页面淘汰。&lt;/p&gt;
&lt;h4 id=&#34;最近最久未使用置换算法&#34;&gt;最近最久未使用置换算法&lt;/h4&gt;
&lt;p&gt;将最近最久未使用的页面予以淘汰。&lt;/p&gt;
&lt;p&gt;实现：&lt;/p&gt;
&lt;h5 id=&#34;寄存器&#34;&gt;寄存器&lt;/h5&gt;
&lt;p&gt;为每个内存中的页面配置一个移位寄存器，访问时最高位1，定时右移寄存器，最小数值的最久未使用。&lt;/p&gt;
&lt;h5 id=&#34;栈&#34;&gt;栈&lt;/h5&gt;
&lt;p&gt;访问时把页面号移出，压入栈顶，栈底为最久未使用的页面。&lt;/p&gt;
&lt;h5 id=&#34;计数器&#34;&gt;计数器&lt;/h5&gt;
&lt;p&gt;为每个页表项增加时间字段……&lt;/p&gt;
&lt;h4 id=&#34;lru的近似算法&#34;&gt;LRU的近似算法&lt;/h4&gt;
&lt;h5 id=&#34;附加引用位算法&#34;&gt;附加引用位算法&lt;/h5&gt;
&lt;p&gt;类寄存器方法。&lt;/p&gt;
&lt;h5 id=&#34;简单clock算法&#34;&gt;简单Clock算法&lt;/h5&gt;
&lt;p&gt;为每一页设置一位访问位，再将内存中的所有页面通过链接指针链接成循环队列。某页被访问时，访问位置1。按FIFO算法检查访问位，若为0，选择换出；若为1，重新置0，暂不换出。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;只考虑访问位，未考虑修改位。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&#34;改进型clock算法&#34;&gt;改进型Clock算法&lt;/h5&gt;
&lt;p&gt;A=0，M=0 最佳淘汰页
A=0，M=1 并不是很好的淘汰页
A=1，M=0 已访问，未修改
A=1，M=1 已访问，已修改&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;寻找A=0 M=0的，选中第一个&lt;/li&gt;
&lt;li&gt;第一步失败，寻找A=0，M=1的，选中第一个。所有经过的A置0&lt;/li&gt;
&lt;li&gt;回到开始位置，并将所有访问位A复0，重复第一步，失败则重复第二步&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;其他置换算法&#34;&gt;其他置换算法&lt;/h4&gt;
&lt;h5 id=&#34;最少使用置换算法&#34;&gt;最少使用置换算法&lt;/h5&gt;
&lt;p&gt;选择最近时期使用次数最少的页面作为淘汰页。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;实际实现与LRU通常相同。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&#34;页面缓冲算法&#34;&gt;页面缓冲算法&lt;/h5&gt;
&lt;p&gt;采用FIFO算法选择淘汰页，建立两个链表 空闲页面链表、已修改页面链表。&lt;/p&gt;
&lt;p&gt;没有被修改页面换出时实际不把它换出内存，而是把该页所在的物理块挂在空闲页链表的尾部。置换已修改页面，挂在已修改页面链表尾部。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;一般与其他分配算法配合使用。
缺页中断处理的性能受不受页缓冲机制的影响？
受影响，因为如果引入缓冲机制，缺失的页在内存中，就不必再到外存寻找，会加快处理速度。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;请求分页系统性能分析&#34;&gt;请求分页系统性能分析&lt;/h3&gt;
&lt;h4 id=&#34;缺页率对有效访问时间的影响&#34;&gt;缺页率对有效访问时间的影响&lt;/h4&gt;
&lt;h4 id=&#34;工作集&#34;&gt;工作集&lt;/h4&gt;
&lt;p&gt;把最近访问的页全部装入内存&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;W(t,Δ)&lt;/strong&gt; 工作集的窗口&lt;/p&gt;
&lt;p&gt;Δ为窗口尺寸，Δ太大，影响存储器利用率&lt;/p&gt;
&lt;p&gt;Δ太小，缺页率高，影响系统的吞吐量&lt;/p&gt;
&lt;h4 id=&#34;抖动&#34;&gt;抖动&lt;/h4&gt;
&lt;p&gt;多道程序度太高，使运行进程大部分时间都用于页换入换出，几乎不能完成任何有效工作的状态称为 &lt;strong&gt;抖动&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;预防&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;采用局部置换策略 进程缺页时，仅在自己内存空间范围置换页面&lt;/li&gt;
&lt;li&gt;在CPU调度程序中引入工作集算法 只有当每个进程在内存中都有足够大驻留集时，才能从外存调入新的作业&lt;/li&gt;
&lt;li&gt;L=S准则 调整多道程序度，以使发生缺页的平均时间L=系统处理缺页的平均时间S&lt;/li&gt;
&lt;li&gt;挂起若干进程 预防抖动，挂起若干进程，腾出进程占用的空间&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;文件系统&#34;&gt;文件系统&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;操作系统快考试了，我觉得自己过应该还是没问题的吧，毕竟也有认真听课。虽然对某些部分流程记忆有点发憷。
[tag]:操作系统|笔记&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;文件命名&#34;&gt;文件命名&lt;/h3&gt;
&lt;p&gt;文件命名向用户提供文件访问的抽象机制。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;大小写&lt;/li&gt;
&lt;li&gt;文件扩展名&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;文件结构&#34;&gt;文件结构&lt;/h4&gt;
&lt;h5 id=&#34;无结构字节序列&#34;&gt;无结构字节序列&lt;/h5&gt;
&lt;p&gt;也称 &lt;strong&gt;流式文件&lt;/strong&gt; ，操作系统不关心文件的内容是什么，它所见到的就是字节，含义由使用文件的程序自行理解。&lt;/p&gt;
&lt;h5 id=&#34;固定长度记录序列&#34;&gt;固定长度记录序列&lt;/h5&gt;
&lt;p&gt;构成文件的基本单位是具有固定长度的记录，每个记录都有其内部结构。读操作返回一个记录，写操作返回或追加一个记录。&lt;/p&gt;
&lt;h5 id=&#34;树形结构&#34;&gt;树形结构&lt;/h5&gt;
&lt;p&gt;文件由一颗记录树构成，记录长度不变，在记录的固定位置包含一个关键字域，记录树按 &lt;strong&gt;关键字域&lt;/strong&gt; 排序。基本操作是获取具有特定关键字的记录。增加记录时，由操作系统决定记录在文件中的存放位置。&lt;/p&gt;
&lt;h4 id=&#34;文件类型&#34;&gt;文件类型&lt;/h4&gt;
&lt;p&gt;文件的类型有 &lt;strong&gt;正规文件&lt;/strong&gt; 、 &lt;strong&gt;目录文件&lt;/strong&gt; 、 &lt;strong&gt;字符设备文件&lt;/strong&gt; 、 &lt;strong&gt;块设备文件&lt;/strong&gt; 等。正规文件包含用户信息，一般分为 &lt;strong&gt;ASCII文件&lt;/strong&gt; 和 &lt;strong&gt;二进制文件&lt;/strong&gt; 。&lt;/p&gt;
&lt;h5 id=&#34;ascii文件&#34;&gt;ASCII文件&lt;/h5&gt;
&lt;p&gt;由多行正文组成，在某些系统中，每行用 &lt;strong&gt;回车符&lt;/strong&gt; 结束，某些则用 &lt;strong&gt;换行符&lt;/strong&gt; 结束，有些系统还同时采用回车符和换行符。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;优势&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可以显示和打印&lt;/li&gt;
&lt;li&gt;可以使用通常的文本编辑器进行编辑&lt;/li&gt;
&lt;li&gt;程序使用ASCII文件输入输出可以很容易把一个程序的输出当做另一个程序的输入。&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;二进制文件&#34;&gt;二进制文件&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;具有一定的内部结构，只有使用该文件的程序才了解这种结构。&lt;/li&gt;
&lt;li&gt;通常的编辑器不能直接显示和打印二进制文件&lt;/li&gt;
&lt;li&gt;不同的操作系统可以识别不同的二进制文件，把某一种结构的二进制文件作为系统中的可执行文件。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;文件存取&#34;&gt;文件存取&lt;/h4&gt;
&lt;p&gt;用户通过对 &lt;strong&gt;文件的存取&lt;/strong&gt; 完成对文件的各种操作。文件的存取方式是由 &lt;strong&gt;文件的性质和用户使用文件的情况&lt;/strong&gt; 来确定的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;顺序存取&lt;/li&gt;
&lt;li&gt;随机存取&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;定长记录的文件能很好地支持随机存取，而变长记录虽然可以随机存取，但实现起来复杂且存取速度慢。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;文件操作&#34;&gt;文件操作&lt;/h4&gt;
&lt;p&gt;使用文件的目的是存储信息，方便以后的检索。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;CREATE&lt;/li&gt;
&lt;li&gt;DELETE&lt;/li&gt;
&lt;li&gt;OPEN 使用文件之前，必须先打开文件。OPEN调用的目的是将 &lt;strong&gt;文件属性和磁盘地址表&lt;/strong&gt; 装入主存，以便后续调用的快速存取。&lt;/li&gt;
&lt;li&gt;CLOSE&lt;/li&gt;
&lt;li&gt;READ&lt;/li&gt;
&lt;li&gt;WRITE&lt;/li&gt;
&lt;li&gt;APPEND&lt;/li&gt;
&lt;li&gt;SEEK&lt;/li&gt;
&lt;li&gt;GETATTRIBUTES&lt;/li&gt;
&lt;li&gt;SETATTRIBUTES&lt;/li&gt;
&lt;li&gt;RENAME&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;目录&#34;&gt;目录&lt;/h3&gt;
&lt;p&gt;文件系统通常提供目录用于记录文件，在很多系统中目录本身也是文件。目录的数量对应文件的数量。&lt;/p&gt;
&lt;h4 id=&#34;层次目录结构&#34;&gt;层次目录结构&lt;/h4&gt;
&lt;h5 id=&#34;目录文件的结构&#34;&gt;目录文件的结构&lt;/h5&gt;
&lt;blockquote&gt;
&lt;p&gt;2^n个扇区叫做一个簇，作为文件分配的最小单位。文件系统按名访问时需要簇号。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;文件名&lt;/th&gt;
&lt;th&gt;地址信息（簇号）&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;/table&gt;
&lt;/blockquote&gt;
&lt;p&gt;地址信息在MS－DOS系统中是起始簇号，在unix是i节点所在簇号。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;单层目录&lt;/li&gt;
&lt;li&gt;双层目录 一个用户一个目录&lt;/li&gt;
&lt;li&gt;目录树&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;路径名&#34;&gt;路径名&lt;/h4&gt;
&lt;h4 id=&#34;实现文件&#34;&gt;实现文件&lt;/h4&gt;
&lt;p&gt;连续分配是将文件作为连续数据存储在磁盘上。&lt;/p&gt;
&lt;p&gt;优点：简单易实现，性能好，一次操作可读出整个文件&lt;/p&gt;
&lt;p&gt;缺点：无法事先知道该为文件分多少空间，文件长度会变，造成磁盘碎片。&lt;/p&gt;
&lt;p&gt;链接表分配是为每个文件构建磁盘块的链接表，每个块的第一个字用于指向下一块的指针，块的其他部分存放数据&lt;/p&gt;
&lt;p&gt;优点：磁盘空间利用率高，管理简单&lt;/p&gt;
&lt;p&gt;缺点：随机存取的速度慢&lt;/p&gt;
&lt;p&gt;使用索引的链接表分配使用链接表实现文件，取出文件名和地址信息作为索引表。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;目录结合FAT表
FAT12&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;FAT文件系统目录结构、FAT表结构作用、如何实现按名访问、数据结构与单个文件管理的最大长度的关系。&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;FAT12采用12位文件分配表，磁盘块大小为2KB&lt;/li&gt;
&lt;li&gt;则FAT12可以管理的磁盘容量为8M&lt;/li&gt;
&lt;li&gt;FAT12文件系统文件名：只能是8.3格式的文件名&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;实现目录&#34;&gt;实现目录&lt;/h4&gt;
&lt;hr&gt;
&lt;p&gt;问：有目录dir，其下有100B的a.txt，问占用磁盘空间。&lt;/p&gt;
&lt;p&gt;答：两个簇，因为一个簇不会比512B更小。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;UNIX中的目录&lt;/p&gt;
&lt;h4 id=&#34;磁盘空间管理&#34;&gt;磁盘空间管理&lt;/h4&gt;
&lt;h5 id=&#34;块大小&#34;&gt;块大小&lt;/h5&gt;
&lt;p&gt;太大浪费空间，太小浪费时间&lt;/p&gt;
&lt;h5 id=&#34;记录空闲块&#34;&gt;记录空闲块&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;空闲磁盘块链表&lt;/li&gt;
&lt;li&gt;位图&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;io设备管理&#34;&gt;I/O设备管理&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;操作系统快考试了，我觉得自己过应该还是没问题的吧，毕竟也有认真听课。虽然对某些部分流程记忆有点发憷。
[tag]:操作系统|笔记&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;io系统的组成&#34;&gt;I/O系统的组成&lt;/h3&gt;
&lt;p&gt;I/O系统不仅包含各种I/O设备，还包含于设备相连的设备控制器，有的系统亦配备了专门用于输入输出控制的专业计算机 &lt;strong&gt;通道&lt;/strong&gt; 。&lt;/p&gt;
&lt;h4 id=&#34;io系统的结构&#34;&gt;I/O系统的结构&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;微机I/O系统&lt;/li&gt;
&lt;li&gt;主机I/O系统&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;io设备的分类&#34;&gt;I/O设备的分类&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;按速率分类&lt;/li&gt;
&lt;li&gt;按信息交换的单位分类&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;块设备&lt;/li&gt;
&lt;li&gt;字符设备&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;两种设备操作系统实现驱动程序的方式是不同的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;按设备的共享属性分类&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;独占设备&lt;/li&gt;
&lt;li&gt;共享设备 资源调度问题&lt;/li&gt;
&lt;li&gt;虚拟设备 利用虚拟技术把一台物理设备变为若干逻辑设备&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;设备控制器&#34;&gt;设备控制器&lt;/h4&gt;
&lt;p&gt;设备控制器是 &lt;strong&gt;CPU&lt;/strong&gt; 与 &lt;strong&gt;I/O设备&lt;/strong&gt; 之间的接口，接收I/O的命令并控制I/O完成设备工作。设备控制器是一个可编址设备，连接多个设备时可有多个设备地址。&lt;/p&gt;
&lt;p&gt;【待补充】&lt;/p&gt;
&lt;h3 id=&#34;io控制方式&#34;&gt;I/O控制方式&lt;/h3&gt;
&lt;h4 id=&#34;轮询控制方式&#34;&gt;轮询控制方式&lt;/h4&gt;
&lt;h4 id=&#34;中断控制方式&#34;&gt;中断控制方式&lt;/h4&gt;
&lt;h4 id=&#34;dma控制方式&#34;&gt;DMA控制方式&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;不同控制下I/O的过程
……进程状态会发生什么变化
OS内核会做些什么
将进程置为阻塞态
为进程分配设备
中断处理，唤醒进程&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;DMA控制器的组成&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;命令/状态寄存器&lt;/li&gt;
&lt;li&gt;内存地址寄存器MAR&lt;/li&gt;
&lt;li&gt;数据寄存器DR&lt;/li&gt;
&lt;li&gt;数据计数器DC&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;不使用DMA过程&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;首先控制器从设备完整读出一块数据放入数据寄存器&lt;/li&gt;
&lt;li&gt;计算校验和&lt;/li&gt;
&lt;li&gt;发中断信号，将数据读入内存&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;使用DMA方式&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;CPU发【待补充】&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;缓冲管理&#34;&gt;缓冲管理&lt;/h3&gt;
&lt;h4 id=&#34;缓冲的引入&#34;&gt;缓冲的引入&lt;/h4&gt;
&lt;p&gt;在数据到达和数据离开速度不一致的地方都可以引入缓冲。&lt;/p&gt;
&lt;p&gt;降低对硬件响应时间的要求。&lt;/p&gt;
&lt;h4 id=&#34;循环缓冲&#34;&gt;循环缓冲&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;引入循环缓冲的理由&lt;/li&gt;
&lt;li&gt;循环缓冲的组成&lt;/li&gt;
&lt;li&gt;缓冲区的使用&lt;/li&gt;
&lt;li&gt;进程同步&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;设备分配&#34;&gt;设备分配&lt;/h3&gt;
&lt;h4 id=&#34;设备分配要考虑的因素&#34;&gt;设备分配要考虑的因素&lt;/h4&gt;
&lt;h4 id=&#34;设备独立性&#34;&gt;设备独立性&lt;/h4&gt;
&lt;p&gt;应用程序独立于具体的物理设备。&lt;/p&gt;
&lt;h4 id=&#34;spooling技术&#34;&gt;SPOOLING技术&lt;/h4&gt;
&lt;h3 id=&#34;磁盘管理&#34;&gt;磁盘管理&lt;/h3&gt;
&lt;h4 id=&#34;磁盘结构&#34;&gt;磁盘结构&lt;/h4&gt;
&lt;p&gt;通过改善调度算法提高访问速度=&amp;gt;减少寻道次数&lt;/p&gt;
&lt;h4 id=&#34;磁盘调度&#34;&gt;磁盘调度&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;考磁盘调度算法&lt;/p&gt;
&lt;/blockquote&gt;
- https://ntutn.top/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/ - CC BY-SA 4.0</description>
        </item>
    
    
    
        <item>
        <title>三门问题</title>
        <link>https://ntutn.top/posts/%E4%B8%89%E9%97%A8%E9%97%AE%E9%A2%98/</link>
        <pubDate>Mon, 16 Sep 2019 03:11:37 +0800</pubDate>
        
        <guid>https://ntutn.top/posts/%E4%B8%89%E9%97%A8%E9%97%AE%E9%A2%98/</guid>
        <description>归零幻想 https://ntutn.top/posts/%E4%B8%89%E9%97%A8%E9%97%AE%E9%A2%98/ -&lt;!-- raw HTML omitted --&gt;
&lt;blockquote&gt;
&lt;p&gt;参赛者面前有三扇关闭着的门，其中一扇的后面是一辆汽车，选中后面有车的那扇门就可以赢得该汽车，
而另外两扇门后面则各藏有一只山羊。当参赛者选定了一扇门，但未去开启它的时候，主持人会开启剩
下两扇门中的一扇，露出其中一只山羊。主持人其后会问参赛者要不要更换选择，选另一扇仍然关着的门。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;那么，应不应该更换呢？
&lt;img src=&#34;https://i.loli.net/2020/08/20/eWcOG6t1FpUD5mC.png&#34; alt=&#34;1560925478346.png&#34;&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;h2 id=&#34;分析&#34;&gt;分析&lt;/h2&gt;
&lt;p&gt;假如你选择了A，那你中奖概率应为1/3.&lt;/p&gt;
&lt;p&gt;主持人在B、C中选了个没奖的，这与你的选择其实没影响，因为你没选的肯定有个没奖的。&lt;/p&gt;
&lt;p&gt;换与不换其实就相当于问你选A还是不选A。&lt;/p&gt;
&lt;h2 id=&#34;程序模拟&#34;&gt;程序模拟&lt;/h2&gt;
&lt;p&gt;有点绕，咱学软件的，就干脆让电脑跑一跑。&lt;/p&gt;
&lt;h3 id=&#34;代码&#34;&gt;代码&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color:#008b45;text-decoration:underline&#34;&gt;java.util.Random&lt;/span&gt;;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;Test&lt;/span&gt;{
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;main&lt;/span&gt;(String[] args) {
        Random ran=&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; Random();
        &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; c1=0,c2=0;
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt;(&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; i=0;i&amp;lt;1e6;i++){
            &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;boolean&lt;/span&gt; boxes[]={&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;false&lt;/span&gt;,&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;false&lt;/span&gt;,&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;false&lt;/span&gt;};
            boxes[ran.&lt;span style=&#34;color:#658b00&#34;&gt;nextInt&lt;/span&gt;(boxes.&lt;span style=&#34;color:#658b00&#34;&gt;length&lt;/span&gt;)]=&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;true&lt;/span&gt;;&lt;span style=&#34;color:#228b22&#34;&gt;//某个门后有奖
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; sel=ran.&lt;span style=&#34;color:#658b00&#34;&gt;nextInt&lt;/span&gt;(boxes.&lt;span style=&#34;color:#658b00&#34;&gt;length&lt;/span&gt;);&lt;span style=&#34;color:#228b22&#34;&gt;//随便选择一扇门
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; p=0;
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;while&lt;/span&gt;(p==sel||boxes[p]){&lt;span style=&#34;color:#228b22&#34;&gt;//主持人选择一扇没奖的门（且不与参与者选同一扇）
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;                p=ran.&lt;span style=&#34;color:#658b00&#34;&gt;nextInt&lt;/span&gt;(boxes.&lt;span style=&#34;color:#658b00&#34;&gt;length&lt;/span&gt;);
            }
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt;(boxes[sel]){&lt;span style=&#34;color:#228b22&#34;&gt;//不更换中奖
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;                c1++;
            }
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt;(boxes[0+1+2-sel-p]){&lt;span style=&#34;color:#228b22&#34;&gt;//更换中奖
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;                c2++;
            }
        }
        System.&lt;span style=&#34;color:#658b00&#34;&gt;out&lt;/span&gt;.&lt;span style=&#34;color:#658b00&#34;&gt;println&lt;/span&gt;(c1/1e6);
        System.&lt;span style=&#34;color:#658b00&#34;&gt;out&lt;/span&gt;.&lt;span style=&#34;color:#658b00&#34;&gt;println&lt;/span&gt;(c2/1e6);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;运行结果&#34;&gt;运行结果&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;0.332419
0.667581
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;看来是更换比较好了。&lt;/p&gt;
- https://ntutn.top/posts/%E4%B8%89%E9%97%A8%E9%97%AE%E9%A2%98/ - CC BY-SA 4.0</description>
        </item>
    
    
    
        <item>
        <title>大型数组按行遍历与按列遍历的区别</title>
        <link>https://ntutn.top/posts/%E5%A4%A7%E5%9E%8B%E6%95%B0%E7%BB%84%E6%8C%89%E8%A1%8C%E9%81%8D%E5%8E%86%E4%B8%8E%E6%8C%89%E5%88%97%E9%81%8D%E5%8E%86%E7%9A%84%E5%8C%BA%E5%88%AB/</link>
        <pubDate>Mon, 16 Sep 2019 03:11:37 +0800</pubDate>
        
        <guid>https://ntutn.top/posts/%E5%A4%A7%E5%9E%8B%E6%95%B0%E7%BB%84%E6%8C%89%E8%A1%8C%E9%81%8D%E5%8E%86%E4%B8%8E%E6%8C%89%E5%88%97%E9%81%8D%E5%8E%86%E7%9A%84%E5%8C%BA%E5%88%AB/</guid>
        <description>归零幻想 https://ntutn.top/posts/%E5%A4%A7%E5%9E%8B%E6%95%B0%E7%BB%84%E6%8C%89%E8%A1%8C%E9%81%8D%E5%8E%86%E4%B8%8E%E6%8C%89%E5%88%97%E9%81%8D%E5%8E%86%E7%9A%84%E5%8C%BA%E5%88%AB/ -&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;今天这学期开学第一天，上了《计算机操作系统原理》，老师提出个问题&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;对于一个很大的数组（如&lt;code&gt;70000×70000&lt;/code&gt;），按行遍历速度快还是按列遍历快，为什么？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;乍一看，程序时间复杂度一样，理论上不是应该一样快吗？难道老师在钓鱼？&lt;/p&gt;
&lt;p&gt;实践出真知，我们就写个程序跑一跑。&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;h2 id=&#34;程序&#34;&gt;程序&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;70000×70000我电脑在默认情况下开不下，我这里用20000×20000测试&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;按行遍历&#34;&gt;按行遍历&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#228b22&#34;&gt;/**
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt; * M1
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt; */&lt;/span&gt;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;M1&lt;/span&gt; {
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;main&lt;/span&gt;(String[] args) {
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;final&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; N=20000;
        &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt;[][] a = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt;[N][N];
        Long start=System.&lt;span style=&#34;color:#658b00&#34;&gt;currentTimeMillis&lt;/span&gt;();
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt;(&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; i=0;i&amp;lt;N;i++){
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; j = 0; j &amp;lt; N; j++) {
                a[i][j]=1;
            }
        }
        Long stop=System.&lt;span style=&#34;color:#658b00&#34;&gt;currentTimeMillis&lt;/span&gt;();
        System.&lt;span style=&#34;color:#658b00&#34;&gt;out&lt;/span&gt;.&lt;span style=&#34;color:#658b00&#34;&gt;println&lt;/span&gt;(stop-start);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;按列遍历&#34;&gt;按列遍历&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#228b22&#34;&gt;/**
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt; * M2
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt; */&lt;/span&gt;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;M2&lt;/span&gt; {
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;main&lt;/span&gt;(String[] args) {
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;final&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; N=20000;
        &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt;[][] a = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt;[N][N];
        Long start=System.&lt;span style=&#34;color:#658b00&#34;&gt;currentTimeMillis&lt;/span&gt;();
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt;(&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; i=0;i&amp;lt;N;i++){
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; j = 0; j &amp;lt; N; j++) {
                a[j][i]=1;
            }
        }
        Long stop=System.&lt;span style=&#34;color:#658b00&#34;&gt;currentTimeMillis&lt;/span&gt;();
        System.&lt;span style=&#34;color:#658b00&#34;&gt;out&lt;/span&gt;.&lt;span style=&#34;color:#658b00&#34;&gt;println&lt;/span&gt;(stop-start);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;运行结果&#34;&gt;运行结果&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2020/08/20/h7FJbzeVcMOpi3Z.png&#34; alt=&#34;1.png&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;分析&#34;&gt;分析&lt;/h2&gt;
&lt;p&gt;好吧，看上去的确是不一样。看这结果是不是感觉有点玄学，为啥差这么多？&lt;/p&gt;
&lt;p&gt;回想计算机组成原理学过的知识，&lt;a href=&#34;https://ntutn.top/show/19.html&#34;&gt;计算机组成原理笔记&lt;/a&gt;，存储器的层次化结构，高速缓存……&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;没错，就是这货！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2020/08/20/IwMb8ixF2g1k3mT.jpg&#34; alt=&#34;2.jpeg&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;存储器的层次化结构&lt;/p&gt;
&lt;blockquote&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;典型存取时间&lt;/th&gt;
&lt;th&gt;存储器&lt;/th&gt;
&lt;th&gt;典型容量&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1ns&lt;/td&gt;
&lt;td&gt;寄存器&lt;/td&gt;
&lt;td&gt;&amp;lt;1KB&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2ns&lt;/td&gt;
&lt;td&gt;高速缓存（cache）&lt;/td&gt;
&lt;td&gt;4MB&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;10ns&lt;/td&gt;
&lt;td&gt;主存储器（RAM和ROM）&lt;/td&gt;
&lt;td&gt;500MB~4GB&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;10ms&lt;/td&gt;
&lt;td&gt;辅助存储器（硬盘）&lt;/td&gt;
&lt;td&gt;40~500G&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;10s&lt;/td&gt;
&lt;td&gt;海量后备存储器（磁带库、光盘等）&lt;/td&gt;
&lt;td&gt;10~100TB&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;在很多主流编程语言中，数组在内存中存放的方式是“一行行”存放的，按行遍历，访问的内存地址分别为&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;x+1,x+2,x+3,……,x+n,x+n+1……
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;而按列遍历访问的顺序是&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;x+1,x+n+1,x+2n+1,……,x+n(n-1)+1,x+2,x+n+2,……
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;cache的命中率基本为0，结合几种存储器的速度，不难分析出原因了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;所以，针对这个问题，在回答时要说明前提，即数组在内存中的实际的编址方式是怎样的。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在我机器java这例子，就是按行遍历快了。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;2019年09月16日，我把实验过程给老师看了，老师补充这个速度除了与高速缓存的命中有关，还与编译器的内存管理有关。&lt;/p&gt;
- https://ntutn.top/posts/%E5%A4%A7%E5%9E%8B%E6%95%B0%E7%BB%84%E6%8C%89%E8%A1%8C%E9%81%8D%E5%8E%86%E4%B8%8E%E6%8C%89%E5%88%97%E9%81%8D%E5%8E%86%E7%9A%84%E5%8C%BA%E5%88%AB/ - CC BY-SA 4.0</description>
        </item>
    
    
  </channel>
</rss> 