<!DOCTYPE HTML>
<html xmlns="http://www.w3.org/1999/xhtml" lang="zh-Hans">

<head>
    
    
    <title>安卓连连看游戏设计--归零幻想的博客</title>
    <meta charset="UTF-8">
    <!--移动设备不缩放-->
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <link rel="alternate" type="application/rss+xml" title="归零幻想" href="https://ntutn.top/rss.xml" />
    <!--github的markdown样式-->
    <link rel="stylesheet" href="/res/css/github-markdown.css">
    <!--一个基于bootstrap的样式-->
    <link rel="stylesheet" href="/res/css/main.css">

    <script src="/res/js/jquery.min.js"></script>
    <script src="/res/js/popper.min.js"></script>
    <script src="/res/js/bootstrap.min.js"></script>

    <style>
        /*图片缩放*/
        .imageWrapper {
            max-width: 500px;
            max-height: 100%;
            display: block;
            margin: 0 auto;
        }

        /*背景图片*/
        body {
            background: url(https://unsplash.it/1600/900?random);
            background-attachment: fixed;
            background-position: bottom center;
            background-size: cover;
        }
    </style>
    <script src="/res/js/zoomify.min.js"></script>
    <link href="/res/css/zoomify.min.css" rel="stylesheet">

    <!---代码高亮-->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/styles/idea.min.css" integrity="sha512-Rfc5zQIp95eozfMCdS3B4MItUxU8orNje/t1OEhf7XwIk0DTCuMH2LG0NIgP8UGYK9L39WfUNI1c4IsM5yY/PA==" crossorigin="anonymous" referrerpolicy="no-referrer" />
           
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/highlight.min.js"></script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/languages/apache.min.js" integrity="sha512-gE8KAQyFIzV1C9+GZ8TKJHZS2s+n7EjNtC+IMRn1l5+WYJTHOODUM6JSjZhFhqXmc7bG8Av6XXpckA4tYhflnw==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/languages/bash.min.js" integrity="sha512-FKvOrHUlsJ2pKk+pk8D25a1wTvD5ab+tudQ9g3lJqMH9YtrpqHEbMEiCeU6HA5URAawnGJC0JfZLesDWkXYLyw==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/languages/basic.min.js" integrity="sha512-e+l7CY07JEoomaYRN0aCm+Nkj6PSnUTKqfNQzbH4uBAxa86Nqx8j+k20Pu9j4+dBgpPNkupUdAQlvmXLnjs6fQ==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/languages/c.min.js" integrity="sha512-6uPEB+tN2jnZQ8gHNkW4ZiJbXUa7gIL21dsIS3UPAJyzRfDCLmm1hFGJmZ/l8RwBPeCiKTOg9BNCB+Bp9btrmA==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/languages/cmake.min.js" integrity="sha512-rGz7I/XUUa81jEKbxXuZFbh2KTx8M7uWE6kq/IOJHNyZcQP9r3HafPVnqGg81xeKJK1sUUmk5BM5zFJj6XsSOA==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/languages/cpp.min.js" integrity="sha512-hZq4EJY8EMM7w6kWktRCsnhWehJs4Tq3V8bccoMuVgwigDj5oKiLlRi59NKUw4Q43wZKK8brlPZl5r0Yo58ZXA==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/languages/csharp.min.js" integrity="sha512-X18ZEfQ3SPnexB5QRmg4fp9QjaFa/jEiw7J1TsWWPIJGgvVyLXrI8fdaZOqbbsfX5byF9/CovS++zG5QL8EZ+A==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/languages/css.min.js" integrity="sha512-yZeVBJRfVCykn6i7I3NXhR2cA5OWI/YM9GlV9bO/KjrXaPSEnSau0OCnOa1ad5hA2LSq/3YB3p0sJTCH+OL3fQ==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/languages/dockerfile.min.js" integrity="sha512-1Ei4BsbZ/bYV5hmzxHa6uzwr7ftc8uysn0U2RK2rJe+aN2O8mXespb6z8Y3xrDf5R7t7rObrLIKA5o3VU3eJFA==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/languages/dos.min.js" integrity="sha512-UAaZyglZlxoUkWirdjgTiE6kzsqUn4ZfMxD99eeRBcUCsq8pbt5arQRlGR9bXS9VHzL38KN6Rw8ozg3AJBfa7w==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/languages/go.min.js" integrity="sha512-EWROca+bote+7Oaaar1F6y74iZj1r1F9rm/ly7o+/FwJopbBaWtsFDmaKoZDd3QiGU2pGacBirHJNivmGLYrow==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/languages/gradle.min.js" integrity="sha512-wlBnLL4IT1i9CSixtdYtmBFTn3pVD8qQRj6Ba58mhMwaFy/UrkOmmV7RgX22p6rn7j8VtN0lto/JJyyTFs/g7A==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/languages/groovy.min.js" integrity="sha512-dETjs4xDxipeZKHG1N/9cju7iw5ldaFHQJ/XK75EDv9cPaNV+FuORBmfMuwg6V5IudAzLnSFzi9ALGZFH6r5NQ==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/languages/ini.min.js" integrity="sha512-ECe50ffxXzZnLKoKCn+r9ULj27e/6h6AFa1uFBgnQz2WVrPOZEsbEmUbt8rsQTUVo4X2s7EO29Bv9bVOBETuqw==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/languages/java.min.js" integrity="sha512-xEnylOTeZvxUCvtK9Lw3FjOgfCwsMEhUbx6Hant1lPgy+PcynqCm8XfqhpRos6XNaTxeMuT4QyrWyo3U1NijHg==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/languages/javascript.min.js" integrity="sha512-Mhvr+xy2hvcm9g/wPUirdSNSQVWZ6gBVOky3SOfYEAiKsMry6FhotoB/yPE37lYP46igpLUOXZK7uPBkdMZedQ==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/languages/kotlin.min.js" integrity="sha512-WP/R3IrzEd0v0jF+/QdNvecCp5LF8LY2g3XDyVwumU2Rl+TL+VgKxwiNlMmz0ks0m/zpfzrE4yoQ97KPsD0KAg==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/languages/latex.min.js" integrity="sha512-xdAZ0+yuywvfmEJBe+VOGM46gkP7orEAlqzh5QQRjqIt+wnLbKQsUGqU0aCNaCbncVH0CZK62HRFappBhkDtsA==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/languages/makefile.min.js" integrity="sha512-HhumF7+woGiAuk8LFmeLWrR6ZOmEVKfdZOuIAfbyKYIIagPDI+3PkHT5yHNuSbuXbdcSSuA9iOgyFw1QAyF5Sw==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/languages/php.min.js" integrity="sha512-/4bsm6nfQWNGd6957+2xA9pcl/1OwrHDrx/vug0V/rr4dG4pMMuESaseX15pj7+pmhvZB6O/dNT4qA6/NQSVNQ==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/languages/python.min.js" integrity="sha512-MbDu8Vk2zJLvSEzk4bOYrlcS+9WE39QPnxINj2aftAG63jxOhdP5p2/Ma6/D3C9IkT/xOjZTO8MtBCX8PI48BA==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/languages/shell.min.js" integrity="sha512-TBRe4v9USbfzECSiP8d6bQSSvqxHHbeMneQPNsU51SSVAaakOezeYI8sOBWdXh8GGc5vD28d1Sxzk+LgDM3dxA==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/languages/vbscript.min.js" integrity="sha512-MKguDuFJ+IM/Jm5SFVQsgy56sRCTjGOhuvvR94sGpYCXnO3Emu/egPCxtFprra3/gNpmIJKMp61VphygW7UCXQ==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/languages/xml.min.js" integrity="sha512-42l52BYLobXrodiKIjvsxUSzwTMhnJww+Da1BZ771+rxtpWCeozwy4Mfca7DM+PRmfEQrGfyEI32kBi3b/0v/w==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/languages/yaml.min.js" integrity="sha512-28oDiQZGKUVN6wQ7PSLPNipOcmkCALXKwOi7bnkyFf8QiMZQxG9EQoy/iiNx6Zxj2cG2SbVa4dXKigQhu7GiFw==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    
    <script>
        $(document).ready(function () {
            $(".markdown-body img").each(function () {
                divImageWrapper = $(this).after("<div class='imageWrapper'></div>")
                $(this).appendTo($(this).next())
            })
            $(".markdown-body img").zoomify() // 图片缩放
            hljs.highlightAll() // 代码高亮
        })
    </script>
</head>

<body>
    <div class="container">
        <nav id="nav" class="navbar navbar-expand-lg navbar-light bg-light">
            <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarTogglerDemo03"
                aria-controls="navbarTogglerDemo03" aria-expanded="false" aria-label="Toggle navigation">
                <span class="navbar-toggler-icon"></span>
            </button>
            <a class="navbar-brand" href="/"><img src="/res/logo.png" width="70" height="40"
                    class="d-inline-block align-top" alt="">
                <span>归零幻想的博客</span></a>

            <div class="collapse navbar-collapse" id="navbarTogglerDemo03">
                <ul class="navbar-nav mr-auto mt-2 mt-lg-0">
                    <li id="n_home" class="nav-item">
                        <a class="nav-link" href="/">主页</a>
                    </li>
                    <!-- <li id="n_tags" class="nav-item">
                        <a class="nav-link" href="/tags">标签</a>
                    </li> -->
                    <li id="n_about" class="nav-item">
                        <a class="nav-link" href="https://channel.ntutn.workers.dev/" target="_blank">频道</a>
                    </li>
                    <li id="n_about" class="nav-item">
                        <a class="nav-link" href="/friends.html">友链</a>
                    </li>
                    <li id="n_about" class="nav-item">
                        <a class="nav-link" href="/about.html">关于</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="/rss.xml">RSS</a>
                    </li>
                </ul>
            </div>
        </nav>
        <nav class="mt-3" aria-label="breadcrumb">
            <ol class="breadcrumb">
                <li class="breadcrumb-item"><a href="/">Home</a></li>

                <li class="breadcrumb-item active" aria-current="page">安卓连连看游戏设计</li>
            </ol>
        </nav>
        <div class="card mt-3 mb-3">
            <div class="card-body markdown-body">
                <h1 class="card-title text-center realtitle">安卓连连看游戏设计</h1>
                <!--TODO 时间-->
                <h6 class="card-subtitle mb-2 text-muted text-center">
                    发布时间：<span>2021-08-08</span>&nbsp;
                    修改时间：<span>2021-08-08</span>&nbsp;
                    作者：<span>归零幻想</span>
                </h6>
                <br>
                <div class="card-text"><p>字节取消大小周了，于是周末时间多起来了。虽然想着到处去玩，但现在疫情形势又不好了，于是安心呆在家里当一个肥宅。除了补一补番剧，就是把之前就想过的连连看游戏做出来了。</p>
<p>连连看游戏规则简单，点击两个相同的元素，如果他们能在两次拐弯以内连接起来，那么就可以消除。消除后就会出现空位，可以连接的就更多了。在规定时间内连续操作，直到消除所有元素。</p>
<p>虽然规则比较简单，但真正动手实现一遍还是很费工夫的。游戏既然做好了，那么我水一篇博客不过分吧:&gt;</p>
<p><img src="https://s3.jpg.cm/2021/08/08/IAjmPL.jpg" alt="连连看游戏界面" /> <sup id="fnref-1"><a class="footnote-ref" href="#fn-1">1</a></sup></p>
<p>项目的代码我放到了github。写的贼丑，轻喷。 <a href="https://github.com/zerofancy/match">https://github.com/zerofancy/match</a></p>
<h2 id="资源准备">资源准备</h2>
<p>连连看需要一些素材图，可以考虑用水果、动物甚至我同学的头像等，但我想把难度设计高一点，手机屏幕就这么大，图片很小也能有比较高的辨识度，思来想去还是麻将比较合适。</p>
<p>幸运的是，我找到了这么一套免费的图片素材，<a href="http://martinpersson.org/">Mahjong Icons</a>，只要提供一个指向这个页面的超链接就可以免费用。</p>
<p>另外还需要一个应用图标，这个我是直接在<a href="https://iconpark.oceanengine.com/home">Icon Park</a>上找了一个。</p>
<p>接下来将素材导入到项目，为了随处使用方便，我还定义到了一个类中：</p>
<pre><code class="language-kt">package top.ntutn.match

/**
 * 麻将牌
 */
object Mahjong {
    val bamboos = listOf(
        R.drawable.bamboo1,
        R.drawable.bamboo2,
        R.drawable.bamboo3,
        R.drawable.bamboo4,
        R.drawable.bamboo5,
        R.drawable.bamboo6,
        R.drawable.bamboo7,
        R.drawable.bamboo8,
        R.drawable.bamboo9
    )
    val dragons = listOf(
        R.drawable.dragon_chun,
        R.drawable.dragon_green,
        R.drawable.dragon_haku
    )
    val faceDown = R.drawable.face_down
    val mans = listOf(
        R.drawable.man1,
        R.drawable.man2,
        R.drawable.man3,
        R.drawable.man4,
        R.drawable.man5,
        R.drawable.man6,
        R.drawable.man7,
        R.drawable.man8,
        R.drawable.man9
    )
    val pins = listOf(
        R.drawable.pin1,
        R.drawable.pin2,
        R.drawable.pin3,
        R.drawable.pin4,
        R.drawable.pin5,
        R.drawable.pin6,
        R.drawable.pin7,
        R.drawable.pin8,
        R.drawable.pin9
    )
    val redDoras = listOf(
        R.drawable.red_dora_bamboo5,
        R.drawable.red_dora_man5,
        R.drawable.red_dora_pin5
    )
    val winds = listOf(
        R.drawable.wind_east,
        R.drawable.wind_north,
        R.drawable.wind_south,
        R.drawable.wind_west
    )
    val front = bamboos + dragons + mans + pins + redDoras + winds
    val all = front + faceDown
}
</code></pre>
<h2 id="界面设计">界面设计</h2>
<p>参考上面截图，游戏区域其实是相当简单的，但麻将格子太多，如何显示到界面中呢？我采取的是使用多个ImageView，然后用代码动态添加的方式。这样我可以将ImageView也存成一个二维数组，正好跟游戏数据的二维数组对应起来，写起来更方便。</p>
<p>这样我的界面就比较简单了，只要准备上方计时器的TextView和主要区域的ImageView就可以了。在<code>onCreate()</code>生命周期我创建并添加这些ImageView：</p>
<p>这里我计算了中间区域的尺寸，让游戏区域为位于中间区域的一个近似正方形：</p>
<pre><code class="language-kt">        // post一下，不然取不到
        imageContainer.post {
            // 中间正方形区域宽高
            areaWidth = min(imageContainer.width, imageContainer.height - horizontalGap * (N - 1))
            imageViewArray = Array(N) { i -&gt;
                Array(N) { j -&gt;
                    ImageView(this).apply {
                        imageContainer.addView(this)
                        layoutParams = FrameLayout.LayoutParams(areaWidth / N, areaWidth / N)
                        y =
                            (i * (areaWidth / N + horizontalGap)).toFloat() - areaWidth / 2 - horizontalGap * N / 2 + imageContainer.height / 2
                        x = (j * areaWidth / N).toFloat() - areaWidth / 2 + imageContainer.width / 2
                        scaleType = ImageView.ScaleType.CENTER_INSIDE
                        setOnClickListener {
                            viewModel.itemClick(i + 1, j + 1)
                        }
                    }
                }
            }
            // 配置改变不重建
            savedInstanceState ?: kotlin.run {
                viewModel.init(N, N, mahjongSize, maxGameTime, stepGameTime)
                viewModel.start()
            }
        }
</code></pre>
<h2 id="数据结构定义">数据结构定义</h2>
<p>对于每一个麻将牌，我们需要关心他们显示的内容和当前的状态（是否被选中，是否已经消除），因而定义这样的数据结构：</p>
<pre><code class="language-kt">/**
 * 麻将数据类型
 * @param id 本次游戏中的编号（不是资源id）
 * @param isSelected 麻将是否被选中
 * @param isDeleted 麻将是否已经被删除
 */
data class MahjongType(
    val id: Int,
    var isSelected: Boolean = false,
    var isDeleted: Boolean = false
)
</code></pre>
<p>在ViewModel中，我用一个二维数组来存储游戏数据</p>
<pre><code class="language-kt">    var mahjongArea: Array&lt;Array&lt;MahjongType&gt;&gt; = arrayOf()
        private set
</code></pre>
<p>对于选中点，需要记录它的行数和列数</p>
<pre><code class="language-kt">    private var selectedIndex: Pair&lt;Int, Int&gt;? = null
</code></pre>
<p>游戏有三种事件：游戏状态改变（开始、结束、暂停等）、游戏区域刷新、倒计时改变。这些我定义为LiveData。这里的refreshArea是一个Unit类型的LiveData，因为不需要传递什么数据，只要通知这个事件到来就可以了。</p>
<pre><code class="language-kt">    // 游戏区域刷新事件
    private val _refreshArea = MutableLiveData&lt;Unit&gt;()
    val refreshArea: LiveData&lt;Unit&gt;
        get() = _refreshArea

    // 游戏状态改变
    private val _gameState = MutableLiveData&lt;GameState&gt;()
    val gameState: LiveData&lt;GameState&gt;
        get() = _gameState

    // 游戏倒计时
    private val _gameTime = MutableLiveData&lt;Int&gt;()
    val gameTime: LiveData&lt;Int&gt;
        get() = _gameTime

    enum class GameState {
        PENDING,
        RUNNING,
        PAUSE,
        SUCCEEDED,
        FAILED
    }

</code></pre>
<h2 id="游戏数据初始化">游戏数据初始化</h2>
<p>游戏数据初始化时，我们要将所有变量置为初始状态。</p>
<ol>
<li>游戏区域 为了计算方便，我们实际存储的游戏区域比显示出来的游戏区域实际上是多一圈的，多一圈空格子，这样边上的元素计算能否连通的时候就不需要特殊处理</li>
<li>游戏中，麻将元素应该是成对的，所以我首先选择一些元素，然后随机添加到一个list中，每个添加两份，最后再打乱顺序</li>
<li>游戏中，所有需要后面判断和比较差异的复制都应该是深拷贝，否则他们是同一个对象，怎么比都是一样</li>
</ol>
<pre><code class="language-kt">    /**
     * 初始化游戏
     * @param rows 游戏区域行数
     * @param cols 游戏区域列数
     * @param itemCount 使用的麻将牌的数量
     */
    fun init(rows: Int, cols: Int, itemCount: Int, maxGameTime: Int, stepGameTime: Int) {
        require(rows * cols % 2 == 0) { &quot;区域应该有偶数个元素&quot; }
        require(itemCount &lt;= Mahjong.front.size) { &quot;麻将牌资源不足&quot; }
        require(maxGameTime &gt; 5) { &quot;游戏时间过短&quot; }
        require(stepGameTime &gt;= 0) { &quot;stepGameTime参数错误&quot; }

        this.rows = rows
        this.cols = cols
        this.maxGameTime = maxGameTime
        this.stepGameTime = stepGameTime

        // +2是为了给周围放上一圈空格子，计算的时候方便
        mahjongArea = Array(rows + 2) {
            Array(cols + 2) {
                MahjongType(id = Mahjong.faceDown, isDeleted = true)
            }
        }

        val totalItemCollection = Mahjong.front.shuffled().subList(0, itemCount)
        val res = mutableListOf&lt;MahjongType&gt;()
        while (res.size &lt; rows * cols) {
            val item = MahjongType(id = totalItemCollection.random())
            res.add(item)
            // 深拷贝
            res.add(item.copy())
        }
        res.shuffle()
        for (i in res.indices) {
            mahjongArea[i / cols + 1][i % cols + 1] = res[i]
        }
        selectedIndex = null
        _refreshArea.value = Unit
        _gameState.value = GameState.PENDING
    }
</code></pre>
<h2 id="游戏界面显示">游戏界面显示</h2>
<p>我将每个ImageView对应的数据存储到它的tag中，这样在收到区域刷新事件时就可以直接比较判断是否要刷新了。</p>
<pre><code class="language-kt">        viewModel.refreshArea.observe(this) {
            for (i in 0 until N) {
                for (j in 0 until N) {
                    val dataItem = viewModel.mahjongArea[i + 1][j + 1]
                    val viewItem = imageViewArray[i][j]
                    if (viewItem.tag != dataItem) {
                        if (dataItem.isDeleted) {
                            viewItem.setImageDrawable(null)
                        } else {
                            viewItem.setImageResource(dataItem.id)
                        }
                        viewItem.scaleType = ImageView.ScaleType.CENTER_INSIDE
                        viewItem.tag = dataItem.copy() // 深拷贝，否则一直一样
                        if (dataItem.isSelected) {
                            viewItem.colorFilter = grayColorMatrixColorFilter
                        } else {
                            viewItem.clearColorFilter()
                        }
                    }
                }
            }
        }
</code></pre>
<h3 id="消除">消除</h3>
<p>对于被消除的元素，通过<code>viewItem.setImageDrawable(null)</code>清除显示内容。</p>
<h3 id="选中">选中</h3>
<p>对于被选中的元素，我通过设置<code>colorFilter</code>的方式调整图片饱和度来做到高亮显示的目的。这个<code>colorFilter</code>定义如下：</p>
<pre><code class="language-kt">    private val grayColorMatrixColorFilter by lazy {
        val colorMatrix = ColorMatrix().apply {
            setSaturation(25f)
        }
        ColorMatrixColorFilter(colorMatrix)
    }
</code></pre>
<h2 id="麻将牌点击事件">麻将牌点击事件</h2>
<h3 id="选中-1">选中</h3>
<p>首先我们只需要处理没有被消除的元素</p>
<pre><code class="language-kt">        if (mahjongArea[row][col].isDeleted) {
            // 当前点击元素已经消除
            return
        }
</code></pre>
<p>如果之前没有选中元素，那么我们应该直接选中这个元素</p>
<pre><code class="language-kt">        if (selectedIndex == null) {
            // 没有已经选中的，选中点击项
            mahjongArea[row][col].isSelected = true
            selectedIndex = row to col
            _refreshArea.value = Unit
            return
        }
</code></pre>
<h3 id="消除-1">消除</h3>
<p>否则就判断一下两个元素能否配对消除，并判断是否已经全部消除</p>
<pre><code class="language-kt">        val previousSelected = mahjongArea[selectedIndex!!.first][selectedIndex!!.second]
        val currentSelected = mahjongArea[row][col]
        // 判断是否可消除
        if (checkIsCanDelete(row to col, selectedIndex!!)) {
            previousSelected.isSelected = false
            previousSelected.isDeleted = true
            currentSelected.isDeleted = true
            selectedIndex = null
            val gameTime = (_gameTime.value ?: 1) + stepGameTime
            _gameTime.value = gameTime.takeIf { it &lt;= maxGameTime } ?: maxGameTime
            if (mahjongArea.all { it.all { it.isDeleted } }) {
                // 所有麻将已经消除，游戏胜利
                _gameState.value = GameState.SUCCEEDED
            }
        } else {
            previousSelected.isSelected = false
            selectedIndex = null
        }
        _refreshArea.value = Unit
</code></pre>
<p>那么如何判断能否消除呢？</p>
<pre><code class="language-kt">    /**
     * 判断两个元素是否能消除
     */
    private fun checkIsCanDelete(itemIndex1: Pair&lt;Int, Int&gt;, itemIndex2: Pair&lt;Int, Int&gt;): Boolean {
        if (itemIndex1 == itemIndex2) {
            return false
        }
        if (mahjongArea.getByPair(itemIndex1).id != mahjongArea.getByPair(itemIndex2).id) {
            return false
        }
        return VisitDirection.values().any {
            checkIsCanMatch(itemIndex1, itemIndex2, it)
        }
    }
</code></pre>
<p>如果是同一个元素，肯定不能消除；如果两个元素不同，那也不能消除。在排除了这两种情况后，要判断能否通过两次以内的拐弯就到达就需要BFS了。</p>
<ol>
<li>如果当前元素当前方向的下一个元素可以与目标元素拐n次弯相连，那么当前元素可以与目标元素拐n次弯相连</li>
<li>如果当前元素非当前方向的下一个元素可以与目标元素拐n次弯相连，那么当前元素可以与目标元素拐n+1次弯相连</li>
</ol>
<p>这里我用递归实现了这个算法，但实现的……有点丑</p>
<pre><code class="language-kt">
    /**
     * 判断两个在不同位置的相同元素是否能消除
     * BFS
     */
    private fun checkIsCanMatch(
        currentPoint: Pair&lt;Int, Int&gt;,
        targetPoint: Pair&lt;Int, Int&gt;,
        visitDirection: VisitDirection,
        maxRounds: Int = 2
    ): Boolean {
        val nextPoints = currentPoint.getNextPoints(visitDirection, targetPoint).filter {
            if (maxRounds &gt; 0) true else it.third == 0
        }
        if (targetPoint in nextPoints.map { it.first }) {
            return true
        }
        return nextPoints.isNotEmpty() &amp;&amp; nextPoints.any {
            checkIsCanMatch(it.first, targetPoint, it.second, maxRounds - it.third)
        }
    }

    /**
     * 当前结点是否在游戏区域内
     */
    private fun Pair&lt;Int, Int&gt;.isPointValid() =
        this.first in 0..(rows + 1) &amp;&amp; this.second in 0..(cols + 1)

    /**
     * 当前访问方向
     */
    private enum class VisitDirection {
        TOP,
        BOTTOM,
        LEFT,
        RIGHT
    }

    /**
     * 获取当前点的下一个点
     * @param currentDirection 当前朝向的方向
     * @return 一个集合，集合中有0～3个三元组，每个三元组有{点，朝向，需要拐弯次数}
     */
    private fun Pair&lt;Int, Int&gt;.getNextPoints(
        currentDirection: VisitDirection,
        targetPoint: Pair&lt;Int, Int&gt;
    ): Set&lt;Triple&lt;Pair&lt;Int, Int&gt;, VisitDirection, Int&gt;&gt; {
        val res = mutableSetOf&lt;Triple&lt;Pair&lt;Int, Int&gt;, VisitDirection, Int&gt;&gt;()
        val nextPoint = when (currentDirection) {
            VisitDirection.TOP -&gt; first - 1 to second
            VisitDirection.BOTTOM -&gt; first + 1 to second
            VisitDirection.LEFT -&gt; first to second - 1
            VisitDirection.RIGHT -&gt; first to second + 1
        }
        val (leftPoint, leftDirection) = when (currentDirection) {
            VisitDirection.TOP -&gt; first to second - 1 to VisitDirection.LEFT
            VisitDirection.BOTTOM -&gt; first to second + 1 to VisitDirection.RIGHT
            VisitDirection.LEFT -&gt; first + 1 to second to VisitDirection.BOTTOM
            VisitDirection.RIGHT -&gt; first - 1 to second to VisitDirection.TOP
        }
        val (rightPoint, rightDirection) = when (currentDirection) {
            VisitDirection.TOP -&gt; first to second + 1 to VisitDirection.RIGHT
            VisitDirection.BOTTOM -&gt; first to second - 1 to VisitDirection.LEFT
            VisitDirection.LEFT -&gt; first - 1 to second to VisitDirection.TOP
            VisitDirection.RIGHT -&gt; first + 1 to second to VisitDirection.BOTTOM
        }
        if (nextPoint.isPointCanUse(targetPoint)) {
            res.add(Triple(nextPoint, currentDirection, 0))
        }
        if (leftPoint.isPointCanUse(targetPoint)) {
            res.add(Triple(leftPoint, leftDirection, 1))
        }
        if (rightPoint.isPointCanUse(targetPoint)) {
            res.add(Triple(rightPoint, rightDirection, 1))
        }
        return res
    }

    /**
     * 判断某个点在游戏区域内，而且是空白格子或目标格子
     */
    private fun Pair&lt;Int, Int&gt;.isPointCanUse(targetPoint: Pair&lt;Int, Int&gt;) =
        isPointValid() &amp;&amp; (mahjongArea.getByPair(this).isDeleted || this == targetPoint)
</code></pre>
<h2 id="计时系统的设计">计时系统的设计</h2>
<p>在VM中我有一个方法，当游戏在进行状态，每调用一次时间就减一。而在每成功消除一次，时间就加3，这样难度就不会太高。</p>
<pre><code class="language-kt">    /**
     * 每秒钟被调用，计算游戏倒计时
     */
    fun timeTick() {
        if (_gameState.value != GameState.RUNNING) {
            return
        }
        val gameTime = (_gameTime.value ?: 1) - 1
        _gameTime.value = gameTime
        if (gameTime &lt;= 0) {
            _gameState.value = GameState.FAILED
        }
    }
</code></pre>
<p>我利用了handler的机制来实现每秒调用一次</p>
<pre><code class="language-kt">        object : Runnable {
            override fun run() {
                viewModel.timeTick()
                handler.postDelayed(this, 1000L)
            }
        }.run()
</code></pre>
<p>因为判断了游戏状态，所以暂停和继续也很好做了：</p>
<pre><code class="language-kt">    /**
     * 游戏暂停
     */
    fun pause() {
        if (_gameState.value != GameState.RUNNING) {
            return
        }
        _gameState.value = GameState.PAUSE
    }

    /**
     * 继续游戏
     */
    fun resume() {
        if (_gameState.value != GameState.PAUSE) {
            return
        }
        _gameState.value = GameState.RUNNING
    }

</code></pre>
<h2 id="还有啥">还有啥</h2>
<p>拓展函数确实是一个很好用的东西，很多通用的转换操作可以定义成拓展函数，用起来贼舒服。</p>
<pre><code class="language-kt">/**
 * 将dp值转换为px
 */
val Number.toPxFloat: Float
    get() {
        val r: Resources = Resources.getSystem()
        val px =
            TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, this.toFloat(), r.displayMetrics)
        return px
    }

/**
 * 将dp值转换为px
 */
val Number.toPx: Int
    get() = toPxFloat.roundToInt()

/**
 * 将px值转换为dp
 */
val Number.toDpFloat: Float
    get() {
        val scale: Float = Resources.getSystem().displayMetrics.density
        return (this.toFloat() * scale + 0.5f)
    }

/**
 * 将px值转换为dp
 */
val Number.toDp: Int
    get() = toDpFloat.roundToInt()

/**
 * 使用一个Int对来取二维数组中的元素
 */
fun &lt;T&gt; Array&lt;Array&lt;T&gt;&gt;.getByPair(pair: Pair&lt;Int, Int&gt;) = this[pair.first][pair.second]

</code></pre>
<p><a href="https://developer.android.com/jetpack/compose">JetPack Compose</a>发布了，也许有机会我会重构下这个小游戏的界面，你可以不抱期待等等看。</p>
<div class="footnotes">
<hr />
<ol>
<li id="fn-1">
<p>本图片由<a href="https://imagelol.com/?utm_source=iplaysoft.com&amp;hmsr=iplaysoft.com">笑果图床</a> 提供支持。</p>
<a href="#fnref-1" class="footnote-backref">&#8617;</a>
</li>
</ol>
</div>
</div>
            </div>
            <script src="https://utteranc.es/client.js" repo="zerofancy/zerofancy.github.io" issue-term="安卓连连看游戏设计" theme="github-light" crossorigin="anonymous" async>
                </script>
        </div>
        <!-- 页脚 -->
        <footer class="navbar navbar-light bg-light">
            <p>版权所有：归零幻想 ┊ 备案号：<a href="http://beian.miit.gov.cn/">暂无</a>┊ Powered by：归零幻想</p>
        </footer>
    </div>
</body>

</html>