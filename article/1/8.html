<!doctype html>
<html lang="zh-CN">

<head>
    <!-- Required meta tags -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- Bootstrap CSS -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.3.1/styles/idea.min.css"
        integrity="sha512-Rfc5zQIp95eozfMCdS3B4MItUxU8orNje/t1OEhf7XwIk0DTCuMH2LG0NIgP8UGYK9L39WfUNI1c4IsM5yY/PA=="
        crossorigin="anonymous" referrerpolicy="no-referrer" />
    <title>安卓连连看游戏设计-归零幻想</title>

    <style>
        body {
            background-repeat: no-repeat;
            background-attachment: fixed;
        }
    </style>
</head>

<body>
    <nav class="container navbar navbar-expand-lg navbar-light bg-light">
        <div class="container-fluid">
            <a class="navbar-brand" href="#">
                <img src="/favicon.ico" alt="归零幻想" width="20px" height="20px">
            </a>
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse"
                data-bs-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false"
                aria-label="Toggle navigation">
                <span class="navbar-toggler-icon"></span>
            </button>
            <div class="collapse navbar-collapse" id="navbarSupportedContent">
                <ul class="navbar-nav me-auto mb-2 mb-lg-0">
                    <li class="nav-item">
                        <a class="nav-link active" aria-current="page" href="/">Home</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="/tag.html">标签</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="/about">关于</a>
                    </li>
                    <!--
                    <li class="nav-item dropdown">
                        <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button"
                            data-bs-toggle="dropdown" aria-expanded="false">
                            Dropdown
                        </a>
                        <ul class="dropdown-menu" aria-labelledby="navbarDropdown">
                            <li><a class="dropdown-item" href="#">Action</a></li>
                            <li><a class="dropdown-item" href="#">Another action</a></li>
                            <li>
                                <hr class="dropdown-divider">
                            </li>
                            <li><a class="dropdown-item" href="#">Something else here</a></li>
                        </ul>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link disabled" href="#" tabindex="-1" aria-disabled="true">Disabled</a>
                    </li>
                -->
                </ul>
                <!--
                <form class="d-flex">
                    <input class="form-control me-2" type="search" placeholder="Search" aria-label="Search">
                    <button class="btn btn-outline-success" type="submit">Search</button>
                </form>
                -->
            </div>
        </div>
    </nav>

    <div class="container mt-3">
        <div class="row">
            <div class="card col" id="content-container">
                <div class="card-body"><p>字节取消大小周了，于是周末时间多起来了。虽然想着到处去玩，但现在疫情形势又不好了，于是安心呆在家里当一个肥宅。除了补一补番剧，就是把之前就想过的连连看游戏做出来了。</p>
<p>连连看游戏规则简单，点击两个相同的元素，如果他们能在两次拐弯以内连接起来，那么就可以消除。消除后就会出现空位，可以连接的就更多了。在规定时间内连续操作，直到消除所有元素。</p>
<p>虽然规则比较简单，但真正动手实现一遍还是很费工夫的。游戏既然做好了，那么我水一篇博客不过分吧:&gt;</p>
<p><img src="https://s3.jpg.cm/2021/08/08/IAjmPL.jpg" alt="连连看游戏界面" /> <sup id="fnref-1"><a class="footnote-ref" href="#fn-1">1</a></sup></p>
<p>项目的代码我放到了github。写的贼丑，轻喷。 <a href="https://github.com/zerofancy/match">https://github.com/zerofancy/match</a></p>
<!--summary-->
<h2 id="资源准备">资源准备</h2>
<p>连连看需要一些素材图，可以考虑用水果、动物甚至我同学的头像等，但我想把难度设计高一点，手机屏幕就这么大，图片很小也能有比较高的辨识度，思来想去还是麻将比较合适。</p>
<p>幸运的是，我找到了这么一套免费的图片素材，<a href="http://martinpersson.org/">Mahjong Icons</a>，只要提供一个指向这个页面的超链接就可以免费用。</p>
<p>另外还需要一个应用图标，这个我是直接在<a href="https://iconpark.oceanengine.com/home">Icon Park</a>上找了一个。</p>
<p>接下来将素材导入到项目，为了随处使用方便，我还定义到了一个类中：</p>
<pre><code class="language-kt">package top.ntutn.match

/**
 * 麻将牌
 */
object Mahjong {
    val bamboos = listOf(
        R.drawable.bamboo1,
        R.drawable.bamboo2,
        R.drawable.bamboo3,
        R.drawable.bamboo4,
        R.drawable.bamboo5,
        R.drawable.bamboo6,
        R.drawable.bamboo7,
        R.drawable.bamboo8,
        R.drawable.bamboo9
    )
    val dragons = listOf(
        R.drawable.dragon_chun,
        R.drawable.dragon_green,
        R.drawable.dragon_haku
    )
    val faceDown = R.drawable.face_down
    val mans = listOf(
        R.drawable.man1,
        R.drawable.man2,
        R.drawable.man3,
        R.drawable.man4,
        R.drawable.man5,
        R.drawable.man6,
        R.drawable.man7,
        R.drawable.man8,
        R.drawable.man9
    )
    val pins = listOf(
        R.drawable.pin1,
        R.drawable.pin2,
        R.drawable.pin3,
        R.drawable.pin4,
        R.drawable.pin5,
        R.drawable.pin6,
        R.drawable.pin7,
        R.drawable.pin8,
        R.drawable.pin9
    )
    val redDoras = listOf(
        R.drawable.red_dora_bamboo5,
        R.drawable.red_dora_man5,
        R.drawable.red_dora_pin5
    )
    val winds = listOf(
        R.drawable.wind_east,
        R.drawable.wind_north,
        R.drawable.wind_south,
        R.drawable.wind_west
    )
    val front = bamboos + dragons + mans + pins + redDoras + winds
    val all = front + faceDown
}
</code></pre>
<h2 id="界面设计">界面设计</h2>
<p>参考上面截图，游戏区域其实是相当简单的，但麻将格子太多，如何显示到界面中呢？我采取的是使用多个ImageView，然后用代码动态添加的方式。这样我可以将ImageView也存成一个二维数组，正好跟游戏数据的二维数组对应起来，写起来更方便。</p>
<p>这样我的界面就比较简单了，只要准备上方计时器的TextView和主要区域的ImageView就可以了。在<code>onCreate()</code>生命周期我创建并添加这些ImageView：</p>
<p>这里我计算了中间区域的尺寸，让游戏区域为位于中间区域的一个近似正方形：</p>
<pre><code class="language-kt">        // post一下，不然取不到
        imageContainer.post {
            // 中间正方形区域宽高
            areaWidth = min(imageContainer.width, imageContainer.height - horizontalGap * (N - 1))
            imageViewArray = Array(N) { i -&gt;
                Array(N) { j -&gt;
                    ImageView(this).apply {
                        imageContainer.addView(this)
                        layoutParams = FrameLayout.LayoutParams(areaWidth / N, areaWidth / N)
                        y =
                            (i * (areaWidth / N + horizontalGap)).toFloat() - areaWidth / 2 - horizontalGap * N / 2 + imageContainer.height / 2
                        x = (j * areaWidth / N).toFloat() - areaWidth / 2 + imageContainer.width / 2
                        scaleType = ImageView.ScaleType.CENTER_INSIDE
                        setOnClickListener {
                            viewModel.itemClick(i + 1, j + 1)
                        }
                    }
                }
            }
            // 配置改变不重建
            savedInstanceState ?: kotlin.run {
                viewModel.init(N, N, mahjongSize, maxGameTime, stepGameTime)
                viewModel.start()
            }
        }
</code></pre>
<h2 id="数据结构定义">数据结构定义</h2>
<p>对于每一个麻将牌，我们需要关心他们显示的内容和当前的状态（是否被选中，是否已经消除），因而定义这样的数据结构：</p>
<pre><code class="language-kt">/**
 * 麻将数据类型
 * @param id 本次游戏中的编号（不是资源id）
 * @param isSelected 麻将是否被选中
 * @param isDeleted 麻将是否已经被删除
 */
data class MahjongType(
    val id: Int,
    var isSelected: Boolean = false,
    var isDeleted: Boolean = false
)
</code></pre>
<p>在ViewModel中，我用一个二维数组来存储游戏数据</p>
<pre><code class="language-kt">    var mahjongArea: Array&lt;Array&lt;MahjongType&gt;&gt; = arrayOf()
        private set
</code></pre>
<p>对于选中点，需要记录它的行数和列数</p>
<pre><code class="language-kt">    private var selectedIndex: Pair&lt;Int, Int&gt;? = null
</code></pre>
<p>游戏有三种事件：游戏状态改变（开始、结束、暂停等）、游戏区域刷新、倒计时改变。这些我定义为LiveData。这里的refreshArea是一个Unit类型的LiveData，因为不需要传递什么数据，只要通知这个事件到来就可以了。</p>
<pre><code class="language-kt">    // 游戏区域刷新事件
    private val _refreshArea = MutableLiveData&lt;Unit&gt;()
    val refreshArea: LiveData&lt;Unit&gt;
        get() = _refreshArea

    // 游戏状态改变
    private val _gameState = MutableLiveData&lt;GameState&gt;()
    val gameState: LiveData&lt;GameState&gt;
        get() = _gameState

    // 游戏倒计时
    private val _gameTime = MutableLiveData&lt;Int&gt;()
    val gameTime: LiveData&lt;Int&gt;
        get() = _gameTime

    enum class GameState {
        PENDING,
        RUNNING,
        PAUSE,
        SUCCEEDED,
        FAILED
    }

</code></pre>
<h2 id="游戏数据初始化">游戏数据初始化</h2>
<p>游戏数据初始化时，我们要将所有变量置为初始状态。</p>
<ol>
<li>游戏区域 为了计算方便，我们实际存储的游戏区域比显示出来的游戏区域实际上是多一圈的，多一圈空格子，这样边上的元素计算能否连通的时候就不需要特殊处理</li>
<li>游戏中，麻将元素应该是成对的，所以我首先选择一些元素，然后随机添加到一个list中，每个添加两份，最后再打乱顺序</li>
<li>游戏中，所有需要后面判断和比较差异的复制都应该是深拷贝，否则他们是同一个对象，怎么比都是一样</li>
</ol>
<pre><code class="language-kt">    /**
     * 初始化游戏
     * @param rows 游戏区域行数
     * @param cols 游戏区域列数
     * @param itemCount 使用的麻将牌的数量
     */
    fun init(rows: Int, cols: Int, itemCount: Int, maxGameTime: Int, stepGameTime: Int) {
        require(rows * cols % 2 == 0) { &quot;区域应该有偶数个元素&quot; }
        require(itemCount &lt;= Mahjong.front.size) { &quot;麻将牌资源不足&quot; }
        require(maxGameTime &gt; 5) { &quot;游戏时间过短&quot; }
        require(stepGameTime &gt;= 0) { &quot;stepGameTime参数错误&quot; }

        this.rows = rows
        this.cols = cols
        this.maxGameTime = maxGameTime
        this.stepGameTime = stepGameTime

        // +2是为了给周围放上一圈空格子，计算的时候方便
        mahjongArea = Array(rows + 2) {
            Array(cols + 2) {
                MahjongType(id = Mahjong.faceDown, isDeleted = true)
            }
        }

        val totalItemCollection = Mahjong.front.shuffled().subList(0, itemCount)
        val res = mutableListOf&lt;MahjongType&gt;()
        while (res.size &lt; rows * cols) {
            val item = MahjongType(id = totalItemCollection.random())
            res.add(item)
            // 深拷贝
            res.add(item.copy())
        }
        res.shuffle()
        for (i in res.indices) {
            mahjongArea[i / cols + 1][i % cols + 1] = res[i]
        }
        selectedIndex = null
        _refreshArea.value = Unit
        _gameState.value = GameState.PENDING
    }
</code></pre>
<h2 id="游戏界面显示">游戏界面显示</h2>
<p>我将每个ImageView对应的数据存储到它的tag中，这样在收到区域刷新事件时就可以直接比较判断是否要刷新了。</p>
<pre><code class="language-kt">        viewModel.refreshArea.observe(this) {
            for (i in 0 until N) {
                for (j in 0 until N) {
                    val dataItem = viewModel.mahjongArea[i + 1][j + 1]
                    val viewItem = imageViewArray[i][j]
                    if (viewItem.tag != dataItem) {
                        if (dataItem.isDeleted) {
                            viewItem.setImageDrawable(null)
                        } else {
                            viewItem.setImageResource(dataItem.id)
                        }
                        viewItem.scaleType = ImageView.ScaleType.CENTER_INSIDE
                        viewItem.tag = dataItem.copy() // 深拷贝，否则一直一样
                        if (dataItem.isSelected) {
                            viewItem.colorFilter = grayColorMatrixColorFilter
                        } else {
                            viewItem.clearColorFilter()
                        }
                    }
                }
            }
        }
</code></pre>
<h3 id="消除">消除</h3>
<p>对于被消除的元素，通过<code>viewItem.setImageDrawable(null)</code>清除显示内容。</p>
<h3 id="选中">选中</h3>
<p>对于被选中的元素，我通过设置<code>colorFilter</code>的方式调整图片饱和度来做到高亮显示的目的。这个<code>colorFilter</code>定义如下：</p>
<pre><code class="language-kt">    private val grayColorMatrixColorFilter by lazy {
        val colorMatrix = ColorMatrix().apply {
            setSaturation(25f)
        }
        ColorMatrixColorFilter(colorMatrix)
    }
</code></pre>
<h2 id="麻将牌点击事件">麻将牌点击事件</h2>
<h3 id="选中-1">选中</h3>
<p>首先我们只需要处理没有被消除的元素</p>
<pre><code class="language-kt">        if (mahjongArea[row][col].isDeleted) {
            // 当前点击元素已经消除
            return
        }
</code></pre>
<p>如果之前没有选中元素，那么我们应该直接选中这个元素</p>
<pre><code class="language-kt">        if (selectedIndex == null) {
            // 没有已经选中的，选中点击项
            mahjongArea[row][col].isSelected = true
            selectedIndex = row to col
            _refreshArea.value = Unit
            return
        }
</code></pre>
<h3 id="消除-1">消除</h3>
<p>否则就判断一下两个元素能否配对消除，并判断是否已经全部消除</p>
<pre><code class="language-kt">        val previousSelected = mahjongArea[selectedIndex!!.first][selectedIndex!!.second]
        val currentSelected = mahjongArea[row][col]
        // 判断是否可消除
        if (checkIsCanDelete(row to col, selectedIndex!!)) {
            previousSelected.isSelected = false
            previousSelected.isDeleted = true
            currentSelected.isDeleted = true
            selectedIndex = null
            val gameTime = (_gameTime.value ?: 1) + stepGameTime
            _gameTime.value = gameTime.takeIf { it &lt;= maxGameTime } ?: maxGameTime
            if (mahjongArea.all { it.all { it.isDeleted } }) {
                // 所有麻将已经消除，游戏胜利
                _gameState.value = GameState.SUCCEEDED
            }
        } else {
            previousSelected.isSelected = false
            selectedIndex = null
        }
        _refreshArea.value = Unit
</code></pre>
<p>那么如何判断能否消除呢？</p>
<pre><code class="language-kt">    /**
     * 判断两个元素是否能消除
     */
    private fun checkIsCanDelete(itemIndex1: Pair&lt;Int, Int&gt;, itemIndex2: Pair&lt;Int, Int&gt;): Boolean {
        if (itemIndex1 == itemIndex2) {
            return false
        }
        if (mahjongArea.getByPair(itemIndex1).id != mahjongArea.getByPair(itemIndex2).id) {
            return false
        }
        return VisitDirection.values().any {
            checkIsCanMatch(itemIndex1, itemIndex2, it)
        }
    }
</code></pre>
<p>如果是同一个元素，肯定不能消除；如果两个元素不同，那也不能消除。在排除了这两种情况后，要判断能否通过两次以内的拐弯就到达就需要BFS了。</p>
<ol>
<li>如果当前元素当前方向的下一个元素可以与目标元素拐n次弯相连，那么当前元素可以与目标元素拐n次弯相连</li>
<li>如果当前元素非当前方向的下一个元素可以与目标元素拐n次弯相连，那么当前元素可以与目标元素拐n+1次弯相连</li>
</ol>
<p>这里我用递归实现了这个算法，但实现的……有点丑</p>
<pre><code class="language-kt">
    /**
     * 判断两个在不同位置的相同元素是否能消除
     * BFS
     */
    private fun checkIsCanMatch(
        currentPoint: Pair&lt;Int, Int&gt;,
        targetPoint: Pair&lt;Int, Int&gt;,
        visitDirection: VisitDirection,
        maxRounds: Int = 2
    ): Boolean {
        val nextPoints = currentPoint.getNextPoints(visitDirection, targetPoint).filter {
            if (maxRounds &gt; 0) true else it.third == 0
        }
        if (targetPoint in nextPoints.map { it.first }) {
            return true
        }
        return nextPoints.isNotEmpty() &amp;&amp; nextPoints.any {
            checkIsCanMatch(it.first, targetPoint, it.second, maxRounds - it.third)
        }
    }

    /**
     * 当前结点是否在游戏区域内
     */
    private fun Pair&lt;Int, Int&gt;.isPointValid() =
        this.first in 0..(rows + 1) &amp;&amp; this.second in 0..(cols + 1)

    /**
     * 当前访问方向
     */
    private enum class VisitDirection {
        TOP,
        BOTTOM,
        LEFT,
        RIGHT
    }

    /**
     * 获取当前点的下一个点
     * @param currentDirection 当前朝向的方向
     * @return 一个集合，集合中有0～3个三元组，每个三元组有{点，朝向，需要拐弯次数}
     */
    private fun Pair&lt;Int, Int&gt;.getNextPoints(
        currentDirection: VisitDirection,
        targetPoint: Pair&lt;Int, Int&gt;
    ): Set&lt;Triple&lt;Pair&lt;Int, Int&gt;, VisitDirection, Int&gt;&gt; {
        val res = mutableSetOf&lt;Triple&lt;Pair&lt;Int, Int&gt;, VisitDirection, Int&gt;&gt;()
        val nextPoint = when (currentDirection) {
            VisitDirection.TOP -&gt; first - 1 to second
            VisitDirection.BOTTOM -&gt; first + 1 to second
            VisitDirection.LEFT -&gt; first to second - 1
            VisitDirection.RIGHT -&gt; first to second + 1
        }
        val (leftPoint, leftDirection) = when (currentDirection) {
            VisitDirection.TOP -&gt; first to second - 1 to VisitDirection.LEFT
            VisitDirection.BOTTOM -&gt; first to second + 1 to VisitDirection.RIGHT
            VisitDirection.LEFT -&gt; first + 1 to second to VisitDirection.BOTTOM
            VisitDirection.RIGHT -&gt; first - 1 to second to VisitDirection.TOP
        }
        val (rightPoint, rightDirection) = when (currentDirection) {
            VisitDirection.TOP -&gt; first to second + 1 to VisitDirection.RIGHT
            VisitDirection.BOTTOM -&gt; first to second - 1 to VisitDirection.LEFT
            VisitDirection.LEFT -&gt; first - 1 to second to VisitDirection.TOP
            VisitDirection.RIGHT -&gt; first + 1 to second to VisitDirection.BOTTOM
        }
        if (nextPoint.isPointCanUse(targetPoint)) {
            res.add(Triple(nextPoint, currentDirection, 0))
        }
        if (leftPoint.isPointCanUse(targetPoint)) {
            res.add(Triple(leftPoint, leftDirection, 1))
        }
        if (rightPoint.isPointCanUse(targetPoint)) {
            res.add(Triple(rightPoint, rightDirection, 1))
        }
        return res
    }

    /**
     * 判断某个点在游戏区域内，而且是空白格子或目标格子
     */
    private fun Pair&lt;Int, Int&gt;.isPointCanUse(targetPoint: Pair&lt;Int, Int&gt;) =
        isPointValid() &amp;&amp; (mahjongArea.getByPair(this).isDeleted || this == targetPoint)
</code></pre>
<h2 id="计时系统的设计">计时系统的设计</h2>
<p>在VM中我有一个方法，当游戏在进行状态，每调用一次时间就减一。而在每成功消除一次，时间就加3，这样难度就不会太高。</p>
<pre><code class="language-kt">    /**
     * 每秒钟被调用，计算游戏倒计时
     */
    fun timeTick() {
        if (_gameState.value != GameState.RUNNING) {
            return
        }
        val gameTime = (_gameTime.value ?: 1) - 1
        _gameTime.value = gameTime
        if (gameTime &lt;= 0) {
            _gameState.value = GameState.FAILED
        }
    }
</code></pre>
<p>我利用了handler的机制来实现每秒调用一次</p>
<pre><code class="language-kt">        object : Runnable {
            override fun run() {
                viewModel.timeTick()
                handler.postDelayed(this, 1000L)
            }
        }.run()
</code></pre>
<p>因为判断了游戏状态，所以暂停和继续也很好做了：</p>
<pre><code class="language-kt">    /**
     * 游戏暂停
     */
    fun pause() {
        if (_gameState.value != GameState.RUNNING) {
            return
        }
        _gameState.value = GameState.PAUSE
    }

    /**
     * 继续游戏
     */
    fun resume() {
        if (_gameState.value != GameState.PAUSE) {
            return
        }
        _gameState.value = GameState.RUNNING
    }

</code></pre>
<h2 id="还有啥">还有啥</h2>
<p>拓展函数确实是一个很好用的东西，很多通用的转换操作可以定义成拓展函数，用起来贼舒服。</p>
<pre><code class="language-kt">/**
 * 将dp值转换为px
 */
val Number.toPxFloat: Float
    get() {
        val r: Resources = Resources.getSystem()
        val px =
            TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, this.toFloat(), r.displayMetrics)
        return px
    }

/**
 * 将dp值转换为px
 */
val Number.toPx: Int
    get() = toPxFloat.roundToInt()

/**
 * 将px值转换为dp
 */
val Number.toDpFloat: Float
    get() {
        val scale: Float = Resources.getSystem().displayMetrics.density
        return (this.toFloat() * scale + 0.5f)
    }

/**
 * 将px值转换为dp
 */
val Number.toDp: Int
    get() = toDpFloat.roundToInt()

/**
 * 使用一个Int对来取二维数组中的元素
 */
fun &lt;T&gt; Array&lt;Array&lt;T&gt;&gt;.getByPair(pair: Pair&lt;Int, Int&gt;) = this[pair.first][pair.second]

</code></pre>
<p><a href="https://developer.android.com/jetpack/compose">JetPack Compose</a>发布了，也许有机会我会重构下这个小游戏的界面，你可以不抱期待等等看。</p>
<div class="footnotes">
<hr />
<ol>
<li id="fn-1">
<p>本图片由<a href="https://imagelol.com/?utm_source=iplaysoft.com&amp;hmsr=iplaysoft.com">笑果图床</a> 提供支持。</p>
<a href="#fnref-1" class="footnote-backref">&#8617;</a>
</li>
</ol>
</div>
</div>
            </div>

            <div class="card col-md-4 d-none d-md-block ms-md-3 text-center">
                <div class="sticky-top">
                    <img src="/favicon.ico" alt="avatar" class="mt-3">
                    <div class="card-body">
                        <p class="card-text">
                            归零幻想
                        </p>
                        <p class="card-text">
                            邮件：<a href="mailto:admin@ntutn.top">admin@ntutn.top</a><br>
                            Telegram: <a href="https://t.me/zerofancy">@zerofancy</a>
                        </p>
                        <blockquote id="hitokoto">正在追番《艾克斯奥特曼》。</blockquote>
                        <div style="text-align:right;" id="hitokoto_from">——站长</div>
                        <a href="/atom.xml">RSS</a>
                    </div>
                    <div>
                        <p class="card-body">友情链接</p>
                        <ul>
                            <li><a href="https://blog.semesse.me/">色魔是色魔</a></li>
                            <li><a href="http://www.xyx6.top/">XYX</a></li>
                            <li><a href="http://upccaishu.top/">菜树</a></li>
                            <li><a href="https://www.ruiovo.top/">ruiOvO</a></li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"></script>
    <script>
        // 一言
        let xhr = new XMLHttpRequest()
        xhr.open('get', 'https://v1.hitokoto.cn/')
        xhr.send()
        xhr.onload = function () {
            let hitokotoResult = JSON.parse(xhr.responseText)
            document.getElementById("hitokoto").innerText = hitokotoResult.hitokoto
            document.getElementById("hitokoto_from").innerText = "——" + hitokotoResult.from
        }
        // 页码
        var getRandomColor = function () {
            return '#' +
                (function (color) {
                    return (color += '0123456789abcdef'[Math.floor(Math.random() * 16)]) && (color.length == 6) ? color : arguments.callee(color);
                })('');
        }
        let pageWidth = window.innerWidth,
            pageHeight = window.innerHeight
        if (typeof innerWidth != 'number') {
            if (document.compatMode == 'CSS1Compat') {//严格模式
                pageWidth = document.documentElement.clientWidth
                pageHeight = document.documentElement.clientHeight
            } else {
                pageWidth = document.body.clientWidth
                pageHeight = document.body.clientHeight
            }
        }
        document.body.style.backgroundColor = getRandomColor();
        console.log(`https://source.unsplash.com/random/${pageWidth}x${pageHeight}`)
        document.body.style.backgroundImage = `url(https://source.unsplash.com/random/${pageWidth}x${pageHeight})`;
    </script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.3.1/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.3.1/languages/bash.min.js"
        integrity="sha512-HIFqAH4BgdlJE3A1Uoyl6weoDR1WtdufmKBPWtemvTI+12lrV5dfPR5ekvJaePkq6w+zuPAek2X2hHxo/T5kag=="
        crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.3.1/languages/basic.min.js"
        integrity="sha512-8MrrYyqbmwVrcDGR/2VenE2+IX+ELHJxM0vysdjlAQrJyXZwfKl9dXdyWASFBKzuszu8z3G7XoyjeJVM3b9MlQ=="
        crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.3.1/languages/c.min.js"
        integrity="sha512-+2nEdmDIEQVBw4y3LD2BLOgAvX1+xx9kPQawjQB/HNfi4bDgSF4ywg8yIQ67ijrLLO2ruHaX9dZ25ruG3HwZSg=="
        crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.3.1/languages/cpp.min.js"
        integrity="sha512-OsjySiIaNsR3uFe7uEH6yht3is/WrIXKocWeO0YHFs25jOwHwMtzIdkUENQjblQihTUIN78bpnLKbhMxRegjLw=="
        crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.3.1/languages/gradle.min.js"
        integrity="sha512-QXYGxsyYg6bKlr3W82K2fp25xklKskdnms2qEhgrm2Uz+dnDG3RCHmVP6GQ6waI34+lirlcgsdddvmSXbBhhhQ=="
        crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.3.1/languages/groovy.min.js"
        integrity="sha512-wHPb/EJ15Z5bl59kfxL/THnrtIGdrlOD0CdeBKZ1tsgcLsmx4kbiTmB0gsPZUqCzgIB3MK9tBemnrIr41WFUkQ=="
        crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.3.1/languages/java.min.js"
        integrity="sha512-5j3t2T2xf236N+J+QPE2Po6Q3P/SXze0hgt2XMi1mbYzkC2VqeB/DFYICXfMhV1V+KdxDOBp9PcCAebb8kLvSw=="
        crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.3.1/languages/javascript.min.js"
        integrity="sha512-Jvh5kXa0Zu4HoSxPaZIVhCWPkD7b7gnWHVzv6jiaJwAJ18a/U6BOXludYfJYwHorpy2WFH0Df6EcFi5udu1dWA=="
        crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.3.1/languages/json.min.js"
        integrity="sha512-z3sCqG8cfRJGXv+x7QvVAx92uACSYScuJCRQzSjEhAU23TabHD8+tqafvAbKterqaB4tkiVJYCFNhQaT1+QmfQ=="
        crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.3.1/languages/kotlin.min.js"
        integrity="sha512-ZEBRAqmcLuQ5A9KdZIayen2HuDMAau0Q4C3s/gwnIldFSvOxAOXJk0zhEpu30ACABYAmHKNSZDmup5OEGbx+9g=="
        crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.3.1/languages/xml.min.js"
        integrity="sha512-1UdiK7+k2GhyGJMG9hmQXQ51TP2NPjHjh65uWhCeqSXSZ4UlzDG5+/st9VWRksKWYxKeU37/qwSAuPfSkcWD6A=="
        crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script>
        hljs.highlightAll()
    </script>

    <!--图片调整-->
    <script>
        //获取图片元素
        var imgs = document.getElementsByTagName("img");
        //获取div元素   
        var contentLeft = document.getElementById("content-container");
        //使用js设置图片元素宽度的变化    
        for (var i = 0; i < imgs.length; i++) {
            imgs[i].style["max-width"] = contentLeft.offsetWidth - 60 + "px";
        }
        //40是要减去padding
    </script>

    <!--HTTPS重定向-->
    <script>
        if (!(window.location.host.startsWith("127.0.0.1") || window.location.host.startsWith("localhost")) && (window.location.protocol != "https:")) {
            window.location.protocol = "https";
        }
    </script>
</body>

</html>