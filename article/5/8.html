<!doctype html>
<html lang="zh-CN">

<head>
    <!-- Required meta tags -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- Bootstrap CSS -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.3.1/styles/idea.min.css"
        integrity="sha512-Rfc5zQIp95eozfMCdS3B4MItUxU8orNje/t1OEhf7XwIk0DTCuMH2LG0NIgP8UGYK9L39WfUNI1c4IsM5yY/PA=="
        crossorigin="anonymous" referrerpolicy="no-referrer" />
    <title>android项目开发：Kotlin-归零幻想</title>

    <style>
        body {
            background-repeat: no-repeat;
            background-attachment: fixed;
        }
    </style>
</head>

<body>
    <nav class="container navbar navbar-expand-lg navbar-light bg-light">
        <div class="container-fluid">
            <a class="navbar-brand" href="#">
                <img src="/favicon.ico" alt="归零幻想" width="20px" height="20px">
            </a>
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse"
                data-bs-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false"
                aria-label="Toggle navigation">
                <span class="navbar-toggler-icon"></span>
            </button>
            <div class="collapse navbar-collapse" id="navbarSupportedContent">
                <ul class="navbar-nav me-auto mb-2 mb-lg-0">
                    <li class="nav-item">
                        <a class="nav-link active" aria-current="page" href="/">Home</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="/tag.html">标签</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="/about">关于</a>
                    </li>
                    <!--
                    <li class="nav-item dropdown">
                        <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button"
                            data-bs-toggle="dropdown" aria-expanded="false">
                            Dropdown
                        </a>
                        <ul class="dropdown-menu" aria-labelledby="navbarDropdown">
                            <li><a class="dropdown-item" href="#">Action</a></li>
                            <li><a class="dropdown-item" href="#">Another action</a></li>
                            <li>
                                <hr class="dropdown-divider">
                            </li>
                            <li><a class="dropdown-item" href="#">Something else here</a></li>
                        </ul>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link disabled" href="#" tabindex="-1" aria-disabled="true">Disabled</a>
                    </li>
                -->
                </ul>
                <!--
                <form class="d-flex">
                    <input class="form-control me-2" type="search" placeholder="Search" aria-label="Search">
                    <button class="btn btn-outline-success" type="submit">Search</button>
                </form>
                -->
            </div>
        </div>
    </nav>

    <div class="container mt-3">
        <div class="row">
            <div class="card col" id="content-container">
                <div class="card-body"><h1 id="kotlin">Kotlin</h1>
<h2 id="变量和函数">变量和函数</h2>
<h3 id="变量">变量</h3>
<p>用<code>var</code>和<code>val</code>定义变量，并有类型自动推导的支持。</p>
<p><code>val</code>用来声明一个不可变的变量，<code>var</code>用来声明一个可变的变量。</p>
<pre><code class="language-kotlin">val a = 10
var b: Int = 12
</code></pre>
<p>Kotlin完全抛弃了java中的基本数据类型，完全使用对象数据类型。</p>
<table>
<thead>
<tr><th>java基本数据类型</th><th>Kotlin对象数据类型</th><th>数据类型说明</th></tr>
</thead>
<tbody>
<tr><td>int</td><td>Int</td><td>整型</td></tr>
<tr><td>long</td><td>Long</td><td>长整型</td></tr>
<tr><td>short</td><td>Short</td><td>短整型</td></tr>
<tr><td>float</td><td>Float</td><td>单精度浮点型</td></tr>
<tr><td>double</td><td>Double</td><td>双精度浮点型</td></tr>
<tr><td>boolean</td><td>Boolean</td><td>布尔型</td></tr>
<tr><td>char</td><td>Char</td><td>字符型</td></tr>
<tr><td>byte</td><td>Byte</td><td>字节型</td></tr>
</tbody>
</table>
<h3 id="函数">函数</h3>
<p>语法：</p>
<pre><code class="language-kotlin">fun main(args: Array&lt;String&gt;) {
    println(&quot;Hello World!&quot;)
}
</code></pre>
<p>Kotlin中的函数在无必要时可以省略很多东西：</p>
<pre><code class="language-kotlin">import kotlin.math.max

fun largerNumber(a: Int, b: Int) = max(a, b)

fun main(args: Array&lt;String&gt;) {
    val a = 3
    val b = 5
    println(&quot;The larger number of a and b is ${largerNumber(a, b)}&quot;)
}
</code></pre>
<h2 id="程序的逻辑控制">程序的逻辑控制</h2>
<h3 id="if">if</h3>
<p>与java中的if语句相比，Kotlin中的if是可以有返回值的。</p>
<pre><code class="language-kotlin">fun judge(score: Int) = if (score &gt;= 60) &quot;你及格了&quot; else &quot;你还需要多努力&quot;

fun main() {
    println(judge(55))
    println(judge(66))
}
</code></pre>
<p>与此同时，Kotlin不再有java中的三元运算符<sup id="fnref-1"><a class="footnote-ref" href="#fn-1">1</a></sup>，语义上清晰了很多。</p>
<h3 id="when条件语句">when条件语句</h3>
<p>类似于java中的switch语句，根据变量的值执行不同的逻辑。</p>
<pre><code class="language-kotlin">fun judge(score: Int) = if (score &gt;= 60) &quot;你及格了&quot; else &quot;你还需要多努力&quot;

fun getScore(name: String) = when (name) {
    &quot;Tom&quot; -&gt; 78
    &quot;Jack&quot; -&gt; 35
    &quot;Jerry&quot; -&gt; 84
    &quot;Lee&quot; -&gt; 57
    else -&gt; 0
}

fun main() {
    println(judge(getScore(&quot;Tom&quot;)))
    println(judge(getScore(&quot;Jack&quot;)))
    println(judge(getScore(&quot;Bill&quot;)))
}
</code></pre>
<p>对我来说，最令人振奋的是再也不需要在每个分支里面都写个break了。其次when也是有返回值的，这和其他特性组合写出来的代码非常简洁优雅。</p>
<p>写个小demo吧。</p>
<pre><code class="language-kotlin">interface Speakable {
    fun speak()
}

class Dog : Speakable {
    override fun speak() {
        println(&quot;汪汪汪&quot;)
    }
}

class Cat : Speakable {
    override fun speak() {
        println(&quot;喵喵喵&quot;)
    }

    fun climb() {
        println(&quot;小猫会爬树&quot;)
    }
}

fun generateAnimal(): Speakable? = when ((1..3).random()) {
    1 -&gt; Dog()
    2 -&gt; Cat()
    else -&gt; null
}

fun main() {
    when (val animal = generateAnimal()) {
        is Dog -&gt; {
            println(&quot;生成的动物是小狗&quot;)
            animal.speak()
        }
        is Cat -&gt; {
            println(&quot;生成的动物是小猫&quot;)
            animal.speak()
            animal.climb()
        }
        else -&gt; println(&quot;生成动物时出现问题&quot;)
    }
}
</code></pre>
<h3 id="循环语句">循环语句</h3>
<p>Kotlin中有两类循环，其中<code>while</code>循环与java学过的while循环非常相似，只说下有差异的<code>for</code>循环吧。</p>
<p>Kotlin的for循环只有for..in式的了，如<code>for(i in list)</code>。</p>
<p>但有时对数组下标进行遍历还是有必要的。于是我们要先了解下Kotlin的<code>区间</code>的概念。</p>
<pre><code class="language-kotlin">val range = 1..10
</code></pre>
<p>这表示<code>[1,10]</code>。但很多时候，我们需要左开右闭区间，比如数组有三个元素，我们需要<code>[0,3)</code>表示数组的下标。此时可以使用<code>util</code>关键字。</p>
<pre><code class="language-kotlin">val indexRange = 0 util 3
</code></pre>
<p>有了range再和前面的for配合就完全可以替代之前java里面的for的作用了：</p>
<pre><code class="language-kotlin">val array = arrayOf(&quot;Bob&quot;, &quot;John&quot;, &quot;Jackson&quot;)
for (i in 0 util array.size) {
    println(&quot;$i:${array[i]}&quot;)
}
</code></pre>
<p>此外，还可以用<code>step</code>指定步长值，实现”隔几个输出一次“的效果：</p>
<pre><code class="language-kotlin">for (i in 0 util 10 step 2) {
    println(i)
}
</code></pre>
<p>如果需要10循环到1,则需要<code>downTo</code>关键字，</p>
<pre><code class="language-kotlin">for (i in 10 downTo 1) {
    println(i)
}
</code></pre>
<!--summary-->
<h2 id="面向对象编程">面向对象编程</h2>
<h3 id="类与对象">类与对象</h3>
<p>与java的class相比Kotlin的class看上去没有多少改变，但创建对象不用new了。</p>
<pre><code class="language-kotlin">class Person(val name: String) {
    fun speak() = &quot;$name is speaking.&quot;
}

fun main() {
    Person(&quot;Jack&quot;).speak()
}
</code></pre>
<h3 id="继承与构造函数">继承与构造函数</h3>
<p>与java类似，Kotlin仍然是单继承，可以继承一个类实现多个接口。但继承的写法与java略有不同。</p>
<pre><code class="language-kotlin">open class Animal//非抽象类只有带了open才可以继承

interface Speakable {
    fun speak()
}

class Dog : Animal(), Speakable {
    override fun speak() {
        println(&quot;汪汪汪&quot;)
    }
}

class Cat : Animal(), Speakable {
    override fun speak() {
        println(&quot;喵喵喵&quot;)
    }

    fun climb() {
        println(&quot;小猫会爬树&quot;)
    }
}
</code></pre>
<p>Kotlin中的构造函数分为主构造函数和次构造函数。如：</p>
<pre><code class="language-kotlin">class Student(val sno: String, val grade: Int, name: String, age: Int) {
    constructor(name: String, age: Int) : this(&quot;&quot;, 0, name, age)

    constructor() : this(&quot;&quot;, 0)

    init {
        println(&quot;$age 的 $name 被初始化了。&quot;)
    }
}
</code></pre>
<p>次构造函数必须调用主构造函数（如果有），继承一个类必须调用他的构造函数（这也是为什么常常继承的类后面带着个括号）。</p>
<blockquote>
<p>Kotlin函数的参数可以有默认值的，大多数情况根本不需要使用多个构造函数。</p>
</blockquote>
<p>主构造函数中<code>val</code>和<code>var</code>标记的变量将直接成为类的属性，没有这个标记的变量则只能在init block中访问。</p>
<h3 id="接口">接口</h3>
<p>接口与java的接口是类似的。</p>
<pre><code class="language-kotlin">interface Study {
    fun readBooks()

    fun doHomework() {
        println(&quot;Do homework default implementation&quot;)
    }
}
</code></pre>
<p>java与Kotlin中的可见性修饰略有不同。</p>
<table>
<thead>
<tr><th>修饰符</th><th>java</th><th>Kotlin</th></tr>
</thead>
<tbody>
<tr><td>public</td><td>所有类可见</td><td>所有类可见（默认）</td></tr>
<tr><td>private</td><td>当前类可见</td><td>当前类可见</td></tr>
<tr><td>protected</td><td>当前类、子类、同一包路径下的类可见</td><td>当前类、子类可见</td></tr>
<tr><td>default</td><td>同一包路径下的类可见</td><td>无</td></tr>
<tr><td>internal</td><td>无</td><td>同一模块中的类可见</td></tr>
</tbody>
</table>
<h3 id="数据类与单例类">数据类与单例类</h3>
<p>数据类在当今的系统设计中占据了重要的地位，他们格式非常固定，一般实现各种构造函数、getter和setter，重写<code>equals()</code>、<code>hashCode()</code>、<code>toString()</code>
这几个方法，真的写腻了。很多ide都提供了一键生成这些样板代码的方法，更有项目Lombok添加个注解在编译时生成这些方法<sup id="fnref-2"><a class="footnote-ref" href="#fn-2">2</a></sup>。</p>
<p>而Kotlin中对于数据类有了专门的支持。</p>
<pre><code class="language-kotlin">data class Student(val sno: String, val name: String, var age: Int)
</code></pre>
<p>idea对于Kotlin有很好的支持。我们用下面的步骤将上面的代码转换为java形式：</p>
<ol>
<li>Tools-&gt;Kotlin-&gt;Show Kotlin ByteCode</li>
<li>Decompile</li>
</ol>
<p>得到的代码如下：</p>
<pre><code class="language-java">import kotlin.Metadata;
import kotlin.jvm.internal.Intrinsics;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

@Metadata(
        mv = {1, 4, 0},
        bv = {1, 0, 3},
        k = 1,
        d1 = {&quot;\u0000\&quot;\n\u0002\u0018\u0002\n\u0002\u0010\u0000\n\u0000\n\u0002\u0010\u000e\n\u0002\b\u0002\n\u0002\u0010\b\n\u0002\b\r\n\u0002\u0010\u000b\n\u0002\b\u0004\b\u0086\b\u0018\u00002\u00020\u0001B\u001d\u0012\u0006\u0010\u0002\u001a\u00020\u0003\u0012\u0006\u0010\u0004\u001a\u00020\u0003\u0012\u0006\u0010\u0005\u001a\u00020\u0006¢\u0006\u0002\u0010\u0007J\t\u0010\u000f\u001a\u00020\u0003HÆ\u0003J\t\u0010\u0010\u001a\u00020\u0003HÆ\u0003J\t\u0010\u0011\u001a\u00020\u0006HÆ\u0003J'\u0010\u0012\u001a\u00020\u00002\b\b\u0002\u0010\u0002\u001a\u00020\u00032\b\b\u0002\u0010\u0004\u001a\u00020\u00032\b\b\u0002\u0010\u0005\u001a\u00020\u0006HÆ\u0001J\u0013\u0010\u0013\u001a\u00020\u00142\b\u0010\u0015\u001a\u0004\u0018\u00010\u0001HÖ\u0003J\t\u0010\u0016\u001a\u00020\u0006HÖ\u0001J\t\u0010\u0017\u001a\u00020\u0003HÖ\u0001R\u001a\u0010\u0005\u001a\u00020\u0006X\u0086\u000e¢\u0006\u000e\n\u0000\u001a\u0004\b\b\u0010\t\&quot;\u0004\b\n\u0010\u000bR\u0011\u0010\u0004\u001a\u00020\u0003¢\u0006\b\n\u0000\u001a\u0004\b\f\u0010\rR\u0011\u0010\u0002\u001a\u00020\u0003¢\u0006\b\n\u0000\u001a\u0004\b\u000e\u0010\r¨\u0006\u0018&quot;},
        d2 = {&quot;LStudent;&quot;, &quot;&quot;, &quot;sno&quot;, &quot;&quot;, &quot;name&quot;, &quot;age&quot;, &quot;&quot;, &quot;(Ljava/lang/String;Ljava/lang/String;I)V&quot;, &quot;getAge&quot;, &quot;()I&quot;, &quot;setAge&quot;, &quot;(I)V&quot;, &quot;getName&quot;, &quot;()Ljava/lang/String;&quot;, &quot;getSno&quot;, &quot;component1&quot;, &quot;component2&quot;, &quot;component3&quot;, &quot;copy&quot;, &quot;equals&quot;, &quot;&quot;, &quot;other&quot;, &quot;hashCode&quot;, &quot;toString&quot;, &quot;kotlin-learning.main&quot;}
)
public final class Student {
    @NotNull
    private final String sno;
    @NotNull
    private final String name;
    private int age;

    @NotNull
    public final String getSno() {
        return this.sno;
    }

    @NotNull
    public final String getName() {
        return this.name;
    }

    public final int getAge() {
        return this.age;
    }

    public final void setAge(int var1) {
        this.age = var1;
    }

    public Student(@NotNull String sno, @NotNull String name, int age) {
        Intrinsics.checkNotNullParameter(sno, &quot;sno&quot;);
        Intrinsics.checkNotNullParameter(name, &quot;name&quot;);
        super();
        this.sno = sno;
        this.name = name;
        this.age = age;
    }

    @NotNull
    public final String component1() {
        return this.sno;
    }

    @NotNull
    public final String component2() {
        return this.name;
    }

    public final int component3() {
        return this.age;
    }

    @NotNull
    public final Student copy(@NotNull String sno, @NotNull String name, int age) {
        Intrinsics.checkNotNullParameter(sno, &quot;sno&quot;);
        Intrinsics.checkNotNullParameter(name, &quot;name&quot;);
        return new Student(sno, name, age);
    }

    // $FF: synthetic method
    public static Student copy$default(Student var0, String var1, String var2, int var3, int var4, Object var5) {
        if ((var4 &amp; 1) != 0) {
            var1 = var0.sno;
        }

        if ((var4 &amp; 2) != 0) {
            var2 = var0.name;
        }

        if ((var4 &amp; 4) != 0) {
            var3 = var0.age;
        }

        return var0.copy(var1, var2, var3);
    }

    @NotNull
    public String toString() {
        return &quot;Student(sno=&quot; + this.sno + &quot;, name=&quot; + this.name + &quot;, age=&quot; + this.age + &quot;)&quot;;
    }

    public int hashCode() {
        String var10000 = this.sno;
        int var1 = (var10000 != null ? var10000.hashCode() : 0) * 31;
        String var10001 = this.name;
        return (var1 + (var10001 != null ? var10001.hashCode() : 0)) * 31 + this.age;
    }

    public boolean equals(@Nullable Object var1) {
        if (this != var1) {
            if (var1 instanceof Student) {
                Student var2 = (Student) var1;
                if (Intrinsics.areEqual(this.sno, var2.sno) &amp;&amp; Intrinsics.areEqual(this.name, var2.name) &amp;&amp; this.age == var2.age) {
                    return true;
                }
            }

            return false;
        } else {
            return true;
        }
    }
}

</code></pre>
<p>孰优孰劣，一目了然。</p>
<p>类似的，Kotlin也对单例类提供了支持。如：</p>
<pre><code class="language-kotlin">object Singleton {
    fun singletonTest() {
        println(&quot;Singleton test is called.&quot;)
    }
}
</code></pre>
<p>这和你费了半天劲写出来的java代码作用是一样的：</p>
<pre><code class="language-java">import kotlin.Metadata;

@Metadata(
        mv = {1, 4, 0},
        bv = {1, 0, 3},
        k = 1,
        d1 = {&quot;\u0000\u0012\n\u0002\u0018\u0002\n\u0002\u0010\u0000\n\u0002\b\u0002\n\u0002\u0010\u0002\n\u0000\bÆ\u0002\u0018\u00002\u00020\u0001B\u0007\b\u0002¢\u0006\u0002\u0010\u0002J\u0006\u0010\u0003\u001a\u00020\u0004¨\u0006\u0005&quot;},
        d2 = {&quot;LSingleton;&quot;, &quot;&quot;, &quot;()V&quot;, &quot;singletonTest&quot;, &quot;&quot;, &quot;kotlin-learning.main&quot;}
)
public final class Singleton {
    public static final Singleton INSTANCE;

    public final void singletonTest() {
        String var1 = &quot;Singleton test is called.&quot;;
        boolean var2 = false;
        System.out.println(var1);
    }

    private Singleton() {
    }

    static {
        Singleton var0 = new Singleton();
        INSTANCE = var0;
    }
}

</code></pre>
<h2 id="lambda编程">Lambda编程</h2>
<pre><code class="language-kotlin">fun main() {
    val map = mapOf(&quot;Apple&quot; to 1, &quot;Banana&quot; to 2, &quot;Orange&quot; to 3, &quot;Pear&quot; to 4, &quot;Grape&quot; to 5)
    for ((fruit, number) in map) {
        println(&quot;fruit is $fruit, number is $number&quot;)
    }
}
</code></pre>
<h3 id="函数式api">函数式API</h3>
<h4 id="maxby">maxBy</h4>
<p>集合中最长的字符串。</p>
<h3 id="map">map</h3>
<p>将集合中每个元素都映射到另一个元素。</p>
<h4 id="filter">filter</h4>
<p>过滤集合中的数据。</p>
<h4 id="any">any</h4>
<p>至少有一个元素满足条件。</p>
<h4 id="all">all</h4>
<p>所有元素都满足条件。</p>
<h3 id="java函数式api">Java函数式API</h3>
<p>对于java中的单抽象方法可使用函数式API。</p>
<pre><code class="language-kotlin">Thread {
    println(&quot;Thread is running&quot;)
}.start()
</code></pre>
<h2 id="空指针检查">空指针检查</h2>
<p>写java时最常见的错误就是<code>java.lang.NullPointerException</code>了吧。在Kotlin中，情况有一些改善。</p>
<p>与java不同，Kotlin中的变量默认是不可空的。</p>
<pre><code class="language-kotlin">fun doStudy(study: Study) {
    study.readBooks()
    study.doHomework()
}
</code></pre>
<p>如果你给这个函数传一个可能为null的值，在编译期间就会得到错误提示。</p>
<p>当然，很多情况我们还是需要让我们的函数接受一个可空的值的，则可以用这样的写法：</p>
<pre><code class="language-kotlin">fun doStudy(study: Study?) {
    if (study != null) {
        study.readBooks()
        study.doHomework()
    }
}
</code></pre>
<p>但在Kotlin中还有更好的方法：</p>
<pre><code class="language-kotlin">fun doStudy(study: Study?) {
    study?.readBooks()
    study?.doHomework()
}
</code></pre>
<p>用上<code>let</code>我们还可以写得更优雅：</p>
<pre><code class="language-kotlin">fun doStudy(study: Study?) {
    study?.let {
        it.readBooks()
        it.doHomework()
    }
}
</code></pre>
<p><code>?.</code>表示只有不为空时才正常调用。</p>
<p>有时我们需要这样的逻辑：</p>
<pre><code class="language-kotlin">fun getTextLength(text: String?): Int {
    if (text != null) {
        return text.length
    }
    return 0
}
</code></pre>
<p>Kotlin也有个方便的操作符：</p>
<pre><code class="language-kotlin">fun getTextLength(text: String?) = text?.length ?: 0
</code></pre>
<p><code>?:</code>表示前面为空时返回后面的值。</p>
<p>当然，有些业务逻辑中Kotlin不一定能正确推断出你的变量是否可能为空，这时Kotlin也提供了让你自己操纵它的机会：</p>
<pre><code class="language-kotlin">var content: String? = null

fun initContent() {
    content = &quot;https://ntutn.top&quot;
}

fun main() {
    initContent()
    if (content != null) {
        printContent()
    }
}

fun printContent() {
    println(content!!)
}
</code></pre>
<div class="footnotes">
<hr />
<ol>
<li id="fn-1">
<p>参考<a href="https://www.w3cschool.cn/java/java-ternary-operator.html">Java中的三元运算符</a></p>
<a href="#fnref-1" class="footnote-backref">&#8617;</a>
</li>
<li id="fn-2">
<p><a href="https://projectlombok.org/">Lombok</a>，用注解的方式简化java代码，但要求使用的ide必须安装lombok插件才能正确识别lombok生成的代码，有人认为这是在”强奸队友“。另外lombok的实现调用了jdk未公开的方法也引发争议。</p>
<a href="#fnref-2" class="footnote-backref">&#8617;</a>
</li>
</ol>
</div>
</div>
            </div>

            <div class="card col-md-4 d-none d-md-block ms-md-3 text-center">
                <div class="sticky-top">
                    <img src="/favicon.ico" alt="avatar" class="mt-3">
                    <div class="card-body">
                        <p class="card-text">
                            归零幻想
                        </p>
                        <p class="card-text">
                            邮件：<a href="mailto:admin@ntutn.top">admin@ntutn.top</a><br>
                            Telegram: <a href="https://t.me/zerofancy">@zerofancy</a>
                        </p>
                        <blockquote id="hitokoto">正在追番《艾克斯奥特曼》。</blockquote>
                        <div style="text-align:right;" id="hitokoto_from">——站长</div>
                        <a href="/atom.xml">RSS</a>
                    </div>
                    <div>
                        <p class="card-body">友情链接</p>
                        <ul>
                            <li><a href="https://blog.semesse.me/">色魔是色魔</a></li>
                            <li><a href="http://www.xyx6.top/">XYX</a></li>
                            <li><a href="http://upccaishu.top/">菜树</a></li>
                            <li><a href="https://www.ruiovo.top/">ruiOvO</a></li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"></script>
    <script>
        // 一言
        let xhr = new XMLHttpRequest()
        xhr.open('get', 'https://v1.hitokoto.cn/')
        xhr.send()
        xhr.onload = function () {
            let hitokotoResult = JSON.parse(xhr.responseText)
            document.getElementById("hitokoto").innerText = hitokotoResult.hitokoto
            document.getElementById("hitokoto_from").innerText = "——" + hitokotoResult.from
        }
        // 页码
        var getRandomColor = function () {
            return '#' +
                (function (color) {
                    return (color += '0123456789abcdef'[Math.floor(Math.random() * 16)]) && (color.length == 6) ? color : arguments.callee(color);
                })('');
        }
        let pageWidth = window.innerWidth,
            pageHeight = window.innerHeight
        if (typeof innerWidth != 'number') {
            if (document.compatMode == 'CSS1Compat') {//严格模式
                pageWidth = document.documentElement.clientWidth
                pageHeight = document.documentElement.clientHeight
            } else {
                pageWidth = document.body.clientWidth
                pageHeight = document.body.clientHeight
            }
        }
        document.body.style.backgroundColor = getRandomColor();
        console.log(`https://source.unsplash.com/random/${pageWidth}x${pageHeight}`)
        document.body.style.backgroundImage = `url(https://source.unsplash.com/random/${pageWidth}x${pageHeight})`;
    </script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.3.1/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.3.1/languages/bash.min.js"
        integrity="sha512-HIFqAH4BgdlJE3A1Uoyl6weoDR1WtdufmKBPWtemvTI+12lrV5dfPR5ekvJaePkq6w+zuPAek2X2hHxo/T5kag=="
        crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.3.1/languages/basic.min.js"
        integrity="sha512-8MrrYyqbmwVrcDGR/2VenE2+IX+ELHJxM0vysdjlAQrJyXZwfKl9dXdyWASFBKzuszu8z3G7XoyjeJVM3b9MlQ=="
        crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.3.1/languages/c.min.js"
        integrity="sha512-+2nEdmDIEQVBw4y3LD2BLOgAvX1+xx9kPQawjQB/HNfi4bDgSF4ywg8yIQ67ijrLLO2ruHaX9dZ25ruG3HwZSg=="
        crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.3.1/languages/cpp.min.js"
        integrity="sha512-OsjySiIaNsR3uFe7uEH6yht3is/WrIXKocWeO0YHFs25jOwHwMtzIdkUENQjblQihTUIN78bpnLKbhMxRegjLw=="
        crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.3.1/languages/gradle.min.js"
        integrity="sha512-QXYGxsyYg6bKlr3W82K2fp25xklKskdnms2qEhgrm2Uz+dnDG3RCHmVP6GQ6waI34+lirlcgsdddvmSXbBhhhQ=="
        crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.3.1/languages/groovy.min.js"
        integrity="sha512-wHPb/EJ15Z5bl59kfxL/THnrtIGdrlOD0CdeBKZ1tsgcLsmx4kbiTmB0gsPZUqCzgIB3MK9tBemnrIr41WFUkQ=="
        crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.3.1/languages/java.min.js"
        integrity="sha512-5j3t2T2xf236N+J+QPE2Po6Q3P/SXze0hgt2XMi1mbYzkC2VqeB/DFYICXfMhV1V+KdxDOBp9PcCAebb8kLvSw=="
        crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.3.1/languages/javascript.min.js"
        integrity="sha512-Jvh5kXa0Zu4HoSxPaZIVhCWPkD7b7gnWHVzv6jiaJwAJ18a/U6BOXludYfJYwHorpy2WFH0Df6EcFi5udu1dWA=="
        crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.3.1/languages/json.min.js"
        integrity="sha512-z3sCqG8cfRJGXv+x7QvVAx92uACSYScuJCRQzSjEhAU23TabHD8+tqafvAbKterqaB4tkiVJYCFNhQaT1+QmfQ=="
        crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.3.1/languages/kotlin.min.js"
        integrity="sha512-ZEBRAqmcLuQ5A9KdZIayen2HuDMAau0Q4C3s/gwnIldFSvOxAOXJk0zhEpu30ACABYAmHKNSZDmup5OEGbx+9g=="
        crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.3.1/languages/xml.min.js"
        integrity="sha512-1UdiK7+k2GhyGJMG9hmQXQ51TP2NPjHjh65uWhCeqSXSZ4UlzDG5+/st9VWRksKWYxKeU37/qwSAuPfSkcWD6A=="
        crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script>
        hljs.highlightAll()
    </script>

    <!--图片调整-->
    <script>
        //获取图片元素
        var imgs = document.getElementsByTagName("img");
        //获取div元素   
        var contentLeft = document.getElementById("content-container");
        //使用js设置图片元素宽度的变化    
        for (var i = 0; i < imgs.length; i++) {
            imgs[i].style["max-width"] = contentLeft.offsetWidth - 60 + "px";
        }
        //40是要减去padding
    </script>

    <!--HTTPS重定向-->
    <script>
        if (!(window.location.host.startsWith("127.0.0.1") || window.location.host.startsWith("localhost")) && (window.location.protocol != "https:")) {
            window.location.protocol = "https";
        }
    </script>
</body>

</html>