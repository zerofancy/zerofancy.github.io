<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Todo on 归零幻想</title>
    <link>https://ntutn.top/categories/todo/</link>
    <description>Recent content in Todo on 归零幻想</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <copyright>CC BY-SA 4.0</copyright>
    <lastBuildDate>Sun, 06 Nov 2022 07:01:29 +0800</lastBuildDate><atom:link href="https://ntutn.top/categories/todo/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>[折腾中] WanAndroid客户端</title>
      <link>https://ntutn.top/project/wanandroid%E5%AE%A2%E6%88%B7%E7%AB%AF/</link>
      <pubDate>Sun, 06 Nov 2022 07:01:29 +0800</pubDate>
      
      <guid>https://ntutn.top/project/wanandroid%E5%AE%A2%E6%88%B7%E7%AB%AF/</guid>
      <description>
WanAndroid 是一个我很喜欢的安卓方面的技术分享站点，站长是个安卓方面的大佬，看介绍这大佬还是我们公司里的，虽然我这菜鸡是没有和他打交道的机会。
WanAndroid对外提供了站内各个模块的API，鼓励大家自己写个APP，作为一个宝贵的练手机会，我也难免手痒，尝试自己实现了下。
地址： https://github.com/zerofancy/WandroidZ
banner Webview文章浏览 首页置顶文章 首页推荐文章 登陆 </description>
    </item>
    
    <item>
      <title>从头开始制作一个tg机器人</title>
      <link>https://ntutn.top/posts/%E4%BB%8E%E5%A4%B4%E5%BC%80%E5%A7%8B%E5%88%B6%E4%BD%9C%E4%B8%80%E4%B8%AAtg%E6%9C%BA%E5%99%A8%E4%BA%BA/</link>
      <pubDate>Tue, 30 Aug 2022 02:49:11 +0800</pubDate>
      
      <guid>https://ntutn.top/posts/%E4%BB%8E%E5%A4%B4%E5%BC%80%E5%A7%8B%E5%88%B6%E4%BD%9C%E4%B8%80%E4%B8%AAtg%E6%9C%BA%E5%99%A8%E4%BA%BA/</guid>
      <description>工作之外，总想折腾点什么东西。最近看朋友搞的QQ摸鱼机器人有点意思，就想自己也搞一个。tg提供的API比较全面，所以就想搞个tg版。
直接贴代码：https://github.com/rfkhx/starsea
基本消息处理和分发 其实仅就这个需求而言，并没有用多线程的必要性，一个死循环中拉取消息，拉到后交给对应模块处理，处理完继续下一次循环拉下一条消息就可以了。不过为了把代码结构写得更清楚一点，并希望能在这个过程中学到点东西，我决定仿照安卓的线程机制组织，将安卓中的 Handler、Looper 移植到我的项目中，借助这个过程更深入理解整个机制。
类似安卓，我在后台线程进行网络请求，主线程进行结果的分发处理。
Message Message 就是消息对象。我对消息对象的定义如下：
data class Message( val what: Int, val arg: Int = -1, val payload: Any? = null, var time: Long = 0L, var target: Handler? = null, val callback: Runnable? = null ) 要理解整个消息机制，还是得先看这几个参数。
what 表示这是一条什么样的消息。一个 Handler 中可能定义和处理多种不同的消息，通过这个参数进行区分。 arg、payload 表示消息携带的参数。 arg 是简单的， Int 类型的参数，而 payload 则用于传递复杂对象。按需使用 time 表示 Message 预期被处理的时间。只有到了这个时间之后消息才可以被取出处理。这对应我们经常用的 handler.postDelayed 方法 target 处理消息的 Handler callback 消息处理时执行特定回调。实际上和继承相关 Handler 并在相关方法中处理消息是等同的 MessageQueue 记得安卓中有个比较经典和基础的问题，主线程实际执行了 Looper.</description>
    </item>
    
    <item>
      <title>Retrofit源码阅读</title>
      <link>https://ntutn.top/posts/retrofit%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/</link>
      <pubDate>Thu, 09 Jun 2022 17:02:54 +0800</pubDate>
      
      <guid>https://ntutn.top/posts/retrofit%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/</guid>
      <description>Retrofit是一个相当简洁的网络请求框架，其本质上只是对Okhttp的封装，实际上底层还是用Okhttp来执行网络请求。这两天终于比较闲一些，于是又想起了被我束之高阁的前辈的武功秘籍。
Retrofit的使用 参考官方例子，定义接口并使用
public interface GitHub { @GET(&amp;#34;/repos/{owner}/{repo}/contributors&amp;#34;) Call&amp;lt;List&amp;lt;Contributor&amp;gt;&amp;gt; contributors(@Path(&amp;#34;owner&amp;#34;) String owner, @Path(&amp;#34;repo&amp;#34;) String repo); } // Create a very simple REST adapter which points the GitHub API. Retrofit retrofit = new Retrofit.Builder() .baseUrl(API_URL) .addConverterFactory(GsonConverterFactory.create()) .build(); // Create an instance of our GitHub API interface. GitHub github = retrofit.create(GitHub.class); // Create a call instance for looking up Retrofit contributors. Call&amp;lt;List&amp;lt;Contributor&amp;gt;&amp;gt; call = github.contributors(&amp;#34;square&amp;#34;, &amp;#34;retrofit&amp;#34;); // Fetch and print a list of the contributors to the library.</description>
    </item>
    
    <item>
      <title>使用自动操作修改壁纸</title>
      <link>https://ntutn.top/posts/%E4%BD%BF%E7%94%A8%E8%87%AA%E5%8A%A8%E6%93%8D%E4%BD%9C%E4%BF%AE%E6%94%B9%E5%A3%81%E7%BA%B8/</link>
      <pubDate>Mon, 06 Jun 2022 12:28:23 +0800</pubDate>
      
      <guid>https://ntutn.top/posts/%E4%BD%BF%E7%94%A8%E8%87%AA%E5%8A%A8%E6%93%8D%E4%BD%9C%E4%BF%AE%E6%94%B9%E5%A3%81%E7%BA%B8/</guid>
      <description>好久没水博客了，今天折腾折腾一个一直在系统里但是没用过的工具：自动操作（Automator）.
首先打开自动操作，新建一个文稿。选择“应用程序”最终可以像其他app一样，点击就执行。但我希望的是每天自动更换，所以这里我选择“日历提醒”。
下载壁纸 “自动操作”的使用方法还是很简单的，把左边的命令拖动过来稍加编辑就可以了。所以，我们得到了
这里用的是Unsplash提供的随机壁纸服务，壁纸还是很合我的胃口的。图中URL：https://source.unsplash.com/random/3584x2240。这里的“3584x2240”根据你的显示器分辨率填写。
设置壁纸 虽然“自动操作”的资源库中有“设置壁纸”这个能力，但我实际测试发现它只能改当前屏幕的壁纸，对于我用双屏的来说就比较难受了。因而这里要用Apple Script来实现：
图中的脚本为：
on run {input, parameters}set theFile to first item of inputset filename to the POSIX path of theFiletell application &amp;#34;System Events&amp;#34;tell every desktopset picture to filenameend tellend tellreturn filenameend run 清理垃圾 这个简单，删除所有不是今天创建的图片就行了。
每天执行 保存后，打开日程应用，可以看到出现了一条刚刚添加的日程。使用Command+E快捷键修改日程，“重复”改为每天。最终结果：
最后效果
摸鱼结束，我去搬砖了。</description>
    </item>
    
    <item>
      <title>把你的光猫变成一个丐版nas</title>
      <link>https://ntutn.top/posts/%E6%8A%8A%E4%BD%A0%E7%9A%84%E5%85%89%E7%8C%AB%E5%8F%98%E6%88%90%E4%B8%80%E4%B8%AA%E4%B8%90%E7%89%88nas/</link>
      <pubDate>Tue, 12 Apr 2022 01:21:54 +0800</pubDate>
      
      <guid>https://ntutn.top/posts/%E6%8A%8A%E4%BD%A0%E7%9A%84%E5%85%89%E7%8C%AB%E5%8F%98%E6%88%90%E4%B8%80%E4%B8%AA%E4%B8%90%E7%89%88nas/</guid>
      <description>把你的光猫变成一个丐版NAS 我的初衷是调研下光猫改桥接的可行性，结果拿到超级管理员密码后还是没有这个选项。但在这个过程中发现直接在光猫上跑个下载服务却是可行的。
允许FTP访问和telnet访问 访问 http://192.168.1.1 ，输入密码后进入光猫管理后台。这里我找到“上网帐号设置”，备份宽带帐号和密码。不得不说他系统还是挺拉的，密码框直接用审查元素功能把 type 改为 input 就可以看到密码了。
第一步后台不要退出，访问 http://192.168.1.1/servmngr.html 。这里看到一个空白页面，审查元素后发现大有乾坤。 将这些代码取消注释，此时网页还是空白的，但是用 Ctrl+A 可以看到实际是有内容的。在这个页面开启 telnet 访问，并设置密码。注意用户名为 admin 不要改，否则后面 telnet 登陆不进去。
telnet 192.168.1.1 成功后执行sh。然后uname -a看下。这里我就不记录查看管理员密码步骤了，反正这个型号管理员面板也没有设置桥接的选项。
开始整活 top，发现占用内存最高的是个两个 java 进程。java -version，发现安装了 java8 。
# java -version openjdk version &amp;#34;1.8.0-internal&amp;#34; OpenJDK Runtime Environment (build 1.8.0-internal-jenkinsang_2022_01_15_04_03-b00) JamVM (build 2.0.0, inline-threaded interpreter with stack-caching) free命令可知总内存约二十多兆，剩余仅 3 兆。这点空间是搞不了什么事情的，因此我尝试干掉前述两个 java 进程。ps -aux | grep java，发现除了存在两个 java 进程，还写了脚本自动把这两个进程拉起来，即/etc/monitor_java.sh 。统统 kill 掉。
现在有 10 兆左右的内存了，对于 java 来说可能还是不太能搞事，但跑个 aria2 足够了！尝试插入 U 盘，发现在/mnt/usb1_1自动挂载。</description>
    </item>
    
    <item>
      <title>写产品和写demo的区别</title>
      <link>https://ntutn.top/posts/%E5%86%99%E4%BA%A7%E5%93%81%E5%92%8C%E5%86%99demo%E7%9A%84%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Tue, 15 Dec 2020 03:11:37 +0800</pubDate>
      
      <guid>https://ntutn.top/posts/%E5%86%99%E4%BA%A7%E5%93%81%E5%92%8C%E5%86%99demo%E7%9A%84%E5%8C%BA%E5%88%AB/</guid>
      <description>上次写的功能灰度报了几例crash，定位是我这里某个变量NPE了。
说实话，在Java中NPE是我们最常打交道的异常了，但Kotlin提供的类型机制下，NPE很少了。而这里出现NPE，其实是因为我认定在当前这个流程中这个变量不会为空——你总是要先弹出菜单再点击菜单项吧，所以用了data!!.id的方式使用。
这个变量被赋值的地方只有三处，不存在多线程问题，我想破脑袋也不知道哪里为空了。最后处理只得暂时加上判空，先不崩再说。
请教同事，同事说我这是还没有分清 写产品和写demo的区别 。
写产品和写demo的区别？仔细一想，的确有道理。『写demo』只要能跑通就行了，而写产品你是要为自己写的每一行代码负责的。我之前写过不少代码，但他们大概都算『写demo』。作业只要演示的时候不崩就行了，考试只要通过样例就行了，练手的项目写起来更是随心，反正自己就是用户，啥时候崩了啥时候debug，方便的很……
但『写产品』不同，你的程序不止要能完成需要的功能，还要在用户不按套路出牌的时候不出错。今天你迟到一分钟，咱班四十个学生等你一分钟就是一节课，你浪费了大家一节课时间…… 虽然这么算不对，但也不能算全错。你的产品面向千千万万用户，任何小瑕疵都可能放大成一场事故。记得那个著名的ATM机的bug，就是因为用户选择了取消，然后插入了银行卡……
回到我这个Issue，虽然从业务逻辑的角度看用户操作后这个变量是不会为null的，但仍然应该有判空，有兜底的逻辑，这样你的程序才会更加健壮。
Kotlin的空安全 与Java不同，Kotlin的类型系统在设计时就考虑了变量是否可空1，其用一个?表示变量是否能为空。
var a: String = &amp;#34;abc&amp;#34; // 默认情况下，常规初始化意味着非空 a = null // 编译错误 var b: String? = &amp;#34;abc&amp;#34; // 可以设置为空 b = null // ok print(b) 判空 Kotlin有一定的类型推断能力，判空后进行赋值操作前能识别出变量是非空的类型。
val b: String? = &amp;#34;Kotlin&amp;#34; if (b != null &amp;amp;&amp;amp; b.length &amp;gt; 0) { print(&amp;#34;String of length ${b.length}&amp;#34;) } else { print(&amp;#34;Empty string&amp;#34;) } 安全调用 Kotlin中提供了?.来安全调用一个可能为空的变量。b?.test()相当于if (b != null) b.test()。</description>
    </item>
    
    <item>
      <title>直</title>
      <link>https://ntutn.top/posts/%E7%9B%B4/</link>
      <pubDate>Wed, 27 Mar 2019 03:11:37 +0800</pubDate>
      
      <guid>https://ntutn.top/posts/%E7%9B%B4/</guid>
      <description>直 发现了自己初中写的作文，我当年这么中二的吗……
树是直的，直得挺拔入云；山是直的，直得直插霄汉；竹是直的直得虚心髙洁。是啊，巍峨的直无处不在。
尺 人们仰慕大自然的直，于是制造了尺。尺，为直而生。再纷乱的外界环境，它总恪尽职守，一丝不苟。即使是它的制造者，它也将毫不留情地指出他的过失。
人本如此。看到它，我想起了屈子，想起了岳将军，想起包拯，想起了正直的中国人。
弓 尺是直的，但在不可抗力下它还是弯曲了。有时弯也是一种无奈，正直的树也抵不住弯曲的斧。那就弯吧。不！你没看到，弦是直的。弦如何直？那是弓在抗拒那股不可抗力！是啊，弓是弯的，但它的心是直的。它仍是一心向直的。
人应如此。狂风袭来，竹顺势而弯，但风速减小了。虽然只有一点。看到它，我想到了周树人，想到了郭沫若，想到了在黑暗中抗争的中国人。
箭 弓是弯的，但它不甘继续弯下去。于是它化作一支羽箭，反射着金色阳光，即使这直是有代价的。它是一根选择燃烧的火柴。它将烧尽，但它选择了燃烧。
看到它，我想到了荆轲，想到了谭嗣同，想到了敢于与黑暗抗争的中国人。
中华民族是一个直的民族，中国人本色如此。中国人是直的，即使在不可抗力下弯了，心还是直的。而且，他们会抗争，不管那是不是不可抗力。在忍无可忍时，他们会用自己的生命，划出一道直线。中国，拉着这样的弓，射出这样的箭，复兴也是必然的。
这就是那个直的传说。</description>
    </item>
    
  </channel>
</rss>
